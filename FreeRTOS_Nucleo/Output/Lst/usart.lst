   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.eabi_attribute 28, 1
   5              		.fpu fpv4-sp-d16
   6              		.eabi_attribute 20, 1
   7              		.eabi_attribute 21, 1
   8              		.eabi_attribute 23, 3
   9              		.eabi_attribute 24, 1
  10              		.eabi_attribute 25, 1
  11              		.eabi_attribute 26, 1
  12              		.eabi_attribute 30, 2
  13              		.eabi_attribute 34, 1
  14              		.eabi_attribute 18, 4
  15              		.thumb
  16              		.file	"usart.c"
  17              		.text
  18              	.Ltext0:
  19              		.cfi_sections	.debug_frame
  20              		.section	.text.USART_Config,"ax",%progbits
  21              		.align	2
  22              		.global	USART_Config
  23              		.thumb
  24              		.thumb_func
  26              	USART_Config:
  27              	.LFB123:
  28              		.file 1 "usart/usart.c"
   1:usart/usart.c **** /*
   2:usart/usart.c ****  * usart.c
   3:usart/usart.c ****  *
   4:usart/usart.c ****  *  Created on: Apr 15, 2015
   5:usart/usart.c ****  *      Author: toandang
   6:usart/usart.c ****  */
   7:usart/usart.c **** #include "usart.h"
   8:usart/usart.c **** 
   9:usart/usart.c **** void USART_Config(void)
  10:usart/usart.c **** {
  29              		.loc 1 10 0
  30              		.cfi_startproc
  31              		@ args = 0, pretend = 0, frame = 32
  32              		@ frame_needed = 0, uses_anonymous_args = 0
  33 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
  34              	.LCFI0:
  35              		.cfi_def_cfa_offset 24
  36              		.cfi_offset 4, -24
  37              		.cfi_offset 5, -20
  38              		.cfi_offset 6, -16
  39              		.cfi_offset 7, -12
  40              		.cfi_offset 8, -8
  41              		.cfi_offset 14, -4
  42 0004 88B0     		sub	sp, sp, #32
  43              	.LCFI1:
  44              		.cfi_def_cfa_offset 56
  11:usart/usart.c ****   GPIO_InitTypeDef GPIO_InitStructure;
  12:usart/usart.c ****   NVIC_InitTypeDef NVIC_InitStructure;
  13:usart/usart.c ****   USART_InitTypeDef USART_InitStructure;
  14:usart/usart.c **** 
  15:usart/usart.c ****   NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn;
  45              		.loc 1 15 0
  46 0006 08A8     		add	r0, sp, #32
  47 0008 4FF49373 		mov	r3, #294
  48 000c C0F20013 		movt	r3, 256
  49 0010 40F81C3D 		str	r3, [r0, #-28]!
  16:usart/usart.c ****   NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
  17:usart/usart.c ****   NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
  18:usart/usart.c ****   NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
  19:usart/usart.c ****   NVIC_Init(&NVIC_InitStructure);
  50              		.loc 1 19 0
  51 0014 FFF7FEFF 		bl	NVIC_Init
  52              	.LVL0:
  20:usart/usart.c **** 
  21:usart/usart.c ****   // sort out clocks
  22:usart/usart.c ****   RCC_AHB1PeriphClockCmd( RCC_AHB1Periph_GPIOA, ENABLE);
  53              		.loc 1 22 0
  54 0018 0120     		movs	r0, #1
  55 001a 0146     		mov	r1, r0
  23:usart/usart.c ****   RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
  24:usart/usart.c ****   /* Configure USART2 Tx (PA.02) as alternate function push-pull */
  25:usart/usart.c ****   GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
  26:usart/usart.c ****   GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  27:usart/usart.c ****   GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
  28:usart/usart.c ****   GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  29:usart/usart.c ****   GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
  30:usart/usart.c ****   GPIO_Init(GPIOA, &GPIO_InitStructure);
  56              		.loc 1 30 0
  57 001c 0027     		movs	r7, #0
  22:usart/usart.c ****   RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
  58              		.loc 1 22 0
  59 001e FFF7FEFF 		bl	RCC_AHB1PeriphClockCmd
  60              	.LVL1:
  61              		.loc 1 30 0
  62 0022 C4F20207 		movt	r7, 16386
  23:usart/usart.c ****   RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
  63              		.loc 1 23 0
  64 0026 4FF40030 		mov	r0, #131072
  65 002a 0121     		movs	r1, #1
  66 002c FFF7FEFF 		bl	RCC_APB1PeriphClockCmd
  67              	.LVL2:
  28:usart/usart.c ****   GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
  68              		.loc 1 28 0
  69 0030 0024     		movs	r4, #0
  26:usart/usart.c ****   GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
  70              		.loc 1 26 0
  71 0032 0226     		movs	r6, #2
  25:usart/usart.c ****   GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  72              		.loc 1 25 0
  73 0034 0423     		movs	r3, #4
  74              		.loc 1 30 0
  75 0036 3846     		mov	r0, r7
  29:usart/usart.c ****   GPIO_Init(GPIOA, &GPIO_InitStructure);
  76              		.loc 1 29 0
  77 0038 4FF00108 		mov	r8, #1
  78              		.loc 1 30 0
  79 003c 02A9     		add	r1, sp, #8
  31:usart/usart.c ****   // Map USART2 to A.02
  32:usart/usart.c ****   GPIO_PinAFConfig(GPIOA, GPIO_PinSource2, GPIO_AF_USART2);
  33:usart/usart.c ****   // Initialize USART
  34:usart/usart.c ****   USART_InitStructure.USART_BaudRate = 115200;
  35:usart/usart.c ****   USART_InitStructure.USART_WordLength = USART_WordLength_8b;
  36:usart/usart.c ****   USART_InitStructure.USART_StopBits = USART_StopBits_1;
  37:usart/usart.c ****   USART_InitStructure.USART_Parity = USART_Parity_No;
  38:usart/usart.c ****   USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
  39:usart/usart.c ****   USART_InitStructure.USART_Mode = USART_Mode_Tx;
  40:usart/usart.c ****   /* Configure USART */
  41:usart/usart.c ****   USART_Init(USART2, &USART_InitStructure);
  80              		.loc 1 41 0
  81 003e 4FF48845 		mov	r5, #17408
  25:usart/usart.c ****   GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  82              		.loc 1 25 0
  83 0042 0293     		str	r3, [sp, #8]
  84              		.loc 1 41 0
  85 0044 C4F20005 		movt	r5, 16384
  26:usart/usart.c ****   GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
  86              		.loc 1 26 0
  87 0048 8DF80D60 		strb	r6, [sp, #13]
  27:usart/usart.c ****   GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  88              		.loc 1 27 0
  89 004c 8DF80C60 		strb	r6, [sp, #12]
  28:usart/usart.c ****   GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
  90              		.loc 1 28 0
  91 0050 8DF80E40 		strb	r4, [sp, #14]
  29:usart/usart.c ****   GPIO_Init(GPIOA, &GPIO_InitStructure);
  92              		.loc 1 29 0
  93 0054 8DF80F80 		strb	r8, [sp, #15]
  30:usart/usart.c ****   // Map USART2 to A.02
  94              		.loc 1 30 0
  95 0058 FFF7FEFF 		bl	GPIO_Init
  96              	.LVL3:
  32:usart/usart.c ****   // Initialize USART
  97              		.loc 1 32 0
  98 005c 3846     		mov	r0, r7
  99 005e 3146     		mov	r1, r6
 100 0060 0722     		movs	r2, #7
 101 0062 FFF7FEFF 		bl	GPIO_PinAFConfig
 102              	.LVL4:
  34:usart/usart.c ****   USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 103              		.loc 1 34 0
 104 0066 4FF4E132 		mov	r2, #115200
  39:usart/usart.c ****   /* Configure USART */
 105              		.loc 1 39 0
 106 006a 0823     		movs	r3, #8
 107              		.loc 1 41 0
 108 006c 2846     		mov	r0, r5
 109 006e 04A9     		add	r1, sp, #16
  34:usart/usart.c ****   USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 110              		.loc 1 34 0
 111 0070 0492     		str	r2, [sp, #16]
  39:usart/usart.c ****   /* Configure USART */
 112              		.loc 1 39 0
 113 0072 ADF81A30 		strh	r3, [sp, #26]	@ movhi
  35:usart/usart.c ****   USART_InitStructure.USART_StopBits = USART_StopBits_1;
 114              		.loc 1 35 0
 115 0076 ADF81440 		strh	r4, [sp, #20]	@ movhi
  36:usart/usart.c ****   USART_InitStructure.USART_Parity = USART_Parity_No;
 116              		.loc 1 36 0
 117 007a ADF81640 		strh	r4, [sp, #22]	@ movhi
  37:usart/usart.c ****   USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
 118              		.loc 1 37 0
 119 007e ADF81840 		strh	r4, [sp, #24]	@ movhi
  38:usart/usart.c ****   USART_InitStructure.USART_Mode = USART_Mode_Tx;
 120              		.loc 1 38 0
 121 0082 ADF81C40 		strh	r4, [sp, #28]	@ movhi
 122              		.loc 1 41 0
 123 0086 FFF7FEFF 		bl	USART_Init
 124              	.LVL5:
  42:usart/usart.c ****   /* Enable the USART */
  43:usart/usart.c ****   USART_Cmd(USART2, ENABLE);
 125              		.loc 1 43 0
 126 008a 2846     		mov	r0, r5
 127 008c 4146     		mov	r1, r8
 128 008e FFF7FEFF 		bl	USART_Cmd
 129              	.LVL6:
  44:usart/usart.c **** }
 130              		.loc 1 44 0
 131 0092 08B0     		add	sp, sp, #32
 132              		@ sp needed
 133 0094 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 134              		.cfi_endproc
 135              	.LFE123:
 137              		.section	.text.USART2_IRQHandler,"ax",%progbits
 138              		.align	2
 139              		.global	USART2_IRQHandler
 140              		.thumb
 141              		.thumb_func
 143              	USART2_IRQHandler:
 144              	.LFB124:
  45:usart/usart.c **** 
  46:usart/usart.c **** void USART2_IRQHandler(void)
  47:usart/usart.c **** {
 145              		.loc 1 47 0
 146              		.cfi_startproc
 147              		@ args = 0, pretend = 0, frame = 8
 148              		@ frame_needed = 0, uses_anonymous_args = 0
 149 0000 00B5     		push	{lr}
 150              	.LCFI2:
 151              		.cfi_def_cfa_offset 4
 152              		.cfi_offset 14, -4
  48:usart/usart.c ****   uint8_t data;
  49:usart/usart.c ****   int status;
  50:usart/usart.c ****   if (USART_GetITStatus(USART2,USART_IT_TXE)!= RESET)
 153              		.loc 1 50 0
 154 0002 4FF48840 		mov	r0, #17408
  47:usart/usart.c ****   uint8_t data;
 155              		.loc 1 47 0
 156 0006 83B0     		sub	sp, sp, #12
 157              	.LCFI3:
 158              		.cfi_def_cfa_offset 16
 159              		.loc 1 50 0
 160 0008 C4F20000 		movt	r0, 16384
 161 000c 40F22771 		movw	r1, #1831
 162 0010 FFF7FEFF 		bl	USART_GetITStatus
 163              	.LVL7:
 164 0014 10B9     		cbnz	r0, .L10
  51:usart/usart.c ****       {
  52:usart/usart.c ****         LED_On();
  53:usart/usart.c ****         status = GetFifo( &data);
  54:usart/usart.c ****         if(!status)
  55:usart/usart.c ****           {
  56:usart/usart.c ****             USART_ITConfig(USART2,USART_IT_TXE,DISABLE);
  57:usart/usart.c ****             return;
  58:usart/usart.c ****           }
  59:usart/usart.c ****         //GetFifo( &data);
  60:usart/usart.c ****         USART_SendData(USART2, data);
  61:usart/usart.c **** 
  62:usart/usart.c ****       }
  63:usart/usart.c **** }
 165              		.loc 1 63 0
 166 0016 03B0     		add	sp, sp, #12
 167              		@ sp needed
 168 0018 5DF804FB 		ldr	pc, [sp], #4
 169              	.L10:
 170              	.LBB7:
  52:usart/usart.c ****         status = GetFifo( &data);
 171              		.loc 1 52 0
 172 001c FFF7FEFF 		bl	LED_On
 173              	.LVL8:
  53:usart/usart.c ****         if(!status)
 174              		.loc 1 53 0
 175 0020 6846     		mov	r0, sp
 176 0022 FFF7FEFF 		bl	GetFifo
 177              	.LVL9:
  54:usart/usart.c ****           {
 178              		.loc 1 54 0
 179 0026 0246     		mov	r2, r0
  56:usart/usart.c ****             return;
 180              		.loc 1 56 0
 181 0028 4FF48840 		mov	r0, #17408
 182              	.LVL10:
 183 002c C4F20000 		movt	r0, 16384
  54:usart/usart.c ****           {
 184              		.loc 1 54 0
 185 0030 32B1     		cbz	r2, .L11
  60:usart/usart.c **** 
 186              		.loc 1 60 0
 187 0032 9DF80010 		ldrb	r1, [sp]	@ zero_extendqisi2
 188 0036 FFF7FEFF 		bl	USART_SendData
 189              	.LVL11:
 190              	.LBE7:
 191              		.loc 1 63 0
 192 003a 03B0     		add	sp, sp, #12
 193              		@ sp needed
 194 003c 5DF804FB 		ldr	pc, [sp], #4
 195              	.LVL12:
 196              	.L11:
 197              	.LBB8:
  56:usart/usart.c ****             return;
 198              		.loc 1 56 0
 199 0040 40F22771 		movw	r1, #1831
 200 0044 FFF7FEFF 		bl	USART_ITConfig
 201              	.LVL13:
 202              	.LBE8:
 203              		.loc 1 63 0
 204 0048 03B0     		add	sp, sp, #12
 205              		@ sp needed
 206 004a 5DF804FB 		ldr	pc, [sp], #4
 207              		.cfi_endproc
 208              	.LFE124:
 210 004e 00BF     		.section	.text.USARTPutchar,"ax",%progbits
 211              		.align	2
 212              		.global	USARTPutchar
 213              		.thumb
 214              		.thumb_func
 216              	USARTPutchar:
 217              	.LFB125:
  64:usart/usart.c **** 
  65:usart/usart.c **** void USARTPutchar(char* ch)
  66:usart/usart.c **** {
 218              		.loc 1 66 0
 219              		.cfi_startproc
 220              		@ args = 0, pretend = 0, frame = 0
 221              		@ frame_needed = 0, uses_anonymous_args = 0
 222              	.LVL14:
 223 0000 10B5     		push	{r4, lr}
 224              	.LCFI4:
 225              		.cfi_def_cfa_offset 8
 226              		.cfi_offset 4, -8
 227              		.cfi_offset 14, -4
 228              		.loc 1 66 0
 229 0002 0446     		mov	r4, r0
  67:usart/usart.c ****   while(*ch!= 0)
 230              		.loc 1 67 0
 231 0004 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 232              	.LVL15:
 233 0006 28B1     		cbz	r0, .L12
 234              	.LVL16:
 235              	.L15:
  68:usart/usart.c ****     {
  69:usart/usart.c ****       PutFifo(*ch++);
 236              		.loc 1 69 0
 237 0008 FFF7FEFF 		bl	PutFifo
 238              	.LVL17:
  67:usart/usart.c ****   while(*ch!= 0)
 239              		.loc 1 67 0
 240 000c 14F8010F 		ldrb	r0, [r4, #1]!	@ zero_extendqisi2
 241              	.LVL18:
 242 0010 0028     		cmp	r0, #0
 243 0012 F9D1     		bne	.L15
 244              	.LVL19:
 245              	.L12:
 246 0014 10BD     		pop	{r4, pc}
 247              		.cfi_endproc
 248              	.LFE125:
 250 0016 00BF     		.section	.text.vDebugPrintf,"ax",%progbits
 251              		.align	2
 252              		.global	vDebugPrintf
 253              		.thumb
 254              		.thumb_func
 256              	vDebugPrintf:
 257              	.LFB126:
  70:usart/usart.c ****     }
  71:usart/usart.c **** }
  72:usart/usart.c **** void vDebugPrintf(const char *fmt, ...) {
 258              		.loc 1 72 0
 259              		.cfi_startproc
 260              		@ args = 4, pretend = 16, frame = 128
 261              		@ frame_needed = 0, uses_anonymous_args = 1
 262              	.LVL20:
 263 0000 0FB4     		push	{r0, r1, r2, r3}
 264              	.LCFI5:
 265              		.cfi_def_cfa_offset 16
 266              		.cfi_offset 0, -16
 267              		.cfi_offset 1, -12
 268              		.cfi_offset 2, -8
 269              		.cfi_offset 3, -4
 270 0002 2DE9F043 		push	{r4, r5, r6, r7, r8, r9, lr}
 271              	.LCFI6:
 272              		.cfi_def_cfa_offset 44
 273              		.cfi_offset 4, -44
 274              		.cfi_offset 5, -40
 275              		.cfi_offset 6, -36
 276              		.cfi_offset 7, -32
 277              		.cfi_offset 8, -28
 278              		.cfi_offset 9, -24
 279              		.cfi_offset 14, -20
 280 0006 A1B0     		sub	sp, sp, #132
 281              	.LCFI7:
 282              		.cfi_def_cfa_offset 176
 283              		.loc 1 72 0
 284 0008 28AD     		add	r5, sp, #160
 285              	.LBB22:
  73:usart/usart.c **** 	char sTmp[80];	// String build area.  String lives on the stack!
  74:usart/usart.c **** 	uint8_t pos=0;
  75:usart/usart.c **** 	char *bp = (char *)fmt;
  76:usart/usart.c ****     va_list ap;
  77:usart/usart.c ****     char c;
  78:usart/usart.c ****     char *p;
  79:usart/usart.c ****     int i;
  80:usart/usart.c **** 
  81:usart/usart.c **** 	/* Print the string, suspending the scheduler as method of mutual
  82:usart/usart.c **** 	exclusion. */
  83:usart/usart.c ****     //__disable_irq();
  84:usart/usart.c **** 	vTaskSuspendAll();
  85:usart/usart.c **** 
  86:usart/usart.c ****     va_start(ap, fmt);
  87:usart/usart.c **** 
  88:usart/usart.c ****     while ((c = *bp++)) {
  89:usart/usart.c ****         if (c != '%') {
  90:usart/usart.c ****             sTmp[pos++] = c;
  91:usart/usart.c ****             continue;
  92:usart/usart.c ****         }
  93:usart/usart.c **** 
  94:usart/usart.c ****         switch ((c = *bp++)) {
  95:usart/usart.c **** 			// d - decimal value
  96:usart/usart.c **** 			case 'd':
  97:usart/usart.c **** 				vNum2String(sTmp, &pos, va_arg(ap, uint32_t), 10);
  98:usart/usart.c **** 				break;
  99:usart/usart.c **** 
 100:usart/usart.c **** 			// %x - value in hex
 101:usart/usart.c **** 			case 'x':
 102:usart/usart.c **** 				sTmp[pos++] = '0';
 103:usart/usart.c **** 				sTmp[pos++] = 'x';
 104:usart/usart.c **** 				vNum2String(sTmp, &pos, va_arg(ap, uint32_t), 16);
 105:usart/usart.c **** 				break;
 106:usart/usart.c **** 
 107:usart/usart.c **** 			// %b - binary
 108:usart/usart.c **** 			case 'b':
 109:usart/usart.c **** 				sTmp[pos++] = '0';
 110:usart/usart.c **** 				sTmp[pos++] = 'b';
 111:usart/usart.c **** 				vNum2String(sTmp, &pos, va_arg(ap, uint32_t), 2);
 112:usart/usart.c **** 				break;
 113:usart/usart.c **** 
 114:usart/usart.c **** 			// %c - character
 115:usart/usart.c **** 			case 'c':
 116:usart/usart.c **** 				sTmp[pos++] = va_arg(ap, int);
 117:usart/usart.c **** 				break;
 118:usart/usart.c **** 
 119:usart/usart.c **** 			// %i - integer
 120:usart/usart.c **** 			case 'i':
 121:usart/usart.c **** 				i = va_arg(ap, int32_t);
 122:usart/usart.c **** 				if(i < 0){
 123:usart/usart.c **** 					sTmp[pos++] = '-';
 124:usart/usart.c **** 					vNum2String(sTmp, &pos, (~i)+1, 10);
 125:usart/usart.c **** 				} else {
 126:usart/usart.c **** 					vNum2String(sTmp, &pos, i, 10);
 127:usart/usart.c **** 				}
 128:usart/usart.c **** 				break;
 129:usart/usart.c **** 
 130:usart/usart.c **** 			// %s - string
 131:usart/usart.c **** 			case 's':
 132:usart/usart.c **** 				p = va_arg(ap, char *);
 133:usart/usart.c **** 				do {
 134:usart/usart.c **** 					sTmp[pos++] = *p++;
 135:usart/usart.c **** 				} while (*p);
 136:usart/usart.c **** 				break;
 137:usart/usart.c **** 
 138:usart/usart.c **** 			// %% - output % character
 139:usart/usart.c **** 			case '%':
 140:usart/usart.c **** 				sTmp[pos++] = '%';
 141:usart/usart.c **** 				break;
 142:usart/usart.c **** 
 143:usart/usart.c **** 			// Else, must be something else not handled.
 144:usart/usart.c **** 			default:
 145:usart/usart.c **** 				sTmp[pos++] = '?';
 286              		.loc 1 145 0
 287 000a 3F27     		movs	r7, #63
 288              	.LBE22:
  72:usart/usart.c **** 	char sTmp[80];	// String build area.  String lives on the stack!
 289              		.loc 1 72 0
 290 000c 55F8044B 		ldr	r4, [r5], #4
 291              	.LVL21:
  84:usart/usart.c **** 
 292              		.loc 1 84 0
 293 0010 FFF7FEFF 		bl	vTaskSuspendAll
 294              	.LVL22:
  74:usart/usart.c **** 	char *bp = (char *)fmt;
 295              		.loc 1 74 0
 296 0014 0023     		movs	r3, #0
 297              	.LBB47:
 298              	.LBB23:
 299              	.LBB24:
 146:usart/usart.c **** 				break;
 147:usart/usart.c ****         }
 148:usart/usart.c ****     }
 149:usart/usart.c ****     sTmp[pos++] = 0;		// Mark the end of the string.
 150:usart/usart.c ****     USARTPutchar(sTmp);	// Copy the string into the OS queue.
 151:usart/usart.c **** 
 152:usart/usart.c ****     /* Resume the scheduler as method of mutual exclusion. */
 153:usart/usart.c **** 	xTaskResumeAll();
 154:usart/usart.c **** 	//__enable_irq();
 155:usart/usart.c ****     return;
 156:usart/usart.c **** }
 157:usart/usart.c **** void USARTPritnf(const char * format, ...)
 158:usart/usart.c **** {
 159:usart/usart.c **** 	char stmp[100];
 160:usart/usart.c **** //	va_list args;
 161:usart/usart.c **** //	va_start (args, format);
 162:usart/usart.c **** //	sprintf(stmp,format,args);
 163:usart/usart.c **** //	va_end (args);
 164:usart/usart.c **** 
 165:usart/usart.c **** 	USARTPutchar(stmp);
 166:usart/usart.c **** }
 167:usart/usart.c **** 
 168:usart/usart.c **** void vNum2String(char *s, uint8_t *pPos, uint32_t u32Number, uint8_t u8Base) {
 169:usart/usart.c **** 
 170:usart/usart.c ****     char buf[33];
 171:usart/usart.c ****     char *p = buf + 33;
 172:usart/usart.c ****     uint32_t c, n;
 173:usart/usart.c **** 
 174:usart/usart.c ****     *--p = '\0';
 175:usart/usart.c ****     do {
 176:usart/usart.c ****         n = u32Number / u8Base;
 300              		.loc 1 176 0
 301 0016 4CF6CD40 		movw	r0, #52429
 302              	.LBE24:
 303              	.LBE23:
 304              	.LBE47:
  86:usart/usart.c **** 
 305              		.loc 1 86 0
 306 001a 0195     		str	r5, [sp, #4]
 307              	.LBB48:
 308              	.LBB28:
 309              	.LBB25:
 310              		.loc 1 176 0
 311 001c CCF6CC40 		movt	r0, 52428
 174:usart/usart.c ****     do {
 312              		.loc 1 174 0
 313 0020 1D46     		mov	r5, r3
 314              	.LBE25:
 315              	.LBE28:
 102:usart/usart.c **** 				sTmp[pos++] = 'x';
 316              		.loc 1 102 0
 317 0022 3026     		movs	r6, #48
 123:usart/usart.c **** 					vNum2String(sTmp, &pos, (~i)+1, 10);
 318              		.loc 1 123 0
 319 0024 4FF02D0E 		mov	lr, #45
 320              	.LVL23:
 321              	.L20:
 322              	.LBE48:
  88:usart/usart.c ****         if (c != '%') {
 323              		.loc 1 88 0 discriminator 1
 324 0028 2278     		ldrb	r2, [r4]	@ zero_extendqisi2
 325              	.LVL24:
 326 002a 5AB1     		cbz	r2, .L91
 327              	.LVL25:
 328              	.L54:
  89:usart/usart.c ****             sTmp[pos++] = c;
 329              		.loc 1 89 0
 330 002c 252A     		cmp	r2, #37
 331 002e 1FD0     		beq	.L21
  90:usart/usart.c ****             continue;
 332              		.loc 1 90 0
 333 0030 20A9     		add	r1, sp, #128
 334 0032 1944     		add	r1, r1, r3
  88:usart/usart.c ****         if (c != '%') {
 335              		.loc 1 88 0
 336 0034 0134     		adds	r4, r4, #1
  90:usart/usart.c ****             continue;
 337              		.loc 1 90 0
 338 0036 01F8502C 		strb	r2, [r1, #-80]
  88:usart/usart.c ****         if (c != '%') {
 339              		.loc 1 88 0
 340 003a 2278     		ldrb	r2, [r4]	@ zero_extendqisi2
  90:usart/usart.c ****             continue;
 341              		.loc 1 90 0
 342 003c 0133     		adds	r3, r3, #1
 343              	.LVL26:
 344 003e DBB2     		uxtb	r3, r3
 345              	.LVL27:
  88:usart/usart.c ****         if (c != '%') {
 346              		.loc 1 88 0
 347 0040 002A     		cmp	r2, #0
 348 0042 F3D1     		bne	.L54
 349              	.LVL28:
 350              	.L91:
 149:usart/usart.c ****     USARTPutchar(sTmp);	// Copy the string into the OS queue.
 351              		.loc 1 149 0
 352 0044 0DF1800C 		add	ip, sp, #128
 353 0048 6344     		add	r3, r3, ip
 354              	.LVL29:
 355 004a 0CAC     		add	r4, sp, #48
 356 004c 03F8502C 		strb	r2, [r3, #-80]
 357              	.LVL30:
 358              	.LBB49:
 359              	.LBB50:
  67:usart/usart.c ****     {
 360              		.loc 1 67 0
 361 0050 9DF83000 		ldrb	r0, [sp, #48]	@ zero_extendqisi2
 362 0054 28B1     		cbz	r0, .L56
 363              	.LVL31:
 364              	.L57:
  69:usart/usart.c ****     }
 365              		.loc 1 69 0
 366 0056 FFF7FEFF 		bl	PutFifo
 367              	.LVL32:
  67:usart/usart.c ****     {
 368              		.loc 1 67 0
 369 005a 14F8010F 		ldrb	r0, [r4, #1]!	@ zero_extendqisi2
 370              	.LVL33:
 371 005e 0028     		cmp	r0, #0
 372 0060 F9D1     		bne	.L57
 373              	.LVL34:
 374              	.L56:
 375              	.LBE50:
 376              	.LBE49:
 153:usart/usart.c **** 	//__enable_irq();
 377              		.loc 1 153 0
 378 0062 FFF7FEFF 		bl	xTaskResumeAll
 379              	.LVL35:
 156:usart/usart.c **** void USARTPritnf(const char * format, ...)
 380              		.loc 1 156 0
 381 0066 21B0     		add	sp, sp, #132
 382              		@ sp needed
 383 0068 BDE8F043 		pop	{r4, r5, r6, r7, r8, r9, lr}
 384 006c 04B0     		add	sp, sp, #16
 385 006e 7047     		bx	lr
 386              	.L21:
  94:usart/usart.c **** 			// d - decimal value
 387              		.loc 1 94 0
 388 0070 6178     		ldrb	r1, [r4, #1]	@ zero_extendqisi2
 389 0072 6429     		cmp	r1, #100
 390 0074 04F10204 		add	r4, r4, #2
 391              	.LVL36:
 392 0078 00F0CA80 		beq	.L24
 393 007c 0DD8     		bhi	.L25
 394 007e 6229     		cmp	r1, #98
 395 0080 00F08980 		beq	.L26
 396 0084 00F2F780 		bhi	.L27
 397 0088 2529     		cmp	r1, #37
 398 008a 0DD1     		bne	.L23
 399              	.LBB51:
 140:usart/usart.c **** 				break;
 400              		.loc 1 140 0
 401 008c 20AA     		add	r2, sp, #128
 402 008e 1A44     		add	r2, r2, r3
 403 0090 0133     		adds	r3, r3, #1
 404              	.LVL37:
 405 0092 02F8501C 		strb	r1, [r2, #-80]
 406 0096 DBB2     		uxtb	r3, r3
 407              	.LVL38:
 141:usart/usart.c **** 
 408              		.loc 1 141 0
 409 0098 C6E7     		b	.L20
 410              	.L25:
 411              	.LBE51:
  94:usart/usart.c **** 			// d - decimal value
 412              		.loc 1 94 0
 413 009a 7329     		cmp	r1, #115
 414 009c 00F0F780 		beq	.L29
 415 00a0 7829     		cmp	r1, #120
 416 00a2 3BD0     		beq	.L30
 417 00a4 6929     		cmp	r1, #105
 418 00a6 06D0     		beq	.L92
 419              	.L23:
 420              	.LBB52:
 145:usart/usart.c **** 				break;
 421              		.loc 1 145 0
 422 00a8 20AA     		add	r2, sp, #128
 423 00aa 1A44     		add	r2, r2, r3
 424 00ac 0133     		adds	r3, r3, #1
 425              	.LVL39:
 426 00ae 02F8507C 		strb	r7, [r2, #-80]
 427 00b2 DBB2     		uxtb	r3, r3
 428              	.LVL40:
 146:usart/usart.c ****         }
 429              		.loc 1 146 0
 430 00b4 B8E7     		b	.L20
 431              	.L92:
 121:usart/usart.c **** 				if(i < 0){
 432              		.loc 1 121 0
 433 00b6 019A     		ldr	r2, [sp, #4]
 434 00b8 1168     		ldr	r1, [r2]
 435 00ba 0432     		adds	r2, r2, #4
 122:usart/usart.c **** 					sTmp[pos++] = '-';
 436              		.loc 1 122 0
 437 00bc 0029     		cmp	r1, #0
 121:usart/usart.c **** 				if(i < 0){
 438              		.loc 1 121 0
 439 00be 0192     		str	r2, [sp, #4]
 440              	.LVL41:
 441              	.LBB29:
 442              	.LBB30:
 174:usart/usart.c ****     do {
 443              		.loc 1 174 0
 444 00c0 A4BF     		itt	ge
 445 00c2 8DF82850 		strbge	r5, [sp, #40]
 446 00c6 0DF1270C 		addge	ip, sp, #39
 447              	.LBE30:
 448              	.LBE29:
 122:usart/usart.c **** 					sTmp[pos++] = '-';
 449              		.loc 1 122 0
 450 00ca 01DA     		bge	.L50
 451 00cc F5E0     		b	.L100
 452              	.LVL42:
 453              	.L94:
 454              	.LBB32:
 455              	.LBB31:
 177:usart/usart.c ****         c = u32Number - (n * u8Base);
 178:usart/usart.c ****         if (c < 10) {
 179:usart/usart.c ****             *--p = '0' + c;
 180:usart/usart.c ****         } else {
 181:usart/usart.c ****             *--p = 'a' + (c - 10);
 182:usart/usart.c ****         }
 183:usart/usart.c ****         u32Number /= u8Base;
 456              		.loc 1 183 0
 457 00ce 1146     		mov	r1, r2
 458              	.LVL43:
 459              	.L50:
 176:usart/usart.c ****         c = u32Number - (n * u8Base);
 460              		.loc 1 176 0
 461 00d0 A0FB0182 		umull	r8, r2, r0, r1
 462 00d4 D208     		lsrs	r2, r2, #3
 177:usart/usart.c ****         c = u32Number - (n * u8Base);
 463              		.loc 1 177 0
 464 00d6 02EB8208 		add	r8, r2, r2, lsl #2
 465 00da A1EB4801 		sub	r1, r1, r8, lsl #1
 179:usart/usart.c ****         } else {
 466              		.loc 1 179 0
 467 00de 5FFA81F8 		uxtb	r8, r1
 468 00e2 08F13009 		add	r9, r8, #48
 181:usart/usart.c ****         }
 469              		.loc 1 181 0
 470 00e6 08F15708 		add	r8, r8, #87
 471 00ea 0929     		cmp	r1, #9
 472 00ec 94BF     		ite	ls
 473 00ee 4946     		movls	r1, r9
 474 00f0 4146     		movhi	r1, r8
 475 00f2 C9B2     		uxtb	r1, r1
 476 00f4 E046     		mov	r8, ip
 477 00f6 0CF80119 		strb	r1, [ip], #-1
 478              	.LVL44:
 184:usart/usart.c ****     } while (u32Number != 0);
 479              		.loc 1 184 0
 480 00fa 002A     		cmp	r2, #0
 481 00fc E7D1     		bne	.L94
 482              	.LVL45:
 185:usart/usart.c **** 
 186:usart/usart.c ****     while (*p){
 483              		.loc 1 186 0
 484 00fe 0029     		cmp	r1, #0
 485 0100 92D0     		beq	.L20
 486 0102 4246     		mov	r2, r8
 487              	.LVL46:
 488              	.L52:
 187:usart/usart.c ****     	s[ *pPos ] = *p;
 489              		.loc 1 187 0
 490 0104 0DF1800C 		add	ip, sp, #128
 491 0108 9C44     		add	ip, ip, r3
 188:usart/usart.c ****     	*pPos += 1;
 492              		.loc 1 188 0
 493 010a 0133     		adds	r3, r3, #1
 494              	.LVL47:
 187:usart/usart.c ****     	s[ *pPos ] = *p;
 495              		.loc 1 187 0
 496 010c 0CF8501C 		strb	r1, [ip, #-80]
 186:usart/usart.c ****     	s[ *pPos ] = *p;
 497              		.loc 1 186 0
 498 0110 12F8011F 		ldrb	r1, [r2, #1]!	@ zero_extendqisi2
 499              	.LVL48:
 500              		.loc 1 188 0
 501 0114 DBB2     		uxtb	r3, r3
 502              	.LVL49:
 186:usart/usart.c ****     	s[ *pPos ] = *p;
 503              		.loc 1 186 0
 504 0116 0029     		cmp	r1, #0
 505 0118 F4D1     		bne	.L52
 506 011a 85E7     		b	.L20
 507              	.LVL50:
 508              	.L30:
 509              	.LBE31:
 510              	.LBE32:
 103:usart/usart.c **** 				vNum2String(sTmp, &pos, va_arg(ap, uint32_t), 16);
 511              		.loc 1 103 0
 512 011c 0DF1800C 		add	ip, sp, #128
 104:usart/usart.c **** 				break;
 513              		.loc 1 104 0
 514 0120 019A     		ldr	r2, [sp, #4]
 515              	.LBB33:
 516              	.LBB34:
 174:usart/usart.c ****     do {
 517              		.loc 1 174 0
 518 0122 8DF82850 		strb	r5, [sp, #40]
 519              	.LBE34:
 520              	.LBE33:
 102:usart/usart.c **** 				sTmp[pos++] = 'x';
 521              		.loc 1 102 0
 522 0126 03F10108 		add	r8, r3, #1
 523              	.LVL51:
 524 012a E146     		mov	r9, ip
 103:usart/usart.c **** 				vNum2String(sTmp, &pos, va_arg(ap, uint32_t), 16);
 525              		.loc 1 103 0
 526 012c 5CFA88F8 		uxtab	r8, ip, r8
 527              	.LVL52:
 102:usart/usart.c **** 				sTmp[pos++] = 'x';
 528              		.loc 1 102 0
 529 0130 9944     		add	r9, r9, r3
 104:usart/usart.c **** 				break;
 530              		.loc 1 104 0
 531 0132 02F1040C 		add	ip, r2, #4
 103:usart/usart.c **** 				vNum2String(sTmp, &pos, va_arg(ap, uint32_t), 16);
 532              		.loc 1 103 0
 533 0136 0233     		adds	r3, r3, #2
 534              	.LVL53:
 102:usart/usart.c **** 				sTmp[pos++] = 'x';
 535              		.loc 1 102 0
 536 0138 09F8506C 		strb	r6, [r9, #-80]
 104:usart/usart.c **** 				break;
 537              		.loc 1 104 0
 538 013c CDF804C0 		str	ip, [sp, #4]
 539 0140 1268     		ldr	r2, [r2]
 103:usart/usart.c **** 				vNum2String(sTmp, &pos, va_arg(ap, uint32_t), 16);
 540              		.loc 1 103 0
 541 0142 08F8501C 		strb	r1, [r8, #-80]
 542 0146 DBB2     		uxtb	r3, r3
 543              	.LVL54:
 544 0148 0DF1270C 		add	ip, sp, #39
 545 014c 00E0     		b	.L37
 546              	.LVL55:
 547              	.L95:
 548              	.LBB36:
 549              	.LBB35:
 183:usart/usart.c ****     } while (u32Number != 0);
 550              		.loc 1 183 0
 551 014e 0A46     		mov	r2, r1
 552              	.LVL56:
 553              	.L37:
 176:usart/usart.c ****         c = u32Number - (n * u8Base);
 554              		.loc 1 176 0
 555 0150 1109     		lsrs	r1, r2, #4
 177:usart/usart.c ****         if (c < 10) {
 556              		.loc 1 177 0
 557 0152 A2EB0112 		sub	r2, r2, r1, lsl #4
 179:usart/usart.c ****         } else {
 558              		.loc 1 179 0
 559 0156 5FFA82F8 		uxtb	r8, r2
 560 015a 08F13009 		add	r9, r8, #48
 181:usart/usart.c ****         }
 561              		.loc 1 181 0
 562 015e 08F15708 		add	r8, r8, #87
 563 0162 092A     		cmp	r2, #9
 564 0164 94BF     		ite	ls
 565 0166 4A46     		movls	r2, r9
 566 0168 4246     		movhi	r2, r8
 567 016a D2B2     		uxtb	r2, r2
 568 016c E046     		mov	r8, ip
 569 016e 0CF80129 		strb	r2, [ip], #-1
 570              	.LVL57:
 184:usart/usart.c **** 
 571              		.loc 1 184 0
 572 0172 0029     		cmp	r1, #0
 573 0174 EBD1     		bne	.L95
 186:usart/usart.c ****     	s[ *pPos ] = *p;
 574              		.loc 1 186 0
 575 0176 002A     		cmp	r2, #0
 576 0178 3FF456AF 		beq	.L20
 577 017c 4146     		mov	r1, r8
 578              	.LVL58:
 579              	.L39:
 187:usart/usart.c ****     	*pPos += 1;
 580              		.loc 1 187 0
 581 017e 0DF1800C 		add	ip, sp, #128
 582 0182 9C44     		add	ip, ip, r3
 583              		.loc 1 188 0
 584 0184 0133     		adds	r3, r3, #1
 585              	.LVL59:
 187:usart/usart.c ****     	*pPos += 1;
 586              		.loc 1 187 0
 587 0186 0CF8502C 		strb	r2, [ip, #-80]
 186:usart/usart.c ****     	s[ *pPos ] = *p;
 588              		.loc 1 186 0
 589 018a 11F8012F 		ldrb	r2, [r1, #1]!	@ zero_extendqisi2
 590              	.LVL60:
 591              		.loc 1 188 0
 592 018e DBB2     		uxtb	r3, r3
 593              	.LVL61:
 186:usart/usart.c ****     	s[ *pPos ] = *p;
 594              		.loc 1 186 0
 595 0190 002A     		cmp	r2, #0
 596 0192 F4D1     		bne	.L39
 597 0194 48E7     		b	.L20
 598              	.LVL62:
 599              	.L26:
 600              	.LBE35:
 601              	.LBE36:
 110:usart/usart.c **** 				vNum2String(sTmp, &pos, va_arg(ap, uint32_t), 2);
 602              		.loc 1 110 0
 603 0196 0DF1800C 		add	ip, sp, #128
 111:usart/usart.c **** 				break;
 604              		.loc 1 111 0
 605 019a 019A     		ldr	r2, [sp, #4]
 606              	.LBB37:
 607              	.LBB38:
 174:usart/usart.c ****     do {
 608              		.loc 1 174 0
 609 019c 8DF82850 		strb	r5, [sp, #40]
 610              	.LBE38:
 611              	.LBE37:
 109:usart/usart.c **** 				sTmp[pos++] = 'b';
 612              		.loc 1 109 0
 613 01a0 03F10108 		add	r8, r3, #1
 614              	.LVL63:
 615 01a4 E146     		mov	r9, ip
 110:usart/usart.c **** 				vNum2String(sTmp, &pos, va_arg(ap, uint32_t), 2);
 616              		.loc 1 110 0
 617 01a6 5CFA88F8 		uxtab	r8, ip, r8
 618              	.LVL64:
 109:usart/usart.c **** 				sTmp[pos++] = 'b';
 619              		.loc 1 109 0
 620 01aa 9944     		add	r9, r9, r3
 111:usart/usart.c **** 				break;
 621              		.loc 1 111 0
 622 01ac 02F1040C 		add	ip, r2, #4
 110:usart/usart.c **** 				vNum2String(sTmp, &pos, va_arg(ap, uint32_t), 2);
 623              		.loc 1 110 0
 624 01b0 0233     		adds	r3, r3, #2
 625              	.LVL65:
 109:usart/usart.c **** 				sTmp[pos++] = 'b';
 626              		.loc 1 109 0
 627 01b2 09F8506C 		strb	r6, [r9, #-80]
 111:usart/usart.c **** 				break;
 628              		.loc 1 111 0
 629 01b6 CDF804C0 		str	ip, [sp, #4]
 630 01ba 1268     		ldr	r2, [r2]
 110:usart/usart.c **** 				vNum2String(sTmp, &pos, va_arg(ap, uint32_t), 2);
 631              		.loc 1 110 0
 632 01bc 08F8501C 		strb	r1, [r8, #-80]
 633 01c0 DBB2     		uxtb	r3, r3
 634              	.LVL66:
 635 01c2 0DF1270C 		add	ip, sp, #39
 636 01c6 00E0     		b	.L41
 637              	.LVL67:
 638              	.L96:
 639              	.LBB40:
 640              	.LBB39:
 183:usart/usart.c ****     } while (u32Number != 0);
 641              		.loc 1 183 0
 642 01c8 0A46     		mov	r2, r1
 643              	.LVL68:
 644              	.L41:
 176:usart/usart.c ****         c = u32Number - (n * u8Base);
 645              		.loc 1 176 0
 646 01ca 5108     		lsrs	r1, r2, #1
 177:usart/usart.c ****         if (c < 10) {
 647              		.loc 1 177 0
 648 01cc A2EB4102 		sub	r2, r2, r1, lsl #1
 179:usart/usart.c ****         } else {
 649              		.loc 1 179 0
 650 01d0 5FFA82F8 		uxtb	r8, r2
 651 01d4 08F13009 		add	r9, r8, #48
 181:usart/usart.c ****         }
 652              		.loc 1 181 0
 653 01d8 08F15708 		add	r8, r8, #87
 654 01dc 092A     		cmp	r2, #9
 655 01de 94BF     		ite	ls
 656 01e0 4A46     		movls	r2, r9
 657 01e2 4246     		movhi	r2, r8
 658 01e4 D2B2     		uxtb	r2, r2
 659 01e6 E046     		mov	r8, ip
 660 01e8 0CF80129 		strb	r2, [ip], #-1
 661              	.LVL69:
 184:usart/usart.c **** 
 662              		.loc 1 184 0
 663 01ec 0029     		cmp	r1, #0
 664 01ee EBD1     		bne	.L96
 186:usart/usart.c ****     	s[ *pPos ] = *p;
 665              		.loc 1 186 0
 666 01f0 002A     		cmp	r2, #0
 667 01f2 3FF419AF 		beq	.L20
 668 01f6 4146     		mov	r1, r8
 669              	.LVL70:
 670              	.L43:
 187:usart/usart.c ****     	*pPos += 1;
 671              		.loc 1 187 0
 672 01f8 0DF1800C 		add	ip, sp, #128
 673 01fc 9C44     		add	ip, ip, r3
 674              		.loc 1 188 0
 675 01fe 0133     		adds	r3, r3, #1
 676              	.LVL71:
 187:usart/usart.c ****     	*pPos += 1;
 677              		.loc 1 187 0
 678 0200 0CF8502C 		strb	r2, [ip, #-80]
 186:usart/usart.c ****     	s[ *pPos ] = *p;
 679              		.loc 1 186 0
 680 0204 11F8012F 		ldrb	r2, [r1, #1]!	@ zero_extendqisi2
 681              	.LVL72:
 682              		.loc 1 188 0
 683 0208 DBB2     		uxtb	r3, r3
 684              	.LVL73:
 186:usart/usart.c ****     	s[ *pPos ] = *p;
 685              		.loc 1 186 0
 686 020a 002A     		cmp	r2, #0
 687 020c F4D1     		bne	.L43
 688 020e 0BE7     		b	.L20
 689              	.LVL74:
 690              	.L24:
 691              	.LBE39:
 692              	.LBE40:
  97:usart/usart.c **** 				break;
 693              		.loc 1 97 0
 694 0210 019A     		ldr	r2, [sp, #4]
 695              	.LBB41:
 696              	.LBB26:
 174:usart/usart.c ****     do {
 697              		.loc 1 174 0
 698 0212 8DF82850 		strb	r5, [sp, #40]
 699              	.LBE26:
 700              	.LBE41:
  97:usart/usart.c **** 				break;
 701              		.loc 1 97 0
 702 0216 02F1040C 		add	ip, r2, #4
 703 021a CDF804C0 		str	ip, [sp, #4]
 704 021e 1168     		ldr	r1, [r2]
 705              	.LVL75:
 706 0220 0DF1270C 		add	ip, sp, #39
 707 0224 00E0     		b	.L33
 708              	.LVL76:
 709              	.L97:
 710              	.LBB42:
 711              	.LBB27:
 183:usart/usart.c ****     } while (u32Number != 0);
 712              		.loc 1 183 0
 713 0226 1146     		mov	r1, r2
 714              	.LVL77:
 715              	.L33:
 176:usart/usart.c ****         c = u32Number - (n * u8Base);
 716              		.loc 1 176 0
 717 0228 A0FB0182 		umull	r8, r2, r0, r1
 718 022c D208     		lsrs	r2, r2, #3
 177:usart/usart.c ****         if (c < 10) {
 719              		.loc 1 177 0
 720 022e 02EB8208 		add	r8, r2, r2, lsl #2
 721 0232 A1EB4801 		sub	r1, r1, r8, lsl #1
 179:usart/usart.c ****         } else {
 722              		.loc 1 179 0
 723 0236 5FFA81F8 		uxtb	r8, r1
 724 023a 08F13009 		add	r9, r8, #48
 181:usart/usart.c ****         }
 725              		.loc 1 181 0
 726 023e 08F15708 		add	r8, r8, #87
 727 0242 0929     		cmp	r1, #9
 728 0244 94BF     		ite	ls
 729 0246 4946     		movls	r1, r9
 730 0248 4146     		movhi	r1, r8
 731 024a C9B2     		uxtb	r1, r1
 732 024c E046     		mov	r8, ip
 733 024e 0CF80119 		strb	r1, [ip], #-1
 734              	.LVL78:
 184:usart/usart.c **** 
 735              		.loc 1 184 0
 736 0252 002A     		cmp	r2, #0
 737 0254 E7D1     		bne	.L97
 738              	.LVL79:
 186:usart/usart.c ****     	s[ *pPos ] = *p;
 739              		.loc 1 186 0
 740 0256 0029     		cmp	r1, #0
 741 0258 3FF4E6AE 		beq	.L20
 742 025c 4246     		mov	r2, r8
 743              	.LVL80:
 744              	.L35:
 187:usart/usart.c ****     	*pPos += 1;
 745              		.loc 1 187 0
 746 025e 0DF1800C 		add	ip, sp, #128
 747 0262 9C44     		add	ip, ip, r3
 748              		.loc 1 188 0
 749 0264 0133     		adds	r3, r3, #1
 750              	.LVL81:
 187:usart/usart.c ****     	*pPos += 1;
 751              		.loc 1 187 0
 752 0266 0CF8501C 		strb	r1, [ip, #-80]
 186:usart/usart.c ****     	s[ *pPos ] = *p;
 753              		.loc 1 186 0
 754 026a 12F8011F 		ldrb	r1, [r2, #1]!	@ zero_extendqisi2
 755              	.LVL82:
 756              		.loc 1 188 0
 757 026e DBB2     		uxtb	r3, r3
 758              	.LVL83:
 186:usart/usart.c ****     	s[ *pPos ] = *p;
 759              		.loc 1 186 0
 760 0270 0029     		cmp	r1, #0
 761 0272 F4D1     		bne	.L35
 762 0274 D8E6     		b	.L20
 763              	.LVL84:
 764              	.L27:
 765              	.LBE27:
 766              	.LBE42:
 116:usart/usart.c **** 				break;
 767              		.loc 1 116 0
 768 0276 019A     		ldr	r2, [sp, #4]
 769 0278 20A9     		add	r1, sp, #128
 770 027a D2F800C0 		ldr	ip, [r2]
 771 027e 1944     		add	r1, r1, r3
 772 0280 0432     		adds	r2, r2, #4
 773 0282 0133     		adds	r3, r3, #1
 774              	.LVL85:
 775 0284 0192     		str	r2, [sp, #4]
 776 0286 01F850CC 		strb	ip, [r1, #-80]
 777 028a DBB2     		uxtb	r3, r3
 778              	.LVL86:
 117:usart/usart.c **** 
 779              		.loc 1 117 0
 780 028c CCE6     		b	.L20
 781              	.L29:
 132:usart/usart.c **** 				do {
 782              		.loc 1 132 0
 783 028e 019A     		ldr	r2, [sp, #4]
 784 0290 1168     		ldr	r1, [r2]
 785              	.LVL87:
 786 0292 0432     		adds	r2, r2, #4
 787 0294 0192     		str	r2, [sp, #4]
 788 0296 91F800C0 		ldrb	ip, [r1]	@ zero_extendqisi2
 789 029a 1A46     		mov	r2, r3
 790 029c 01E0     		b	.L53
 791              	.LVL88:
 792              	.L98:
 793 029e 9446     		mov	ip, r2
 134:usart/usart.c **** 				} while (*p);
 794              		.loc 1 134 0
 795 02a0 1A46     		mov	r2, r3
 796              	.LVL89:
 797              	.L53:
 134:usart/usart.c **** 				} while (*p);
 798              		.loc 1 134 0 is_stmt 0 discriminator 1
 799 02a2 0DF18008 		add	r8, sp, #128
 800 02a6 9044     		add	r8, r8, r2
 135:usart/usart.c **** 				break;
 801              		.loc 1 135 0 is_stmt 1 discriminator 1
 802 02a8 11F8012F 		ldrb	r2, [r1, #1]!	@ zero_extendqisi2
 803              	.LVL90:
 134:usart/usart.c **** 				} while (*p);
 804              		.loc 1 134 0 discriminator 1
 805 02ac 08F850CC 		strb	ip, [r8, #-80]
 806 02b0 0133     		adds	r3, r3, #1
 807              	.LVL91:
 808 02b2 DBB2     		uxtb	r3, r3
 809              	.LVL92:
 135:usart/usart.c **** 				break;
 810              		.loc 1 135 0 discriminator 1
 811 02b4 002A     		cmp	r2, #0
 812 02b6 F2D1     		bne	.L98
 813 02b8 B6E6     		b	.L20
 814              	.LVL93:
 815              	.L100:
 123:usart/usart.c **** 					vNum2String(sTmp, &pos, (~i)+1, 10);
 816              		.loc 1 123 0
 817 02ba 20AA     		add	r2, sp, #128
 818              	.LVL94:
 819 02bc 1A44     		add	r2, r2, r3
 820 02be 0133     		adds	r3, r3, #1
 124:usart/usart.c **** 				} else {
 821              		.loc 1 124 0
 822 02c0 4942     		negs	r1, r1
 823              	.LBB43:
 824              	.LBB44:
 174:usart/usart.c ****     do {
 825              		.loc 1 174 0
 826 02c2 8DF82850 		strb	r5, [sp, #40]
 827              	.LBE44:
 828              	.LBE43:
 123:usart/usart.c **** 					vNum2String(sTmp, &pos, (~i)+1, 10);
 829              		.loc 1 123 0
 830 02c6 02F850EC 		strb	lr, [r2, #-80]
 831 02ca DBB2     		uxtb	r3, r3
 832              	.LVL95:
 833 02cc 0DF1270C 		add	ip, sp, #39
 834 02d0 00E0     		b	.L46
 835              	.LVL96:
 836              	.L99:
 837              	.LBB46:
 838              	.LBB45:
 183:usart/usart.c ****     } while (u32Number != 0);
 839              		.loc 1 183 0
 840 02d2 1146     		mov	r1, r2
 841              	.LVL97:
 842              	.L46:
 176:usart/usart.c ****         c = u32Number - (n * u8Base);
 843              		.loc 1 176 0
 844 02d4 A0FB0182 		umull	r8, r2, r0, r1
 845 02d8 D208     		lsrs	r2, r2, #3
 177:usart/usart.c ****         if (c < 10) {
 846              		.loc 1 177 0
 847 02da 02EB8208 		add	r8, r2, r2, lsl #2
 848 02de A1EB4808 		sub	r8, r1, r8, lsl #1
 179:usart/usart.c ****         } else {
 849              		.loc 1 179 0
 850 02e2 5FFA88F9 		uxtb	r9, r8
 851 02e6 09F13001 		add	r1, r9, #48
 181:usart/usart.c ****         }
 852              		.loc 1 181 0
 853 02ea 09F15709 		add	r9, r9, #87
 854 02ee B8F1090F 		cmp	r8, #9
 855 02f2 88BF     		it	hi
 856 02f4 4946     		movhi	r1, r9
 857 02f6 C9B2     		uxtb	r1, r1
 858 02f8 E046     		mov	r8, ip
 859 02fa 0CF80119 		strb	r1, [ip], #-1
 860              	.LVL98:
 184:usart/usart.c **** 
 861              		.loc 1 184 0
 862 02fe 002A     		cmp	r2, #0
 863 0300 E7D1     		bne	.L99
 186:usart/usart.c ****     	s[ *pPos ] = *p;
 864              		.loc 1 186 0
 865 0302 0029     		cmp	r1, #0
 866 0304 3FF490AE 		beq	.L20
 867 0308 4246     		mov	r2, r8
 868              	.LVL99:
 869              	.L48:
 187:usart/usart.c ****     	*pPos += 1;
 870              		.loc 1 187 0
 871 030a 0DF1800C 		add	ip, sp, #128
 872 030e 9C44     		add	ip, ip, r3
 873              		.loc 1 188 0
 874 0310 0133     		adds	r3, r3, #1
 875              	.LVL100:
 187:usart/usart.c ****     	*pPos += 1;
 876              		.loc 1 187 0
 877 0312 0CF8501C 		strb	r1, [ip, #-80]
 186:usart/usart.c ****     	s[ *pPos ] = *p;
 878              		.loc 1 186 0
 879 0316 12F8011F 		ldrb	r1, [r2, #1]!	@ zero_extendqisi2
 880              	.LVL101:
 881              		.loc 1 188 0
 882 031a DBB2     		uxtb	r3, r3
 883              	.LVL102:
 186:usart/usart.c ****     	s[ *pPos ] = *p;
 884              		.loc 1 186 0
 885 031c 0029     		cmp	r1, #0
 886 031e F4D1     		bne	.L48
 887 0320 82E6     		b	.L20
 888              	.LBE45:
 889              	.LBE46:
 890              	.LBE52:
 891              		.cfi_endproc
 892              	.LFE126:
 894 0322 00BF     		.section	.text.USARTPritnf,"ax",%progbits
 895              		.align	2
 896              		.global	USARTPritnf
 897              		.thumb
 898              		.thumb_func
 900              	USARTPritnf:
 901              	.LFB127:
 158:usart/usart.c **** 	char stmp[100];
 902              		.loc 1 158 0
 903              		.cfi_startproc
 904              		@ args = 4, pretend = 16, frame = 104
 905              		@ frame_needed = 0, uses_anonymous_args = 1
 906              	.LVL103:
 907 0000 0FB4     		push	{r0, r1, r2, r3}
 908              	.LCFI8:
 909              		.cfi_def_cfa_offset 16
 910              		.cfi_offset 0, -16
 911              		.cfi_offset 1, -12
 912              		.cfi_offset 2, -8
 913              		.cfi_offset 3, -4
 914 0002 10B5     		push	{r4, lr}
 915              	.LCFI9:
 916              		.cfi_def_cfa_offset 24
 917              		.cfi_offset 4, -24
 918              		.cfi_offset 14, -20
 919 0004 9AB0     		sub	sp, sp, #104
 920              	.LCFI10:
 921              		.cfi_def_cfa_offset 128
 922              	.LVL104:
 923              	.LBB53:
 924              	.LBB54:
  67:usart/usart.c ****     {
 925              		.loc 1 67 0
 926 0006 9DF80000 		ldrb	r0, [sp]	@ zero_extendqisi2
 927 000a 30B1     		cbz	r0, .L101
 928 000c 6C46     		mov	r4, sp
 929              	.LVL105:
 930              	.L104:
  69:usart/usart.c ****     }
 931              		.loc 1 69 0
 932 000e FFF7FEFF 		bl	PutFifo
 933              	.LVL106:
  67:usart/usart.c ****     {
 934              		.loc 1 67 0
 935 0012 14F8010F 		ldrb	r0, [r4, #1]!	@ zero_extendqisi2
 936              	.LVL107:
 937 0016 0028     		cmp	r0, #0
 938 0018 F9D1     		bne	.L104
 939              	.LVL108:
 940              	.L101:
 941              	.LBE54:
 942              	.LBE53:
 166:usart/usart.c **** 
 943              		.loc 1 166 0
 944 001a 1AB0     		add	sp, sp, #104
 945              		@ sp needed
 946 001c BDE81040 		pop	{r4, lr}
 947 0020 04B0     		add	sp, sp, #16
 948 0022 7047     		bx	lr
 949              		.cfi_endproc
 950              	.LFE127:
 952              		.section	.text.vNum2String,"ax",%progbits
 953              		.align	2
 954              		.global	vNum2String
 955              		.thumb
 956              		.thumb_func
 958              	vNum2String:
 959              	.LFB128:
 168:usart/usart.c **** 
 960              		.loc 1 168 0
 961              		.cfi_startproc
 962              		@ args = 0, pretend = 0, frame = 40
 963              		@ frame_needed = 0, uses_anonymous_args = 0
 964              		@ link register save eliminated.
 965              	.LVL109:
 966 0000 F0B4     		push	{r4, r5, r6, r7}
 967              	.LCFI11:
 968              		.cfi_def_cfa_offset 16
 969              		.cfi_offset 4, -16
 970              		.cfi_offset 5, -12
 971              		.cfi_offset 6, -8
 972              		.cfi_offset 7, -4
 973 0002 8AB0     		sub	sp, sp, #40
 974              	.LCFI12:
 975              		.cfi_def_cfa_offset 56
 976              	.LVL110:
 174:usart/usart.c ****     do {
 977              		.loc 1 174 0
 978 0004 0024     		movs	r4, #0
 979 0006 8DF82040 		strb	r4, [sp, #32]
 980 000a 0DF11F05 		add	r5, sp, #31
 981 000e 00E0     		b	.L110
 982              	.LVL111:
 983              	.L117:
 183:usart/usart.c ****     } while (u32Number != 0);
 984              		.loc 1 183 0
 985 0010 2246     		mov	r2, r4
 986              	.LVL112:
 987              	.L110:
 176:usart/usart.c ****         c = u32Number - (n * u8Base);
 988              		.loc 1 176 0
 989 0012 B2FBF3F4 		udiv	r4, r2, r3
 177:usart/usart.c ****         if (c < 10) {
 990              		.loc 1 177 0
 991 0016 03FB1422 		mls	r2, r3, r4, r2
 179:usart/usart.c ****         } else {
 992              		.loc 1 179 0
 993 001a D6B2     		uxtb	r6, r2
 994 001c 06F13007 		add	r7, r6, #48
 181:usart/usart.c ****         }
 995              		.loc 1 181 0
 996 0020 5736     		adds	r6, r6, #87
 997 0022 092A     		cmp	r2, #9
 998 0024 94BF     		ite	ls
 999 0026 3A46     		movls	r2, r7
 1000 0028 3246     		movhi	r2, r6
 1001 002a D2B2     		uxtb	r2, r2
 1002 002c 2E46     		mov	r6, r5
 1003 002e 05F80129 		strb	r2, [r5], #-1
 1004              	.LVL113:
 184:usart/usart.c **** 
 1005              		.loc 1 184 0
 1006 0032 002C     		cmp	r4, #0
 1007 0034 ECD1     		bne	.L117
 186:usart/usart.c ****     	s[ *pPos ] = *p;
 1008              		.loc 1 186 0 discriminator 1
 1009 0036 52B1     		cbz	r2, .L108
 1010 0038 0B78     		ldrb	r3, [r1]	@ zero_extendqisi2
 1011              	.LVL114:
 1012 003a 3446     		mov	r4, r6
 1013              	.LVL115:
 1014              	.L113:
 187:usart/usart.c ****     	*pPos += 1;
 1015              		.loc 1 187 0
 1016 003c C254     		strb	r2, [r0, r3]
 1017              		.loc 1 188 0
 1018 003e 0B78     		ldrb	r3, [r1]	@ zero_extendqisi2
 186:usart/usart.c ****     	s[ *pPos ] = *p;
 1019              		.loc 1 186 0
 1020 0040 14F8012F 		ldrb	r2, [r4, #1]!	@ zero_extendqisi2
 1021              	.LVL116:
 1022              		.loc 1 188 0
 1023 0044 0133     		adds	r3, r3, #1
 1024 0046 DBB2     		uxtb	r3, r3
 1025 0048 0B70     		strb	r3, [r1]
 1026              	.LVL117:
 186:usart/usart.c ****     	s[ *pPos ] = *p;
 1027              		.loc 1 186 0
 1028 004a 002A     		cmp	r2, #0
 1029 004c F6D1     		bne	.L113
 1030              	.L108:
 189:usart/usart.c ****         p++;
 190:usart/usart.c ****     }
 191:usart/usart.c ****     return;
 192:usart/usart.c **** }
 1031              		.loc 1 192 0
 1032 004e 0AB0     		add	sp, sp, #40
 1033              		@ sp needed
 1034 0050 F0BC     		pop	{r4, r5, r6, r7}
 1035 0052 7047     		bx	lr
 1036              		.cfi_endproc
 1037              	.LFE128:
 1039              		.comm	Fifo,100,4
 1040              		.comm	GETPT,4,4
 1041              		.comm	PUTPT,4,4
 1042              		.text
 1043              	.Letext0:
 1044              		.file 2 "/opt/toolchains/eabi/arm-2014.05/arm-none-eabi/include/stdint.h"
 1045              		.file 3 "inc/stm32f4xx.h"
 1046              		.file 4 "Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_gpio.h"
 1047              		.file 5 "Libraries/STM32F4xx_StdPeriph_Driver/inc/misc.h"
 1048              		.file 6 "Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_usart.h"
 1049              		.file 7 "Libraries/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h"
 1050              		.file 8 "/opt/toolchains/eabi/arm-2014.05/lib/gcc/arm-none-eabi/4.8.3/include/stdarg.h"
 1051              		.file 9 "Libraries/CMSIS/Include/core_cm4.h"
 1052              		.file 10 "fifo/fifo.h"
 1053              		.file 11 "Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_rcc.h"
 1054              		.file 12 "<built-in>"
 1055              		.file 13 "Libraries/FreeRTOS/Source/include/task.h"
DEFINED SYMBOLS
                            *ABS*:00000000 usart.c
     /tmp/cckmMOpb.s:21     .text.USART_Config:00000000 $t
     /tmp/cckmMOpb.s:26     .text.USART_Config:00000000 USART_Config
     /tmp/cckmMOpb.s:138    .text.USART2_IRQHandler:00000000 $t
     /tmp/cckmMOpb.s:143    .text.USART2_IRQHandler:00000000 USART2_IRQHandler
     /tmp/cckmMOpb.s:211    .text.USARTPutchar:00000000 $t
     /tmp/cckmMOpb.s:216    .text.USARTPutchar:00000000 USARTPutchar
     /tmp/cckmMOpb.s:251    .text.vDebugPrintf:00000000 $t
     /tmp/cckmMOpb.s:256    .text.vDebugPrintf:00000000 vDebugPrintf
     /tmp/cckmMOpb.s:895    .text.USARTPritnf:00000000 $t
     /tmp/cckmMOpb.s:900    .text.USARTPritnf:00000000 USARTPritnf
     /tmp/cckmMOpb.s:953    .text.vNum2String:00000000 $t
     /tmp/cckmMOpb.s:958    .text.vNum2String:00000000 vNum2String
                            *COM*:00000064 Fifo
                            *COM*:00000004 GETPT
                            *COM*:00000004 PUTPT
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
NVIC_Init
RCC_AHB1PeriphClockCmd
RCC_APB1PeriphClockCmd
GPIO_Init
GPIO_PinAFConfig
USART_Init
USART_Cmd
USART_GetITStatus
LED_On
GetFifo
USART_SendData
USART_ITConfig
PutFifo
vTaskSuspendAll
xTaskResumeAll
