   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.eabi_attribute 28, 1
   5              		.fpu fpv4-sp-d16
   6              		.eabi_attribute 20, 1
   7              		.eabi_attribute 21, 1
   8              		.eabi_attribute 23, 3
   9              		.eabi_attribute 24, 1
  10              		.eabi_attribute 25, 1
  11              		.eabi_attribute 26, 1
  12              		.eabi_attribute 30, 2
  13              		.eabi_attribute 34, 1
  14              		.eabi_attribute 18, 4
  15              		.thumb
  16              		.file	"queue.c"
  17              		.text
  18              	.Ltext0:
  19              		.cfi_sections	.debug_frame
  20              		.section	.text.unlikely.prvCopyDataFromQueue,"ax",%progbits
  21              		.align	2
  22              		.thumb
  23              		.thumb_func
  25              	prvCopyDataFromQueue:
  26              	.LFB139:
  27              		.file 1 "Libraries/FreeRTOS/Source/queue.c"
   1:Libraries/FreeRTOS/Source/queue.c **** /*
   2:Libraries/FreeRTOS/Source/queue.c ****     FreeRTOS V8.0.1 - Copyright (C) 2014 Real Time Engineers Ltd.
   3:Libraries/FreeRTOS/Source/queue.c ****     All rights reserved
   4:Libraries/FreeRTOS/Source/queue.c **** 
   5:Libraries/FreeRTOS/Source/queue.c ****     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:Libraries/FreeRTOS/Source/queue.c **** 
   7:Libraries/FreeRTOS/Source/queue.c ****     ***************************************************************************
   8:Libraries/FreeRTOS/Source/queue.c ****      *                                                                       *
   9:Libraries/FreeRTOS/Source/queue.c ****      *    FreeRTOS provides completely free yet professionally developed,    *
  10:Libraries/FreeRTOS/Source/queue.c ****      *    robust, strictly quality controlled, supported, and cross          *
  11:Libraries/FreeRTOS/Source/queue.c ****      *    platform software that has become a de facto standard.             *
  12:Libraries/FreeRTOS/Source/queue.c ****      *                                                                       *
  13:Libraries/FreeRTOS/Source/queue.c ****      *    Help yourself get started quickly and support the FreeRTOS         *
  14:Libraries/FreeRTOS/Source/queue.c ****      *    project by purchasing a FreeRTOS tutorial book, reference          *
  15:Libraries/FreeRTOS/Source/queue.c ****      *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
  16:Libraries/FreeRTOS/Source/queue.c ****      *                                                                       *
  17:Libraries/FreeRTOS/Source/queue.c ****      *    Thank you!                                                         *
  18:Libraries/FreeRTOS/Source/queue.c ****      *                                                                       *
  19:Libraries/FreeRTOS/Source/queue.c ****     ***************************************************************************
  20:Libraries/FreeRTOS/Source/queue.c **** 
  21:Libraries/FreeRTOS/Source/queue.c ****     This file is part of the FreeRTOS distribution.
  22:Libraries/FreeRTOS/Source/queue.c **** 
  23:Libraries/FreeRTOS/Source/queue.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  24:Libraries/FreeRTOS/Source/queue.c ****     the terms of the GNU General Public License (version 2) as published by the
  25:Libraries/FreeRTOS/Source/queue.c ****     Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
  26:Libraries/FreeRTOS/Source/queue.c **** 
  27:Libraries/FreeRTOS/Source/queue.c ****     >>!   NOTE: The modification to the GPL is included to allow you to     !<<
  28:Libraries/FreeRTOS/Source/queue.c ****     >>!   distribute a combined work that includes FreeRTOS without being   !<<
  29:Libraries/FreeRTOS/Source/queue.c ****     >>!   obliged to provide the source code for proprietary components     !<<
  30:Libraries/FreeRTOS/Source/queue.c ****     >>!   outside of the FreeRTOS kernel.                                   !<<
  31:Libraries/FreeRTOS/Source/queue.c **** 
  32:Libraries/FreeRTOS/Source/queue.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  33:Libraries/FreeRTOS/Source/queue.c ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  34:Libraries/FreeRTOS/Source/queue.c ****     FOR A PARTICULAR PURPOSE.  Full license text is available from the following
  35:Libraries/FreeRTOS/Source/queue.c ****     link: http://www.freertos.org/a00114.html
  36:Libraries/FreeRTOS/Source/queue.c **** 
  37:Libraries/FreeRTOS/Source/queue.c ****     1 tab == 4 spaces!
  38:Libraries/FreeRTOS/Source/queue.c **** 
  39:Libraries/FreeRTOS/Source/queue.c ****     ***************************************************************************
  40:Libraries/FreeRTOS/Source/queue.c ****      *                                                                       *
  41:Libraries/FreeRTOS/Source/queue.c ****      *    Having a problem?  Start by reading the FAQ "My application does   *
  42:Libraries/FreeRTOS/Source/queue.c ****      *    not run, what could be wrong?"                                     *
  43:Libraries/FreeRTOS/Source/queue.c ****      *                                                                       *
  44:Libraries/FreeRTOS/Source/queue.c ****      *    http://www.FreeRTOS.org/FAQHelp.html                               *
  45:Libraries/FreeRTOS/Source/queue.c ****      *                                                                       *
  46:Libraries/FreeRTOS/Source/queue.c ****     ***************************************************************************
  47:Libraries/FreeRTOS/Source/queue.c **** 
  48:Libraries/FreeRTOS/Source/queue.c ****     http://www.FreeRTOS.org - Documentation, books, training, latest versions,
  49:Libraries/FreeRTOS/Source/queue.c ****     license and Real Time Engineers Ltd. contact details.
  50:Libraries/FreeRTOS/Source/queue.c **** 
  51:Libraries/FreeRTOS/Source/queue.c ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  52:Libraries/FreeRTOS/Source/queue.c ****     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
  53:Libraries/FreeRTOS/Source/queue.c ****     compatible FAT file system, and our tiny thread aware UDP/IP stack.
  54:Libraries/FreeRTOS/Source/queue.c **** 
  55:Libraries/FreeRTOS/Source/queue.c ****     http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
  56:Libraries/FreeRTOS/Source/queue.c ****     Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
  57:Libraries/FreeRTOS/Source/queue.c ****     licenses offer ticketed support, indemnification and middleware.
  58:Libraries/FreeRTOS/Source/queue.c **** 
  59:Libraries/FreeRTOS/Source/queue.c ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
  60:Libraries/FreeRTOS/Source/queue.c ****     engineered and independently SIL3 certified version for use in safety and
  61:Libraries/FreeRTOS/Source/queue.c ****     mission critical applications that require provable dependability.
  62:Libraries/FreeRTOS/Source/queue.c **** 
  63:Libraries/FreeRTOS/Source/queue.c ****     1 tab == 4 spaces!
  64:Libraries/FreeRTOS/Source/queue.c **** */
  65:Libraries/FreeRTOS/Source/queue.c **** 
  66:Libraries/FreeRTOS/Source/queue.c **** #include <stdlib.h>
  67:Libraries/FreeRTOS/Source/queue.c **** #include <string.h>
  68:Libraries/FreeRTOS/Source/queue.c **** 
  69:Libraries/FreeRTOS/Source/queue.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  70:Libraries/FreeRTOS/Source/queue.c **** all the API functions to use the MPU wrappers.  That should only be done when
  71:Libraries/FreeRTOS/Source/queue.c **** task.h is included from an application file. */
  72:Libraries/FreeRTOS/Source/queue.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  73:Libraries/FreeRTOS/Source/queue.c **** 
  74:Libraries/FreeRTOS/Source/queue.c **** #include "FreeRTOS.h"
  75:Libraries/FreeRTOS/Source/queue.c **** #include "task.h"
  76:Libraries/FreeRTOS/Source/queue.c **** #include "queue.h"
  77:Libraries/FreeRTOS/Source/queue.c **** 
  78:Libraries/FreeRTOS/Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
  79:Libraries/FreeRTOS/Source/queue.c **** 	#include "croutine.h"
  80:Libraries/FreeRTOS/Source/queue.c **** #endif
  81:Libraries/FreeRTOS/Source/queue.c **** 
  82:Libraries/FreeRTOS/Source/queue.c **** /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
  83:Libraries/FreeRTOS/Source/queue.c **** MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
  84:Libraries/FreeRTOS/Source/queue.c **** header files above, but not in this file, in order to generate the correct
  85:Libraries/FreeRTOS/Source/queue.c **** privileged Vs unprivileged linkage and placement. */
  86:Libraries/FreeRTOS/Source/queue.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
  87:Libraries/FreeRTOS/Source/queue.c **** 
  88:Libraries/FreeRTOS/Source/queue.c **** 
  89:Libraries/FreeRTOS/Source/queue.c **** /* Constants used with the xRxLock and xTxLock structure members. */
  90:Libraries/FreeRTOS/Source/queue.c **** #define queueUNLOCKED					( ( BaseType_t ) -1 )
  91:Libraries/FreeRTOS/Source/queue.c **** #define queueLOCKED_UNMODIFIED			( ( BaseType_t ) 0 )
  92:Libraries/FreeRTOS/Source/queue.c **** 
  93:Libraries/FreeRTOS/Source/queue.c **** /* When the Queue_t structure is used to represent a base queue its pcHead and
  94:Libraries/FreeRTOS/Source/queue.c **** pcTail members are used as pointers into the queue storage area.  When the
  95:Libraries/FreeRTOS/Source/queue.c **** Queue_t structure is used to represent a mutex pcHead and pcTail pointers are
  96:Libraries/FreeRTOS/Source/queue.c **** not necessary, and the pcHead pointer is set to NULL to indicate that the
  97:Libraries/FreeRTOS/Source/queue.c **** pcTail pointer actually points to the mutex holder (if any).  Map alternative
  98:Libraries/FreeRTOS/Source/queue.c **** names to the pcHead and pcTail structure members to ensure the readability of
  99:Libraries/FreeRTOS/Source/queue.c **** the code is maintained despite this dual use of two structure members.  An
 100:Libraries/FreeRTOS/Source/queue.c **** alternative implementation would be to use a union, but use of a union is
 101:Libraries/FreeRTOS/Source/queue.c **** against the coding standard (although an exception to the standard has been
 102:Libraries/FreeRTOS/Source/queue.c **** permitted where the dual use also significantly changes the type of the
 103:Libraries/FreeRTOS/Source/queue.c **** structure member). */
 104:Libraries/FreeRTOS/Source/queue.c **** #define pxMutexHolder					pcTail
 105:Libraries/FreeRTOS/Source/queue.c **** #define uxQueueType						pcHead
 106:Libraries/FreeRTOS/Source/queue.c **** #define queueQUEUE_IS_MUTEX				NULL
 107:Libraries/FreeRTOS/Source/queue.c **** 
 108:Libraries/FreeRTOS/Source/queue.c **** /* Semaphores do not actually store or copy data, so have an item size of
 109:Libraries/FreeRTOS/Source/queue.c **** zero. */
 110:Libraries/FreeRTOS/Source/queue.c **** #define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( ( UBaseType_t ) 0 )
 111:Libraries/FreeRTOS/Source/queue.c **** #define queueMUTEX_GIVE_BLOCK_TIME		 ( ( TickType_t ) 0U )
 112:Libraries/FreeRTOS/Source/queue.c **** 
 113:Libraries/FreeRTOS/Source/queue.c **** #if( configUSE_PREEMPTION == 0 )
 114:Libraries/FreeRTOS/Source/queue.c **** 	/* If the cooperative scheduler is being used then a yield should not be
 115:Libraries/FreeRTOS/Source/queue.c **** 	performed just because a higher priority task has been woken. */
 116:Libraries/FreeRTOS/Source/queue.c **** 	#define queueYIELD_IF_USING_PREEMPTION()
 117:Libraries/FreeRTOS/Source/queue.c **** #else
 118:Libraries/FreeRTOS/Source/queue.c **** 	#define queueYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
 119:Libraries/FreeRTOS/Source/queue.c **** #endif
 120:Libraries/FreeRTOS/Source/queue.c **** 
 121:Libraries/FreeRTOS/Source/queue.c **** /*
 122:Libraries/FreeRTOS/Source/queue.c ****  * Definition of the queue used by the scheduler.
 123:Libraries/FreeRTOS/Source/queue.c ****  * Items are queued by copy, not reference.
 124:Libraries/FreeRTOS/Source/queue.c ****  */
 125:Libraries/FreeRTOS/Source/queue.c **** typedef struct QueueDefinition
 126:Libraries/FreeRTOS/Source/queue.c **** {
 127:Libraries/FreeRTOS/Source/queue.c **** 	int8_t *pcHead;					/*< Points to the beginning of the queue storage area. */
 128:Libraries/FreeRTOS/Source/queue.c **** 	int8_t *pcTail;					/*< Points to the byte at the end of the queue storage area.  Once more byte i
 129:Libraries/FreeRTOS/Source/queue.c **** 	int8_t *pcWriteTo;				/*< Points to the free next place in the storage area. */
 130:Libraries/FreeRTOS/Source/queue.c **** 
 131:Libraries/FreeRTOS/Source/queue.c **** 	union							/* Use of a union is an exception to the coding standard to ensure two mutually exclus
 132:Libraries/FreeRTOS/Source/queue.c **** 	{
 133:Libraries/FreeRTOS/Source/queue.c **** 		int8_t *pcReadFrom;			/*< Points to the last place that a queued item was read from when the stru
 134:Libraries/FreeRTOS/Source/queue.c **** 		UBaseType_t uxRecursiveCallCount;/*< Maintains a count of the number of times a recursive mutex h
 135:Libraries/FreeRTOS/Source/queue.c **** 	} u;
 136:Libraries/FreeRTOS/Source/queue.c **** 
 137:Libraries/FreeRTOS/Source/queue.c **** 	List_t xTasksWaitingToSend;		/*< List of tasks that are blocked waiting to post onto this queue.  
 138:Libraries/FreeRTOS/Source/queue.c **** 	List_t xTasksWaitingToReceive;	/*< List of tasks that are blocked waiting to read from this queue.
 139:Libraries/FreeRTOS/Source/queue.c **** 
 140:Libraries/FreeRTOS/Source/queue.c **** 	volatile UBaseType_t uxMessagesWaiting;/*< The number of items currently in the queue. */
 141:Libraries/FreeRTOS/Source/queue.c **** 	UBaseType_t uxLength;			/*< The length of the queue defined as the number of items it will hold, n
 142:Libraries/FreeRTOS/Source/queue.c **** 	UBaseType_t uxItemSize;			/*< The size of each items that the queue will hold. */
 143:Libraries/FreeRTOS/Source/queue.c **** 
 144:Libraries/FreeRTOS/Source/queue.c **** 	volatile BaseType_t xRxLock;	/*< Stores the number of items received from the queue (removed from 
 145:Libraries/FreeRTOS/Source/queue.c **** 	volatile BaseType_t xTxLock;	/*< Stores the number of items transmitted to the queue (added to the
 146:Libraries/FreeRTOS/Source/queue.c **** 
 147:Libraries/FreeRTOS/Source/queue.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 148:Libraries/FreeRTOS/Source/queue.c **** 		UBaseType_t uxQueueNumber;
 149:Libraries/FreeRTOS/Source/queue.c **** 		uint8_t ucQueueType;
 150:Libraries/FreeRTOS/Source/queue.c **** 	#endif
 151:Libraries/FreeRTOS/Source/queue.c **** 
 152:Libraries/FreeRTOS/Source/queue.c **** 	#if ( configUSE_QUEUE_SETS == 1 )
 153:Libraries/FreeRTOS/Source/queue.c **** 		struct QueueDefinition *pxQueueSetContainer;
 154:Libraries/FreeRTOS/Source/queue.c **** 	#endif
 155:Libraries/FreeRTOS/Source/queue.c **** 
 156:Libraries/FreeRTOS/Source/queue.c **** } xQUEUE;
 157:Libraries/FreeRTOS/Source/queue.c **** 
 158:Libraries/FreeRTOS/Source/queue.c **** /* The old xQUEUE name is maintained above then typedefed to the new Queue_t
 159:Libraries/FreeRTOS/Source/queue.c **** name below to enable the use of older kernel aware debuggers. */
 160:Libraries/FreeRTOS/Source/queue.c **** typedef xQUEUE Queue_t;
 161:Libraries/FreeRTOS/Source/queue.c **** 
 162:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 163:Libraries/FreeRTOS/Source/queue.c **** 
 164:Libraries/FreeRTOS/Source/queue.c **** /*
 165:Libraries/FreeRTOS/Source/queue.c ****  * The queue registry is just a means for kernel aware debuggers to locate
 166:Libraries/FreeRTOS/Source/queue.c ****  * queue structures.  It has no other purpose so is an optional component.
 167:Libraries/FreeRTOS/Source/queue.c ****  */
 168:Libraries/FreeRTOS/Source/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
 169:Libraries/FreeRTOS/Source/queue.c **** 
 170:Libraries/FreeRTOS/Source/queue.c **** 	/* The type stored within the queue registry array.  This allows a name
 171:Libraries/FreeRTOS/Source/queue.c **** 	to be assigned to each queue making kernel aware debugging a little
 172:Libraries/FreeRTOS/Source/queue.c **** 	more user friendly. */
 173:Libraries/FreeRTOS/Source/queue.c **** 	typedef struct QUEUE_REGISTRY_ITEM
 174:Libraries/FreeRTOS/Source/queue.c **** 	{
 175:Libraries/FreeRTOS/Source/queue.c **** 		const char *pcQueueName; /*lint !e971 Unqualified char types are allowed for strings and single c
 176:Libraries/FreeRTOS/Source/queue.c **** 		QueueHandle_t xHandle;
 177:Libraries/FreeRTOS/Source/queue.c **** 	} xQueueRegistryItem;
 178:Libraries/FreeRTOS/Source/queue.c **** 
 179:Libraries/FreeRTOS/Source/queue.c **** 	/* The old xQueueRegistryItem name is maintained above then typedefed to the
 180:Libraries/FreeRTOS/Source/queue.c **** 	new xQueueRegistryItem name below to enable the use of older kernel aware
 181:Libraries/FreeRTOS/Source/queue.c **** 	debuggers. */
 182:Libraries/FreeRTOS/Source/queue.c **** 	typedef xQueueRegistryItem QueueRegistryItem_t;
 183:Libraries/FreeRTOS/Source/queue.c **** 
 184:Libraries/FreeRTOS/Source/queue.c **** 	/* The queue registry is simply an array of QueueRegistryItem_t structures.
 185:Libraries/FreeRTOS/Source/queue.c **** 	The pcQueueName member of a structure being NULL is indicative of the
 186:Libraries/FreeRTOS/Source/queue.c **** 	array position being vacant. */
 187:Libraries/FreeRTOS/Source/queue.c **** 	QueueRegistryItem_t xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
 188:Libraries/FreeRTOS/Source/queue.c **** 
 189:Libraries/FreeRTOS/Source/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
 190:Libraries/FreeRTOS/Source/queue.c **** 
 191:Libraries/FreeRTOS/Source/queue.c **** /*
 192:Libraries/FreeRTOS/Source/queue.c ****  * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
 193:Libraries/FreeRTOS/Source/queue.c ****  * prevent an ISR from adding or removing items to the queue, but does prevent
 194:Libraries/FreeRTOS/Source/queue.c ****  * an ISR from removing tasks from the queue event lists.  If an ISR finds a
 195:Libraries/FreeRTOS/Source/queue.c ****  * queue is locked it will instead increment the appropriate queue lock count
 196:Libraries/FreeRTOS/Source/queue.c ****  * to indicate that a task may require unblocking.  When the queue in unlocked
 197:Libraries/FreeRTOS/Source/queue.c ****  * these lock counts are inspected, and the appropriate action taken.
 198:Libraries/FreeRTOS/Source/queue.c ****  */
 199:Libraries/FreeRTOS/Source/queue.c **** static void prvUnlockQueue( Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
 200:Libraries/FreeRTOS/Source/queue.c **** 
 201:Libraries/FreeRTOS/Source/queue.c **** /*
 202:Libraries/FreeRTOS/Source/queue.c ****  * Uses a critical section to determine if there is any data in a queue.
 203:Libraries/FreeRTOS/Source/queue.c ****  *
 204:Libraries/FreeRTOS/Source/queue.c ****  * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
 205:Libraries/FreeRTOS/Source/queue.c ****  */
 206:Libraries/FreeRTOS/Source/queue.c **** static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
 207:Libraries/FreeRTOS/Source/queue.c **** 
 208:Libraries/FreeRTOS/Source/queue.c **** /*
 209:Libraries/FreeRTOS/Source/queue.c ****  * Uses a critical section to determine if there is any space in a queue.
 210:Libraries/FreeRTOS/Source/queue.c ****  *
 211:Libraries/FreeRTOS/Source/queue.c ****  * @return pdTRUE if there is no space, otherwise pdFALSE;
 212:Libraries/FreeRTOS/Source/queue.c ****  */
 213:Libraries/FreeRTOS/Source/queue.c **** static BaseType_t prvIsQueueFull( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
 214:Libraries/FreeRTOS/Source/queue.c **** 
 215:Libraries/FreeRTOS/Source/queue.c **** /*
 216:Libraries/FreeRTOS/Source/queue.c ****  * Copies an item into the queue, either at the front of the queue or the
 217:Libraries/FreeRTOS/Source/queue.c ****  * back of the queue.
 218:Libraries/FreeRTOS/Source/queue.c ****  */
 219:Libraries/FreeRTOS/Source/queue.c **** static void prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_
 220:Libraries/FreeRTOS/Source/queue.c **** 
 221:Libraries/FreeRTOS/Source/queue.c **** /*
 222:Libraries/FreeRTOS/Source/queue.c ****  * Copies an item out of a queue.
 223:Libraries/FreeRTOS/Source/queue.c ****  */
 224:Libraries/FreeRTOS/Source/queue.c **** static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer ) PRIVILEGED_FUNCT
 225:Libraries/FreeRTOS/Source/queue.c **** 
 226:Libraries/FreeRTOS/Source/queue.c **** #if ( configUSE_QUEUE_SETS == 1 )
 227:Libraries/FreeRTOS/Source/queue.c **** 	/*
 228:Libraries/FreeRTOS/Source/queue.c **** 	 * Checks to see if a queue is a member of a queue set, and if so, notifies
 229:Libraries/FreeRTOS/Source/queue.c **** 	 * the queue set that the queue contains data.
 230:Libraries/FreeRTOS/Source/queue.c **** 	 */
 231:Libraries/FreeRTOS/Source/queue.c **** 	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCop
 232:Libraries/FreeRTOS/Source/queue.c **** #endif
 233:Libraries/FreeRTOS/Source/queue.c **** 
 234:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 235:Libraries/FreeRTOS/Source/queue.c **** 
 236:Libraries/FreeRTOS/Source/queue.c **** /*
 237:Libraries/FreeRTOS/Source/queue.c ****  * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
 238:Libraries/FreeRTOS/Source/queue.c ****  * accessing the queue event lists.
 239:Libraries/FreeRTOS/Source/queue.c ****  */
 240:Libraries/FreeRTOS/Source/queue.c **** #define prvLockQueue( pxQueue )								\
 241:Libraries/FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();									\
 242:Libraries/FreeRTOS/Source/queue.c **** 	{														\
 243:Libraries/FreeRTOS/Source/queue.c **** 		if( ( pxQueue )->xRxLock == queueUNLOCKED )			\
 244:Libraries/FreeRTOS/Source/queue.c **** 		{													\
 245:Libraries/FreeRTOS/Source/queue.c **** 			( pxQueue )->xRxLock = queueLOCKED_UNMODIFIED;	\
 246:Libraries/FreeRTOS/Source/queue.c **** 		}													\
 247:Libraries/FreeRTOS/Source/queue.c **** 		if( ( pxQueue )->xTxLock == queueUNLOCKED )			\
 248:Libraries/FreeRTOS/Source/queue.c **** 		{													\
 249:Libraries/FreeRTOS/Source/queue.c **** 			( pxQueue )->xTxLock = queueLOCKED_UNMODIFIED;	\
 250:Libraries/FreeRTOS/Source/queue.c **** 		}													\
 251:Libraries/FreeRTOS/Source/queue.c **** 	}														\
 252:Libraries/FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL()
 253:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 254:Libraries/FreeRTOS/Source/queue.c **** 
 255:Libraries/FreeRTOS/Source/queue.c **** BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
 256:Libraries/FreeRTOS/Source/queue.c **** {
 257:Libraries/FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 258:Libraries/FreeRTOS/Source/queue.c **** 
 259:Libraries/FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
 260:Libraries/FreeRTOS/Source/queue.c **** 
 261:Libraries/FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 262:Libraries/FreeRTOS/Source/queue.c **** 	{
 263:Libraries/FreeRTOS/Source/queue.c **** 		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 264:Libraries/FreeRTOS/Source/queue.c **** 		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 265:Libraries/FreeRTOS/Source/queue.c **** 		pxQueue->pcWriteTo = pxQueue->pcHead;
 266:Libraries/FreeRTOS/Source/queue.c **** 		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue-
 267:Libraries/FreeRTOS/Source/queue.c **** 		pxQueue->xRxLock = queueUNLOCKED;
 268:Libraries/FreeRTOS/Source/queue.c **** 		pxQueue->xTxLock = queueUNLOCKED;
 269:Libraries/FreeRTOS/Source/queue.c **** 
 270:Libraries/FreeRTOS/Source/queue.c **** 		if( xNewQueue == pdFALSE )
 271:Libraries/FreeRTOS/Source/queue.c **** 		{
 272:Libraries/FreeRTOS/Source/queue.c **** 			/* If there are tasks blocked waiting to read from the queue, then
 273:Libraries/FreeRTOS/Source/queue.c **** 			the tasks will remain blocked as after this function exits the queue
 274:Libraries/FreeRTOS/Source/queue.c **** 			will still be empty.  If there are tasks blocked waiting to write to
 275:Libraries/FreeRTOS/Source/queue.c **** 			the queue, then one should be unblocked as after this function exits
 276:Libraries/FreeRTOS/Source/queue.c **** 			it will be possible to write to it. */
 277:Libraries/FreeRTOS/Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 278:Libraries/FreeRTOS/Source/queue.c **** 			{
 279:Libraries/FreeRTOS/Source/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 280:Libraries/FreeRTOS/Source/queue.c **** 				{
 281:Libraries/FreeRTOS/Source/queue.c **** 					queueYIELD_IF_USING_PREEMPTION();
 282:Libraries/FreeRTOS/Source/queue.c **** 				}
 283:Libraries/FreeRTOS/Source/queue.c **** 				else
 284:Libraries/FreeRTOS/Source/queue.c **** 				{
 285:Libraries/FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
 286:Libraries/FreeRTOS/Source/queue.c **** 				}
 287:Libraries/FreeRTOS/Source/queue.c **** 			}
 288:Libraries/FreeRTOS/Source/queue.c **** 			else
 289:Libraries/FreeRTOS/Source/queue.c **** 			{
 290:Libraries/FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
 291:Libraries/FreeRTOS/Source/queue.c **** 			}
 292:Libraries/FreeRTOS/Source/queue.c **** 		}
 293:Libraries/FreeRTOS/Source/queue.c **** 		else
 294:Libraries/FreeRTOS/Source/queue.c **** 		{
 295:Libraries/FreeRTOS/Source/queue.c **** 			/* Ensure the event queues start in the correct state. */
 296:Libraries/FreeRTOS/Source/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 297:Libraries/FreeRTOS/Source/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 298:Libraries/FreeRTOS/Source/queue.c **** 		}
 299:Libraries/FreeRTOS/Source/queue.c **** 	}
 300:Libraries/FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 301:Libraries/FreeRTOS/Source/queue.c **** 
 302:Libraries/FreeRTOS/Source/queue.c **** 	/* A value is returned for calling semantic consistency with previous
 303:Libraries/FreeRTOS/Source/queue.c **** 	versions. */
 304:Libraries/FreeRTOS/Source/queue.c **** 	return pdPASS;
 305:Libraries/FreeRTOS/Source/queue.c **** }
 306:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 307:Libraries/FreeRTOS/Source/queue.c **** 
 308:Libraries/FreeRTOS/Source/queue.c **** QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, c
 309:Libraries/FreeRTOS/Source/queue.c **** {
 310:Libraries/FreeRTOS/Source/queue.c **** Queue_t *pxNewQueue;
 311:Libraries/FreeRTOS/Source/queue.c **** size_t xQueueSizeInBytes;
 312:Libraries/FreeRTOS/Source/queue.c **** QueueHandle_t xReturn = NULL;
 313:Libraries/FreeRTOS/Source/queue.c **** 
 314:Libraries/FreeRTOS/Source/queue.c **** 	/* Remove compiler warnings about unused parameters should
 315:Libraries/FreeRTOS/Source/queue.c **** 	configUSE_TRACE_FACILITY not be set to 1. */
 316:Libraries/FreeRTOS/Source/queue.c **** 	( void ) ucQueueType;
 317:Libraries/FreeRTOS/Source/queue.c **** 
 318:Libraries/FreeRTOS/Source/queue.c **** 	/* Allocate the new queue structure. */
 319:Libraries/FreeRTOS/Source/queue.c **** 	if( uxQueueLength > ( UBaseType_t ) 0 )
 320:Libraries/FreeRTOS/Source/queue.c **** 	{
 321:Libraries/FreeRTOS/Source/queue.c **** 		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
 322:Libraries/FreeRTOS/Source/queue.c **** 		if( pxNewQueue != NULL )
 323:Libraries/FreeRTOS/Source/queue.c **** 		{
 324:Libraries/FreeRTOS/Source/queue.c **** 			/* Create the list of pointers to queue items.  The queue is one byte
 325:Libraries/FreeRTOS/Source/queue.c **** 			longer than asked for to make wrap checking easier/faster. */
 326:Libraries/FreeRTOS/Source/queue.c **** 			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA
 327:Libraries/FreeRTOS/Source/queue.c **** 
 328:Libraries/FreeRTOS/Source/queue.c **** 			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
 329:Libraries/FreeRTOS/Source/queue.c **** 			if( pxNewQueue->pcHead != NULL )
 330:Libraries/FreeRTOS/Source/queue.c **** 			{
 331:Libraries/FreeRTOS/Source/queue.c **** 				/* Initialise the queue members as described above where the
 332:Libraries/FreeRTOS/Source/queue.c **** 				queue type is defined. */
 333:Libraries/FreeRTOS/Source/queue.c **** 				pxNewQueue->uxLength = uxQueueLength;
 334:Libraries/FreeRTOS/Source/queue.c **** 				pxNewQueue->uxItemSize = uxItemSize;
 335:Libraries/FreeRTOS/Source/queue.c **** 				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 336:Libraries/FreeRTOS/Source/queue.c **** 
 337:Libraries/FreeRTOS/Source/queue.c **** 				#if ( configUSE_TRACE_FACILITY == 1 )
 338:Libraries/FreeRTOS/Source/queue.c **** 				{
 339:Libraries/FreeRTOS/Source/queue.c **** 					pxNewQueue->ucQueueType = ucQueueType;
 340:Libraries/FreeRTOS/Source/queue.c **** 				}
 341:Libraries/FreeRTOS/Source/queue.c **** 				#endif /* configUSE_TRACE_FACILITY */
 342:Libraries/FreeRTOS/Source/queue.c **** 
 343:Libraries/FreeRTOS/Source/queue.c **** 				#if( configUSE_QUEUE_SETS == 1 )
 344:Libraries/FreeRTOS/Source/queue.c **** 				{
 345:Libraries/FreeRTOS/Source/queue.c **** 					pxNewQueue->pxQueueSetContainer = NULL;
 346:Libraries/FreeRTOS/Source/queue.c **** 				}
 347:Libraries/FreeRTOS/Source/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
 348:Libraries/FreeRTOS/Source/queue.c **** 
 349:Libraries/FreeRTOS/Source/queue.c **** 				traceQUEUE_CREATE( pxNewQueue );
 350:Libraries/FreeRTOS/Source/queue.c **** 				xReturn = pxNewQueue;
 351:Libraries/FreeRTOS/Source/queue.c **** 			}
 352:Libraries/FreeRTOS/Source/queue.c **** 			else
 353:Libraries/FreeRTOS/Source/queue.c **** 			{
 354:Libraries/FreeRTOS/Source/queue.c **** 				traceQUEUE_CREATE_FAILED( ucQueueType );
 355:Libraries/FreeRTOS/Source/queue.c **** 				vPortFree( pxNewQueue );
 356:Libraries/FreeRTOS/Source/queue.c **** 			}
 357:Libraries/FreeRTOS/Source/queue.c **** 		}
 358:Libraries/FreeRTOS/Source/queue.c **** 		else
 359:Libraries/FreeRTOS/Source/queue.c **** 		{
 360:Libraries/FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
 361:Libraries/FreeRTOS/Source/queue.c **** 		}
 362:Libraries/FreeRTOS/Source/queue.c **** 	}
 363:Libraries/FreeRTOS/Source/queue.c **** 	else
 364:Libraries/FreeRTOS/Source/queue.c **** 	{
 365:Libraries/FreeRTOS/Source/queue.c **** 		mtCOVERAGE_TEST_MARKER();
 366:Libraries/FreeRTOS/Source/queue.c **** 	}
 367:Libraries/FreeRTOS/Source/queue.c **** 
 368:Libraries/FreeRTOS/Source/queue.c **** 	configASSERT( xReturn );
 369:Libraries/FreeRTOS/Source/queue.c **** 
 370:Libraries/FreeRTOS/Source/queue.c **** 	return xReturn;
 371:Libraries/FreeRTOS/Source/queue.c **** }
 372:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 373:Libraries/FreeRTOS/Source/queue.c **** 
 374:Libraries/FreeRTOS/Source/queue.c **** #if ( configUSE_MUTEXES == 1 )
 375:Libraries/FreeRTOS/Source/queue.c **** 
 376:Libraries/FreeRTOS/Source/queue.c **** 	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
 377:Libraries/FreeRTOS/Source/queue.c **** 	{
 378:Libraries/FreeRTOS/Source/queue.c **** 	Queue_t *pxNewQueue;
 379:Libraries/FreeRTOS/Source/queue.c **** 
 380:Libraries/FreeRTOS/Source/queue.c **** 		/* Prevent compiler warnings about unused parameters if
 381:Libraries/FreeRTOS/Source/queue.c **** 		configUSE_TRACE_FACILITY does not equal 1. */
 382:Libraries/FreeRTOS/Source/queue.c **** 		( void ) ucQueueType;
 383:Libraries/FreeRTOS/Source/queue.c **** 
 384:Libraries/FreeRTOS/Source/queue.c **** 		/* Allocate the new queue structure. */
 385:Libraries/FreeRTOS/Source/queue.c **** 		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
 386:Libraries/FreeRTOS/Source/queue.c **** 		if( pxNewQueue != NULL )
 387:Libraries/FreeRTOS/Source/queue.c **** 		{
 388:Libraries/FreeRTOS/Source/queue.c **** 			/* Information required for priority inheritance. */
 389:Libraries/FreeRTOS/Source/queue.c **** 			pxNewQueue->pxMutexHolder = NULL;
 390:Libraries/FreeRTOS/Source/queue.c **** 			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 391:Libraries/FreeRTOS/Source/queue.c **** 
 392:Libraries/FreeRTOS/Source/queue.c **** 			/* Queues used as a mutex no data is actually copied into or out
 393:Libraries/FreeRTOS/Source/queue.c **** 			of the queue. */
 394:Libraries/FreeRTOS/Source/queue.c **** 			pxNewQueue->pcWriteTo = NULL;
 395:Libraries/FreeRTOS/Source/queue.c **** 			pxNewQueue->u.pcReadFrom = NULL;
 396:Libraries/FreeRTOS/Source/queue.c **** 
 397:Libraries/FreeRTOS/Source/queue.c **** 			/* Each mutex has a length of 1 (like a binary semaphore) and
 398:Libraries/FreeRTOS/Source/queue.c **** 			an item size of 0 as nothing is actually copied into or out
 399:Libraries/FreeRTOS/Source/queue.c **** 			of the mutex. */
 400:Libraries/FreeRTOS/Source/queue.c **** 			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 401:Libraries/FreeRTOS/Source/queue.c **** 			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
 402:Libraries/FreeRTOS/Source/queue.c **** 			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
 403:Libraries/FreeRTOS/Source/queue.c **** 			pxNewQueue->xRxLock = queueUNLOCKED;
 404:Libraries/FreeRTOS/Source/queue.c **** 			pxNewQueue->xTxLock = queueUNLOCKED;
 405:Libraries/FreeRTOS/Source/queue.c **** 
 406:Libraries/FreeRTOS/Source/queue.c **** 			#if ( configUSE_TRACE_FACILITY == 1 )
 407:Libraries/FreeRTOS/Source/queue.c **** 			{
 408:Libraries/FreeRTOS/Source/queue.c **** 				pxNewQueue->ucQueueType = ucQueueType;
 409:Libraries/FreeRTOS/Source/queue.c **** 			}
 410:Libraries/FreeRTOS/Source/queue.c **** 			#endif
 411:Libraries/FreeRTOS/Source/queue.c **** 
 412:Libraries/FreeRTOS/Source/queue.c **** 			#if ( configUSE_QUEUE_SETS == 1 )
 413:Libraries/FreeRTOS/Source/queue.c **** 			{
 414:Libraries/FreeRTOS/Source/queue.c **** 				pxNewQueue->pxQueueSetContainer = NULL;
 415:Libraries/FreeRTOS/Source/queue.c **** 			}
 416:Libraries/FreeRTOS/Source/queue.c **** 			#endif
 417:Libraries/FreeRTOS/Source/queue.c **** 
 418:Libraries/FreeRTOS/Source/queue.c **** 			/* Ensure the event queues start with the correct state. */
 419:Libraries/FreeRTOS/Source/queue.c **** 			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 420:Libraries/FreeRTOS/Source/queue.c **** 			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 421:Libraries/FreeRTOS/Source/queue.c **** 
 422:Libraries/FreeRTOS/Source/queue.c **** 			traceCREATE_MUTEX( pxNewQueue );
 423:Libraries/FreeRTOS/Source/queue.c **** 
 424:Libraries/FreeRTOS/Source/queue.c **** 			/* Start with the semaphore in the expected state. */
 425:Libraries/FreeRTOS/Source/queue.c **** 			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 426:Libraries/FreeRTOS/Source/queue.c **** 		}
 427:Libraries/FreeRTOS/Source/queue.c **** 		else
 428:Libraries/FreeRTOS/Source/queue.c **** 		{
 429:Libraries/FreeRTOS/Source/queue.c **** 			traceCREATE_MUTEX_FAILED();
 430:Libraries/FreeRTOS/Source/queue.c **** 		}
 431:Libraries/FreeRTOS/Source/queue.c **** 
 432:Libraries/FreeRTOS/Source/queue.c **** 		configASSERT( pxNewQueue );
 433:Libraries/FreeRTOS/Source/queue.c **** 		return pxNewQueue;
 434:Libraries/FreeRTOS/Source/queue.c **** 	}
 435:Libraries/FreeRTOS/Source/queue.c **** 
 436:Libraries/FreeRTOS/Source/queue.c **** #endif /* configUSE_MUTEXES */
 437:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 438:Libraries/FreeRTOS/Source/queue.c **** 
 439:Libraries/FreeRTOS/Source/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
 440:Libraries/FreeRTOS/Source/queue.c **** 
 441:Libraries/FreeRTOS/Source/queue.c **** 	void* xQueueGetMutexHolder( QueueHandle_t xSemaphore )
 442:Libraries/FreeRTOS/Source/queue.c **** 	{
 443:Libraries/FreeRTOS/Source/queue.c **** 	void *pxReturn;
 444:Libraries/FreeRTOS/Source/queue.c **** 
 445:Libraries/FreeRTOS/Source/queue.c **** 		/* This function is called by xSemaphoreGetMutexHolder(), and should not
 446:Libraries/FreeRTOS/Source/queue.c **** 		be called directly.  Note:  This is a good way of determining if the
 447:Libraries/FreeRTOS/Source/queue.c **** 		calling task is the mutex holder, but not a good way of determining the
 448:Libraries/FreeRTOS/Source/queue.c **** 		identity of the mutex holder, as the holder may change between the
 449:Libraries/FreeRTOS/Source/queue.c **** 		following critical section exiting and the function returning. */
 450:Libraries/FreeRTOS/Source/queue.c **** 		taskENTER_CRITICAL();
 451:Libraries/FreeRTOS/Source/queue.c **** 		{
 452:Libraries/FreeRTOS/Source/queue.c **** 			if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
 453:Libraries/FreeRTOS/Source/queue.c **** 			{
 454:Libraries/FreeRTOS/Source/queue.c **** 				pxReturn = ( void * ) ( ( Queue_t * ) xSemaphore )->pxMutexHolder;
 455:Libraries/FreeRTOS/Source/queue.c **** 			}
 456:Libraries/FreeRTOS/Source/queue.c **** 			else
 457:Libraries/FreeRTOS/Source/queue.c **** 			{
 458:Libraries/FreeRTOS/Source/queue.c **** 				pxReturn = NULL;
 459:Libraries/FreeRTOS/Source/queue.c **** 			}
 460:Libraries/FreeRTOS/Source/queue.c **** 		}
 461:Libraries/FreeRTOS/Source/queue.c **** 		taskEXIT_CRITICAL();
 462:Libraries/FreeRTOS/Source/queue.c **** 
 463:Libraries/FreeRTOS/Source/queue.c **** 		return pxReturn;
 464:Libraries/FreeRTOS/Source/queue.c **** 	}
 465:Libraries/FreeRTOS/Source/queue.c **** 
 466:Libraries/FreeRTOS/Source/queue.c **** #endif
 467:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 468:Libraries/FreeRTOS/Source/queue.c **** 
 469:Libraries/FreeRTOS/Source/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 470:Libraries/FreeRTOS/Source/queue.c **** 
 471:Libraries/FreeRTOS/Source/queue.c **** 	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
 472:Libraries/FreeRTOS/Source/queue.c **** 	{
 473:Libraries/FreeRTOS/Source/queue.c **** 	BaseType_t xReturn;
 474:Libraries/FreeRTOS/Source/queue.c **** 	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 475:Libraries/FreeRTOS/Source/queue.c **** 
 476:Libraries/FreeRTOS/Source/queue.c **** 		configASSERT( pxMutex );
 477:Libraries/FreeRTOS/Source/queue.c **** 
 478:Libraries/FreeRTOS/Source/queue.c **** 		/* If this is the task that holds the mutex then pxMutexHolder will not
 479:Libraries/FreeRTOS/Source/queue.c **** 		change outside of this task.  If this task does not hold the mutex then
 480:Libraries/FreeRTOS/Source/queue.c **** 		pxMutexHolder can never coincidentally equal the tasks handle, and as
 481:Libraries/FreeRTOS/Source/queue.c **** 		this is the only condition we are interested in it does not matter if
 482:Libraries/FreeRTOS/Source/queue.c **** 		pxMutexHolder is accessed simultaneously by another task.  Therefore no
 483:Libraries/FreeRTOS/Source/queue.c **** 		mutual exclusion is required to test the pxMutexHolder variable. */
 484:Libraries/FreeRTOS/Source/queue.c **** 		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Not a redunda
 485:Libraries/FreeRTOS/Source/queue.c **** 		{
 486:Libraries/FreeRTOS/Source/queue.c **** 			traceGIVE_MUTEX_RECURSIVE( pxMutex );
 487:Libraries/FreeRTOS/Source/queue.c **** 
 488:Libraries/FreeRTOS/Source/queue.c **** 			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
 489:Libraries/FreeRTOS/Source/queue.c **** 			the task handle, therefore no underflow check is required.  Also,
 490:Libraries/FreeRTOS/Source/queue.c **** 			uxRecursiveCallCount is only modified by the mutex holder, and as
 491:Libraries/FreeRTOS/Source/queue.c **** 			there can only be one, no mutual exclusion is required to modify the
 492:Libraries/FreeRTOS/Source/queue.c **** 			uxRecursiveCallCount member. */
 493:Libraries/FreeRTOS/Source/queue.c **** 			( pxMutex->u.uxRecursiveCallCount )--;
 494:Libraries/FreeRTOS/Source/queue.c **** 
 495:Libraries/FreeRTOS/Source/queue.c **** 			/* Have we unwound the call count? */
 496:Libraries/FreeRTOS/Source/queue.c **** 			if( pxMutex->u.uxRecursiveCallCount == ( UBaseType_t ) 0 )
 497:Libraries/FreeRTOS/Source/queue.c **** 			{
 498:Libraries/FreeRTOS/Source/queue.c **** 				/* Return the mutex.  This will automatically unblock any other
 499:Libraries/FreeRTOS/Source/queue.c **** 				task that might be waiting to access the mutex. */
 500:Libraries/FreeRTOS/Source/queue.c **** 				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 501:Libraries/FreeRTOS/Source/queue.c **** 			}
 502:Libraries/FreeRTOS/Source/queue.c **** 			else
 503:Libraries/FreeRTOS/Source/queue.c **** 			{
 504:Libraries/FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
 505:Libraries/FreeRTOS/Source/queue.c **** 			}
 506:Libraries/FreeRTOS/Source/queue.c **** 
 507:Libraries/FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
 508:Libraries/FreeRTOS/Source/queue.c **** 		}
 509:Libraries/FreeRTOS/Source/queue.c **** 		else
 510:Libraries/FreeRTOS/Source/queue.c **** 		{
 511:Libraries/FreeRTOS/Source/queue.c **** 			/* We cannot give the mutex because we are not the holder. */
 512:Libraries/FreeRTOS/Source/queue.c **** 			xReturn = pdFAIL;
 513:Libraries/FreeRTOS/Source/queue.c **** 
 514:Libraries/FreeRTOS/Source/queue.c **** 			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
 515:Libraries/FreeRTOS/Source/queue.c **** 		}
 516:Libraries/FreeRTOS/Source/queue.c **** 
 517:Libraries/FreeRTOS/Source/queue.c **** 		return xReturn;
 518:Libraries/FreeRTOS/Source/queue.c **** 	}
 519:Libraries/FreeRTOS/Source/queue.c **** 
 520:Libraries/FreeRTOS/Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 521:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 522:Libraries/FreeRTOS/Source/queue.c **** 
 523:Libraries/FreeRTOS/Source/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 524:Libraries/FreeRTOS/Source/queue.c **** 
 525:Libraries/FreeRTOS/Source/queue.c **** 	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
 526:Libraries/FreeRTOS/Source/queue.c **** 	{
 527:Libraries/FreeRTOS/Source/queue.c **** 	BaseType_t xReturn;
 528:Libraries/FreeRTOS/Source/queue.c **** 	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 529:Libraries/FreeRTOS/Source/queue.c **** 
 530:Libraries/FreeRTOS/Source/queue.c **** 		configASSERT( pxMutex );
 531:Libraries/FreeRTOS/Source/queue.c **** 
 532:Libraries/FreeRTOS/Source/queue.c **** 		/* Comments regarding mutual exclusion as per those within
 533:Libraries/FreeRTOS/Source/queue.c **** 		xQueueGiveMutexRecursive(). */
 534:Libraries/FreeRTOS/Source/queue.c **** 
 535:Libraries/FreeRTOS/Source/queue.c **** 		traceTAKE_MUTEX_RECURSIVE( pxMutex );
 536:Libraries/FreeRTOS/Source/queue.c **** 
 537:Libraries/FreeRTOS/Source/queue.c **** 		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Cast is not r
 538:Libraries/FreeRTOS/Source/queue.c **** 		{
 539:Libraries/FreeRTOS/Source/queue.c **** 			( pxMutex->u.uxRecursiveCallCount )++;
 540:Libraries/FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
 541:Libraries/FreeRTOS/Source/queue.c **** 		}
 542:Libraries/FreeRTOS/Source/queue.c **** 		else
 543:Libraries/FreeRTOS/Source/queue.c **** 		{
 544:Libraries/FreeRTOS/Source/queue.c **** 			xReturn = xQueueGenericReceive( pxMutex, NULL, xTicksToWait, pdFALSE );
 545:Libraries/FreeRTOS/Source/queue.c **** 
 546:Libraries/FreeRTOS/Source/queue.c **** 			/* pdPASS will only be returned if we successfully obtained the mutex,
 547:Libraries/FreeRTOS/Source/queue.c **** 			we may have blocked to reach here. */
 548:Libraries/FreeRTOS/Source/queue.c **** 			if( xReturn == pdPASS )
 549:Libraries/FreeRTOS/Source/queue.c **** 			{
 550:Libraries/FreeRTOS/Source/queue.c **** 				( pxMutex->u.uxRecursiveCallCount )++;
 551:Libraries/FreeRTOS/Source/queue.c **** 			}
 552:Libraries/FreeRTOS/Source/queue.c **** 			else
 553:Libraries/FreeRTOS/Source/queue.c **** 			{
 554:Libraries/FreeRTOS/Source/queue.c **** 				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
 555:Libraries/FreeRTOS/Source/queue.c **** 			}
 556:Libraries/FreeRTOS/Source/queue.c **** 		}
 557:Libraries/FreeRTOS/Source/queue.c **** 
 558:Libraries/FreeRTOS/Source/queue.c **** 		return xReturn;
 559:Libraries/FreeRTOS/Source/queue.c **** 	}
 560:Libraries/FreeRTOS/Source/queue.c **** 
 561:Libraries/FreeRTOS/Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 562:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 563:Libraries/FreeRTOS/Source/queue.c **** 
 564:Libraries/FreeRTOS/Source/queue.c **** #if ( configUSE_COUNTING_SEMAPHORES == 1 )
 565:Libraries/FreeRTOS/Source/queue.c **** 
 566:Libraries/FreeRTOS/Source/queue.c **** 	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxIni
 567:Libraries/FreeRTOS/Source/queue.c **** 	{
 568:Libraries/FreeRTOS/Source/queue.c **** 	QueueHandle_t xHandle;
 569:Libraries/FreeRTOS/Source/queue.c **** 
 570:Libraries/FreeRTOS/Source/queue.c **** 		configASSERT( uxMaxCount != 0 );
 571:Libraries/FreeRTOS/Source/queue.c **** 		configASSERT( uxInitialCount <= uxMaxCount );
 572:Libraries/FreeRTOS/Source/queue.c **** 
 573:Libraries/FreeRTOS/Source/queue.c **** 		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUN
 574:Libraries/FreeRTOS/Source/queue.c **** 
 575:Libraries/FreeRTOS/Source/queue.c **** 		if( xHandle != NULL )
 576:Libraries/FreeRTOS/Source/queue.c **** 		{
 577:Libraries/FreeRTOS/Source/queue.c **** 			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 578:Libraries/FreeRTOS/Source/queue.c **** 
 579:Libraries/FreeRTOS/Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE();
 580:Libraries/FreeRTOS/Source/queue.c **** 		}
 581:Libraries/FreeRTOS/Source/queue.c **** 		else
 582:Libraries/FreeRTOS/Source/queue.c **** 		{
 583:Libraries/FreeRTOS/Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
 584:Libraries/FreeRTOS/Source/queue.c **** 		}
 585:Libraries/FreeRTOS/Source/queue.c **** 
 586:Libraries/FreeRTOS/Source/queue.c **** 		configASSERT( xHandle );
 587:Libraries/FreeRTOS/Source/queue.c **** 		return xHandle;
 588:Libraries/FreeRTOS/Source/queue.c **** 	}
 589:Libraries/FreeRTOS/Source/queue.c **** 
 590:Libraries/FreeRTOS/Source/queue.c **** #endif /* configUSE_COUNTING_SEMAPHORES */
 591:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 592:Libraries/FreeRTOS/Source/queue.c **** 
 593:Libraries/FreeRTOS/Source/queue.c **** BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xT
 594:Libraries/FreeRTOS/Source/queue.c **** {
 595:Libraries/FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 596:Libraries/FreeRTOS/Source/queue.c **** TimeOut_t xTimeOut;
 597:Libraries/FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 598:Libraries/FreeRTOS/Source/queue.c **** 
 599:Libraries/FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
 600:Libraries/FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 601:Libraries/FreeRTOS/Source/queue.c **** 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 602:Libraries/FreeRTOS/Source/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
 603:Libraries/FreeRTOS/Source/queue.c **** 	{
 604:Libraries/FreeRTOS/Source/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
 605:Libraries/FreeRTOS/Source/queue.c **** 	}
 606:Libraries/FreeRTOS/Source/queue.c **** 	#endif
 607:Libraries/FreeRTOS/Source/queue.c **** 
 608:Libraries/FreeRTOS/Source/queue.c **** 
 609:Libraries/FreeRTOS/Source/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
 610:Libraries/FreeRTOS/Source/queue.c **** 	statements within the function itself.  This is done in the interest
 611:Libraries/FreeRTOS/Source/queue.c **** 	of execution time efficiency. */
 612:Libraries/FreeRTOS/Source/queue.c **** 	for( ;; )
 613:Libraries/FreeRTOS/Source/queue.c **** 	{
 614:Libraries/FreeRTOS/Source/queue.c **** 		taskENTER_CRITICAL();
 615:Libraries/FreeRTOS/Source/queue.c **** 		{
 616:Libraries/FreeRTOS/Source/queue.c **** 			/* Is there room on the queue now?  The running task must be
 617:Libraries/FreeRTOS/Source/queue.c **** 			the highest priority task wanting to access the queue.  If
 618:Libraries/FreeRTOS/Source/queue.c **** 			the head item in the queue is to be overwritten then it does
 619:Libraries/FreeRTOS/Source/queue.c **** 			not matter if the queue is full. */
 620:Libraries/FreeRTOS/Source/queue.c **** 			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 621:Libraries/FreeRTOS/Source/queue.c **** 			{
 622:Libraries/FreeRTOS/Source/queue.c **** 				traceQUEUE_SEND( pxQueue );
 623:Libraries/FreeRTOS/Source/queue.c **** 				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 624:Libraries/FreeRTOS/Source/queue.c **** 
 625:Libraries/FreeRTOS/Source/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
 626:Libraries/FreeRTOS/Source/queue.c **** 				{
 627:Libraries/FreeRTOS/Source/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
 628:Libraries/FreeRTOS/Source/queue.c **** 					{
 629:Libraries/FreeRTOS/Source/queue.c **** 						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
 630:Libraries/FreeRTOS/Source/queue.c **** 						{
 631:Libraries/FreeRTOS/Source/queue.c **** 							/* The queue is a member of a queue set, and posting
 632:Libraries/FreeRTOS/Source/queue.c **** 							to the queue set caused a higher priority task to
 633:Libraries/FreeRTOS/Source/queue.c **** 							unblock. A context switch is required. */
 634:Libraries/FreeRTOS/Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 635:Libraries/FreeRTOS/Source/queue.c **** 						}
 636:Libraries/FreeRTOS/Source/queue.c **** 						else
 637:Libraries/FreeRTOS/Source/queue.c **** 						{
 638:Libraries/FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 639:Libraries/FreeRTOS/Source/queue.c **** 						}
 640:Libraries/FreeRTOS/Source/queue.c **** 					}
 641:Libraries/FreeRTOS/Source/queue.c **** 					else
 642:Libraries/FreeRTOS/Source/queue.c **** 					{
 643:Libraries/FreeRTOS/Source/queue.c **** 						/* If there was a task waiting for data to arrive on the
 644:Libraries/FreeRTOS/Source/queue.c **** 						queue then unblock it now. */
 645:Libraries/FreeRTOS/Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 646:Libraries/FreeRTOS/Source/queue.c **** 						{
 647:Libraries/FreeRTOS/Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 648:Libraries/FreeRTOS/Source/queue.c **** 							{
 649:Libraries/FreeRTOS/Source/queue.c **** 								/* The unblocked task has a priority higher than
 650:Libraries/FreeRTOS/Source/queue.c **** 								our own so yield immediately.  Yes it is ok to
 651:Libraries/FreeRTOS/Source/queue.c **** 								do this from within the critical section - the
 652:Libraries/FreeRTOS/Source/queue.c **** 								kernel takes care of that. */
 653:Libraries/FreeRTOS/Source/queue.c **** 								queueYIELD_IF_USING_PREEMPTION();
 654:Libraries/FreeRTOS/Source/queue.c **** 							}
 655:Libraries/FreeRTOS/Source/queue.c **** 							else
 656:Libraries/FreeRTOS/Source/queue.c **** 							{
 657:Libraries/FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
 658:Libraries/FreeRTOS/Source/queue.c **** 							}
 659:Libraries/FreeRTOS/Source/queue.c **** 						}
 660:Libraries/FreeRTOS/Source/queue.c **** 						else
 661:Libraries/FreeRTOS/Source/queue.c **** 						{
 662:Libraries/FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 663:Libraries/FreeRTOS/Source/queue.c **** 						}
 664:Libraries/FreeRTOS/Source/queue.c **** 					}
 665:Libraries/FreeRTOS/Source/queue.c **** 				}
 666:Libraries/FreeRTOS/Source/queue.c **** 				#else /* configUSE_QUEUE_SETS */
 667:Libraries/FreeRTOS/Source/queue.c **** 				{
 668:Libraries/FreeRTOS/Source/queue.c **** 					/* If there was a task waiting for data to arrive on the
 669:Libraries/FreeRTOS/Source/queue.c **** 					queue then unblock it now. */
 670:Libraries/FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 671:Libraries/FreeRTOS/Source/queue.c **** 					{
 672:Libraries/FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 673:Libraries/FreeRTOS/Source/queue.c **** 						{
 674:Libraries/FreeRTOS/Source/queue.c **** 							/* The unblocked task has a priority higher than
 675:Libraries/FreeRTOS/Source/queue.c **** 							our own so yield immediately.  Yes it is ok to do
 676:Libraries/FreeRTOS/Source/queue.c **** 							this from within the critical section - the kernel
 677:Libraries/FreeRTOS/Source/queue.c **** 							takes care of that. */
 678:Libraries/FreeRTOS/Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 679:Libraries/FreeRTOS/Source/queue.c **** 						}
 680:Libraries/FreeRTOS/Source/queue.c **** 						else
 681:Libraries/FreeRTOS/Source/queue.c **** 						{
 682:Libraries/FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 683:Libraries/FreeRTOS/Source/queue.c **** 						}
 684:Libraries/FreeRTOS/Source/queue.c **** 					}
 685:Libraries/FreeRTOS/Source/queue.c **** 					else
 686:Libraries/FreeRTOS/Source/queue.c **** 					{
 687:Libraries/FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
 688:Libraries/FreeRTOS/Source/queue.c **** 					}
 689:Libraries/FreeRTOS/Source/queue.c **** 				}
 690:Libraries/FreeRTOS/Source/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
 691:Libraries/FreeRTOS/Source/queue.c **** 
 692:Libraries/FreeRTOS/Source/queue.c **** 				taskEXIT_CRITICAL();
 693:Libraries/FreeRTOS/Source/queue.c **** 
 694:Libraries/FreeRTOS/Source/queue.c **** 				/* Return to the original privilege level before exiting the
 695:Libraries/FreeRTOS/Source/queue.c **** 				function. */
 696:Libraries/FreeRTOS/Source/queue.c **** 				return pdPASS;
 697:Libraries/FreeRTOS/Source/queue.c **** 			}
 698:Libraries/FreeRTOS/Source/queue.c **** 			else
 699:Libraries/FreeRTOS/Source/queue.c **** 			{
 700:Libraries/FreeRTOS/Source/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
 701:Libraries/FreeRTOS/Source/queue.c **** 				{
 702:Libraries/FreeRTOS/Source/queue.c **** 					/* The queue was full and no block time is specified (or
 703:Libraries/FreeRTOS/Source/queue.c **** 					the block time has expired) so leave now. */
 704:Libraries/FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 705:Libraries/FreeRTOS/Source/queue.c **** 
 706:Libraries/FreeRTOS/Source/queue.c **** 					/* Return to the original privilege level before exiting
 707:Libraries/FreeRTOS/Source/queue.c **** 					the function. */
 708:Libraries/FreeRTOS/Source/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 709:Libraries/FreeRTOS/Source/queue.c **** 					return errQUEUE_FULL;
 710:Libraries/FreeRTOS/Source/queue.c **** 				}
 711:Libraries/FreeRTOS/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 712:Libraries/FreeRTOS/Source/queue.c **** 				{
 713:Libraries/FreeRTOS/Source/queue.c **** 					/* The queue was full and a block time was specified so
 714:Libraries/FreeRTOS/Source/queue.c **** 					configure the timeout structure. */
 715:Libraries/FreeRTOS/Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 716:Libraries/FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 717:Libraries/FreeRTOS/Source/queue.c **** 				}
 718:Libraries/FreeRTOS/Source/queue.c **** 				else
 719:Libraries/FreeRTOS/Source/queue.c **** 				{
 720:Libraries/FreeRTOS/Source/queue.c **** 					/* Entry time was already set. */
 721:Libraries/FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
 722:Libraries/FreeRTOS/Source/queue.c **** 				}
 723:Libraries/FreeRTOS/Source/queue.c **** 			}
 724:Libraries/FreeRTOS/Source/queue.c **** 		}
 725:Libraries/FreeRTOS/Source/queue.c **** 		taskEXIT_CRITICAL();
 726:Libraries/FreeRTOS/Source/queue.c **** 
 727:Libraries/FreeRTOS/Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
 728:Libraries/FreeRTOS/Source/queue.c **** 		now the critical section has been exited. */
 729:Libraries/FreeRTOS/Source/queue.c **** 
 730:Libraries/FreeRTOS/Source/queue.c **** 		vTaskSuspendAll();
 731:Libraries/FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 732:Libraries/FreeRTOS/Source/queue.c **** 
 733:Libraries/FreeRTOS/Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
 734:Libraries/FreeRTOS/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 735:Libraries/FreeRTOS/Source/queue.c **** 		{
 736:Libraries/FreeRTOS/Source/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 737:Libraries/FreeRTOS/Source/queue.c **** 			{
 738:Libraries/FreeRTOS/Source/queue.c **** 				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 739:Libraries/FreeRTOS/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 740:Libraries/FreeRTOS/Source/queue.c **** 
 741:Libraries/FreeRTOS/Source/queue.c **** 				/* Unlocking the queue means queue events can effect the
 742:Libraries/FreeRTOS/Source/queue.c **** 				event list.  It is possible	that interrupts occurring now
 743:Libraries/FreeRTOS/Source/queue.c **** 				remove this task from the event	list again - but as the
 744:Libraries/FreeRTOS/Source/queue.c **** 				scheduler is suspended the task will go onto the pending
 745:Libraries/FreeRTOS/Source/queue.c **** 				ready last instead of the actual ready list. */
 746:Libraries/FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 747:Libraries/FreeRTOS/Source/queue.c **** 
 748:Libraries/FreeRTOS/Source/queue.c **** 				/* Resuming the scheduler will move tasks from the pending
 749:Libraries/FreeRTOS/Source/queue.c **** 				ready list into the ready list - so it is feasible that this
 750:Libraries/FreeRTOS/Source/queue.c **** 				task is already in a ready list before it yields - in which
 751:Libraries/FreeRTOS/Source/queue.c **** 				case the yield will not cause a context switch unless there
 752:Libraries/FreeRTOS/Source/queue.c **** 				is also a higher priority task in the pending ready list. */
 753:Libraries/FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 754:Libraries/FreeRTOS/Source/queue.c **** 				{
 755:Libraries/FreeRTOS/Source/queue.c **** 					portYIELD_WITHIN_API();
 756:Libraries/FreeRTOS/Source/queue.c **** 				}
 757:Libraries/FreeRTOS/Source/queue.c **** 			}
 758:Libraries/FreeRTOS/Source/queue.c **** 			else
 759:Libraries/FreeRTOS/Source/queue.c **** 			{
 760:Libraries/FreeRTOS/Source/queue.c **** 				/* Try again. */
 761:Libraries/FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 762:Libraries/FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
 763:Libraries/FreeRTOS/Source/queue.c **** 			}
 764:Libraries/FreeRTOS/Source/queue.c **** 		}
 765:Libraries/FreeRTOS/Source/queue.c **** 		else
 766:Libraries/FreeRTOS/Source/queue.c **** 		{
 767:Libraries/FreeRTOS/Source/queue.c **** 			/* The timeout has expired. */
 768:Libraries/FreeRTOS/Source/queue.c **** 			prvUnlockQueue( pxQueue );
 769:Libraries/FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
 770:Libraries/FreeRTOS/Source/queue.c **** 
 771:Libraries/FreeRTOS/Source/queue.c **** 			/* Return to the original privilege level before exiting the
 772:Libraries/FreeRTOS/Source/queue.c **** 			function. */
 773:Libraries/FreeRTOS/Source/queue.c **** 			traceQUEUE_SEND_FAILED( pxQueue );
 774:Libraries/FreeRTOS/Source/queue.c **** 			return errQUEUE_FULL;
 775:Libraries/FreeRTOS/Source/queue.c **** 		}
 776:Libraries/FreeRTOS/Source/queue.c **** 	}
 777:Libraries/FreeRTOS/Source/queue.c **** }
 778:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 779:Libraries/FreeRTOS/Source/queue.c **** 
 780:Libraries/FreeRTOS/Source/queue.c **** #if ( configUSE_ALTERNATIVE_API == 1 )
 781:Libraries/FreeRTOS/Source/queue.c **** 
 782:Libraries/FreeRTOS/Source/queue.c **** 	BaseType_t xQueueAltGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_
 783:Libraries/FreeRTOS/Source/queue.c **** 	{
 784:Libraries/FreeRTOS/Source/queue.c **** 	BaseType_t xEntryTimeSet = pdFALSE;
 785:Libraries/FreeRTOS/Source/queue.c **** 	TimeOut_t xTimeOut;
 786:Libraries/FreeRTOS/Source/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 787:Libraries/FreeRTOS/Source/queue.c **** 
 788:Libraries/FreeRTOS/Source/queue.c **** 		configASSERT( pxQueue );
 789:Libraries/FreeRTOS/Source/queue.c **** 		configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 790:Libraries/FreeRTOS/Source/queue.c **** 
 791:Libraries/FreeRTOS/Source/queue.c **** 		for( ;; )
 792:Libraries/FreeRTOS/Source/queue.c **** 		{
 793:Libraries/FreeRTOS/Source/queue.c **** 			taskENTER_CRITICAL();
 794:Libraries/FreeRTOS/Source/queue.c **** 			{
 795:Libraries/FreeRTOS/Source/queue.c **** 				/* Is there room on the queue now?  To be running we must be
 796:Libraries/FreeRTOS/Source/queue.c **** 				the highest priority task wanting to access the queue. */
 797:Libraries/FreeRTOS/Source/queue.c **** 				if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 798:Libraries/FreeRTOS/Source/queue.c **** 				{
 799:Libraries/FreeRTOS/Source/queue.c **** 					traceQUEUE_SEND( pxQueue );
 800:Libraries/FreeRTOS/Source/queue.c **** 					prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 801:Libraries/FreeRTOS/Source/queue.c **** 
 802:Libraries/FreeRTOS/Source/queue.c **** 					/* If there was a task waiting for data to arrive on the
 803:Libraries/FreeRTOS/Source/queue.c **** 					queue then unblock it now. */
 804:Libraries/FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 805:Libraries/FreeRTOS/Source/queue.c **** 					{
 806:Libraries/FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 807:Libraries/FreeRTOS/Source/queue.c **** 						{
 808:Libraries/FreeRTOS/Source/queue.c **** 							/* The unblocked task has a priority higher than
 809:Libraries/FreeRTOS/Source/queue.c **** 							our own so yield immediately. */
 810:Libraries/FreeRTOS/Source/queue.c **** 							portYIELD_WITHIN_API();
 811:Libraries/FreeRTOS/Source/queue.c **** 						}
 812:Libraries/FreeRTOS/Source/queue.c **** 						else
 813:Libraries/FreeRTOS/Source/queue.c **** 						{
 814:Libraries/FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 815:Libraries/FreeRTOS/Source/queue.c **** 						}
 816:Libraries/FreeRTOS/Source/queue.c **** 					}
 817:Libraries/FreeRTOS/Source/queue.c **** 					else
 818:Libraries/FreeRTOS/Source/queue.c **** 					{
 819:Libraries/FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
 820:Libraries/FreeRTOS/Source/queue.c **** 					}
 821:Libraries/FreeRTOS/Source/queue.c **** 
 822:Libraries/FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 823:Libraries/FreeRTOS/Source/queue.c **** 					return pdPASS;
 824:Libraries/FreeRTOS/Source/queue.c **** 				}
 825:Libraries/FreeRTOS/Source/queue.c **** 				else
 826:Libraries/FreeRTOS/Source/queue.c **** 				{
 827:Libraries/FreeRTOS/Source/queue.c **** 					if( xTicksToWait == ( TickType_t ) 0 )
 828:Libraries/FreeRTOS/Source/queue.c **** 					{
 829:Libraries/FreeRTOS/Source/queue.c **** 						taskEXIT_CRITICAL();
 830:Libraries/FreeRTOS/Source/queue.c **** 						return errQUEUE_FULL;
 831:Libraries/FreeRTOS/Source/queue.c **** 					}
 832:Libraries/FreeRTOS/Source/queue.c **** 					else if( xEntryTimeSet == pdFALSE )
 833:Libraries/FreeRTOS/Source/queue.c **** 					{
 834:Libraries/FreeRTOS/Source/queue.c **** 						vTaskSetTimeOutState( &xTimeOut );
 835:Libraries/FreeRTOS/Source/queue.c **** 						xEntryTimeSet = pdTRUE;
 836:Libraries/FreeRTOS/Source/queue.c **** 					}
 837:Libraries/FreeRTOS/Source/queue.c **** 				}
 838:Libraries/FreeRTOS/Source/queue.c **** 			}
 839:Libraries/FreeRTOS/Source/queue.c **** 			taskEXIT_CRITICAL();
 840:Libraries/FreeRTOS/Source/queue.c **** 
 841:Libraries/FreeRTOS/Source/queue.c **** 			taskENTER_CRITICAL();
 842:Libraries/FreeRTOS/Source/queue.c **** 			{
 843:Libraries/FreeRTOS/Source/queue.c **** 				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 844:Libraries/FreeRTOS/Source/queue.c **** 				{
 845:Libraries/FreeRTOS/Source/queue.c **** 					if( prvIsQueueFull( pxQueue ) != pdFALSE )
 846:Libraries/FreeRTOS/Source/queue.c **** 					{
 847:Libraries/FreeRTOS/Source/queue.c **** 						traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 848:Libraries/FreeRTOS/Source/queue.c **** 						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 849:Libraries/FreeRTOS/Source/queue.c **** 						portYIELD_WITHIN_API();
 850:Libraries/FreeRTOS/Source/queue.c **** 					}
 851:Libraries/FreeRTOS/Source/queue.c **** 					else
 852:Libraries/FreeRTOS/Source/queue.c **** 					{
 853:Libraries/FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
 854:Libraries/FreeRTOS/Source/queue.c **** 					}
 855:Libraries/FreeRTOS/Source/queue.c **** 				}
 856:Libraries/FreeRTOS/Source/queue.c **** 				else
 857:Libraries/FreeRTOS/Source/queue.c **** 				{
 858:Libraries/FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 859:Libraries/FreeRTOS/Source/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 860:Libraries/FreeRTOS/Source/queue.c **** 					return errQUEUE_FULL;
 861:Libraries/FreeRTOS/Source/queue.c **** 				}
 862:Libraries/FreeRTOS/Source/queue.c **** 			}
 863:Libraries/FreeRTOS/Source/queue.c **** 			taskEXIT_CRITICAL();
 864:Libraries/FreeRTOS/Source/queue.c **** 		}
 865:Libraries/FreeRTOS/Source/queue.c **** 	}
 866:Libraries/FreeRTOS/Source/queue.c **** 
 867:Libraries/FreeRTOS/Source/queue.c **** #endif /* configUSE_ALTERNATIVE_API */
 868:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 869:Libraries/FreeRTOS/Source/queue.c **** 
 870:Libraries/FreeRTOS/Source/queue.c **** #if ( configUSE_ALTERNATIVE_API == 1 )
 871:Libraries/FreeRTOS/Source/queue.c **** 
 872:Libraries/FreeRTOS/Source/queue.c **** 	BaseType_t xQueueAltGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicks
 873:Libraries/FreeRTOS/Source/queue.c **** 	{
 874:Libraries/FreeRTOS/Source/queue.c **** 	BaseType_t xEntryTimeSet = pdFALSE;
 875:Libraries/FreeRTOS/Source/queue.c **** 	TimeOut_t xTimeOut;
 876:Libraries/FreeRTOS/Source/queue.c **** 	int8_t *pcOriginalReadPosition;
 877:Libraries/FreeRTOS/Source/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 878:Libraries/FreeRTOS/Source/queue.c **** 
 879:Libraries/FreeRTOS/Source/queue.c **** 		configASSERT( pxQueue );
 880:Libraries/FreeRTOS/Source/queue.c **** 		configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 881:Libraries/FreeRTOS/Source/queue.c **** 
 882:Libraries/FreeRTOS/Source/queue.c **** 		for( ;; )
 883:Libraries/FreeRTOS/Source/queue.c **** 		{
 884:Libraries/FreeRTOS/Source/queue.c **** 			taskENTER_CRITICAL();
 885:Libraries/FreeRTOS/Source/queue.c **** 			{
 886:Libraries/FreeRTOS/Source/queue.c **** 				if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 887:Libraries/FreeRTOS/Source/queue.c **** 				{
 888:Libraries/FreeRTOS/Source/queue.c **** 					/* Remember our read position in case we are just peeking. */
 889:Libraries/FreeRTOS/Source/queue.c **** 					pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 890:Libraries/FreeRTOS/Source/queue.c **** 
 891:Libraries/FreeRTOS/Source/queue.c **** 					prvCopyDataFromQueue( pxQueue, pvBuffer );
 892:Libraries/FreeRTOS/Source/queue.c **** 
 893:Libraries/FreeRTOS/Source/queue.c **** 					if( xJustPeeking == pdFALSE )
 894:Libraries/FreeRTOS/Source/queue.c **** 					{
 895:Libraries/FreeRTOS/Source/queue.c **** 						traceQUEUE_RECEIVE( pxQueue );
 896:Libraries/FreeRTOS/Source/queue.c **** 
 897:Libraries/FreeRTOS/Source/queue.c **** 						/* Data is actually being removed (not just peeked). */
 898:Libraries/FreeRTOS/Source/queue.c **** 						--( pxQueue->uxMessagesWaiting );
 899:Libraries/FreeRTOS/Source/queue.c **** 
 900:Libraries/FreeRTOS/Source/queue.c **** 						#if ( configUSE_MUTEXES == 1 )
 901:Libraries/FreeRTOS/Source/queue.c **** 						{
 902:Libraries/FreeRTOS/Source/queue.c **** 							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 903:Libraries/FreeRTOS/Source/queue.c **** 							{
 904:Libraries/FreeRTOS/Source/queue.c **** 								/* Record the information required to implement
 905:Libraries/FreeRTOS/Source/queue.c **** 								priority inheritance should it become necessary. */
 906:Libraries/FreeRTOS/Source/queue.c **** 								pxQueue->pxMutexHolder = ( int8_t * ) xTaskGetCurrentTaskHandle();
 907:Libraries/FreeRTOS/Source/queue.c **** 							}
 908:Libraries/FreeRTOS/Source/queue.c **** 							else
 909:Libraries/FreeRTOS/Source/queue.c **** 							{
 910:Libraries/FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
 911:Libraries/FreeRTOS/Source/queue.c **** 							}
 912:Libraries/FreeRTOS/Source/queue.c **** 						}
 913:Libraries/FreeRTOS/Source/queue.c **** 						#endif
 914:Libraries/FreeRTOS/Source/queue.c **** 
 915:Libraries/FreeRTOS/Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 916:Libraries/FreeRTOS/Source/queue.c **** 						{
 917:Libraries/FreeRTOS/Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 918:Libraries/FreeRTOS/Source/queue.c **** 							{
 919:Libraries/FreeRTOS/Source/queue.c **** 								portYIELD_WITHIN_API();
 920:Libraries/FreeRTOS/Source/queue.c **** 							}
 921:Libraries/FreeRTOS/Source/queue.c **** 							else
 922:Libraries/FreeRTOS/Source/queue.c **** 							{
 923:Libraries/FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
 924:Libraries/FreeRTOS/Source/queue.c **** 							}
 925:Libraries/FreeRTOS/Source/queue.c **** 						}
 926:Libraries/FreeRTOS/Source/queue.c **** 					}
 927:Libraries/FreeRTOS/Source/queue.c **** 					else
 928:Libraries/FreeRTOS/Source/queue.c **** 					{
 929:Libraries/FreeRTOS/Source/queue.c **** 						traceQUEUE_PEEK( pxQueue );
 930:Libraries/FreeRTOS/Source/queue.c **** 
 931:Libraries/FreeRTOS/Source/queue.c **** 						/* We are not removing the data, so reset our read
 932:Libraries/FreeRTOS/Source/queue.c **** 						pointer. */
 933:Libraries/FreeRTOS/Source/queue.c **** 						pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 934:Libraries/FreeRTOS/Source/queue.c **** 
 935:Libraries/FreeRTOS/Source/queue.c **** 						/* The data is being left in the queue, so see if there are
 936:Libraries/FreeRTOS/Source/queue.c **** 						any other tasks waiting for the data. */
 937:Libraries/FreeRTOS/Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 938:Libraries/FreeRTOS/Source/queue.c **** 						{
 939:Libraries/FreeRTOS/Source/queue.c **** 							/* Tasks that are removed from the event list will get added to
 940:Libraries/FreeRTOS/Source/queue.c **** 							the pending ready list as the scheduler is still suspended. */
 941:Libraries/FreeRTOS/Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 942:Libraries/FreeRTOS/Source/queue.c **** 							{
 943:Libraries/FreeRTOS/Source/queue.c **** 								/* The task waiting has a higher priority than this task. */
 944:Libraries/FreeRTOS/Source/queue.c **** 								portYIELD_WITHIN_API();
 945:Libraries/FreeRTOS/Source/queue.c **** 							}
 946:Libraries/FreeRTOS/Source/queue.c **** 							else
 947:Libraries/FreeRTOS/Source/queue.c **** 							{
 948:Libraries/FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
 949:Libraries/FreeRTOS/Source/queue.c **** 							}
 950:Libraries/FreeRTOS/Source/queue.c **** 						}
 951:Libraries/FreeRTOS/Source/queue.c **** 						else
 952:Libraries/FreeRTOS/Source/queue.c **** 						{
 953:Libraries/FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 954:Libraries/FreeRTOS/Source/queue.c **** 						}
 955:Libraries/FreeRTOS/Source/queue.c **** 					}
 956:Libraries/FreeRTOS/Source/queue.c **** 
 957:Libraries/FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 958:Libraries/FreeRTOS/Source/queue.c **** 					return pdPASS;
 959:Libraries/FreeRTOS/Source/queue.c **** 				}
 960:Libraries/FreeRTOS/Source/queue.c **** 				else
 961:Libraries/FreeRTOS/Source/queue.c **** 				{
 962:Libraries/FreeRTOS/Source/queue.c **** 					if( xTicksToWait == ( TickType_t ) 0 )
 963:Libraries/FreeRTOS/Source/queue.c **** 					{
 964:Libraries/FreeRTOS/Source/queue.c **** 						taskEXIT_CRITICAL();
 965:Libraries/FreeRTOS/Source/queue.c **** 						traceQUEUE_RECEIVE_FAILED( pxQueue );
 966:Libraries/FreeRTOS/Source/queue.c **** 						return errQUEUE_EMPTY;
 967:Libraries/FreeRTOS/Source/queue.c **** 					}
 968:Libraries/FreeRTOS/Source/queue.c **** 					else if( xEntryTimeSet == pdFALSE )
 969:Libraries/FreeRTOS/Source/queue.c **** 					{
 970:Libraries/FreeRTOS/Source/queue.c **** 						vTaskSetTimeOutState( &xTimeOut );
 971:Libraries/FreeRTOS/Source/queue.c **** 						xEntryTimeSet = pdTRUE;
 972:Libraries/FreeRTOS/Source/queue.c **** 					}
 973:Libraries/FreeRTOS/Source/queue.c **** 				}
 974:Libraries/FreeRTOS/Source/queue.c **** 			}
 975:Libraries/FreeRTOS/Source/queue.c **** 			taskEXIT_CRITICAL();
 976:Libraries/FreeRTOS/Source/queue.c **** 
 977:Libraries/FreeRTOS/Source/queue.c **** 			taskENTER_CRITICAL();
 978:Libraries/FreeRTOS/Source/queue.c **** 			{
 979:Libraries/FreeRTOS/Source/queue.c **** 				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 980:Libraries/FreeRTOS/Source/queue.c **** 				{
 981:Libraries/FreeRTOS/Source/queue.c **** 					if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 982:Libraries/FreeRTOS/Source/queue.c **** 					{
 983:Libraries/FreeRTOS/Source/queue.c **** 						traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
 984:Libraries/FreeRTOS/Source/queue.c **** 
 985:Libraries/FreeRTOS/Source/queue.c **** 						#if ( configUSE_MUTEXES == 1 )
 986:Libraries/FreeRTOS/Source/queue.c **** 						{
 987:Libraries/FreeRTOS/Source/queue.c **** 							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 988:Libraries/FreeRTOS/Source/queue.c **** 							{
 989:Libraries/FreeRTOS/Source/queue.c **** 								taskENTER_CRITICAL();
 990:Libraries/FreeRTOS/Source/queue.c **** 								{
 991:Libraries/FreeRTOS/Source/queue.c **** 									vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 992:Libraries/FreeRTOS/Source/queue.c **** 								}
 993:Libraries/FreeRTOS/Source/queue.c **** 								taskEXIT_CRITICAL();
 994:Libraries/FreeRTOS/Source/queue.c **** 							}
 995:Libraries/FreeRTOS/Source/queue.c **** 							else
 996:Libraries/FreeRTOS/Source/queue.c **** 							{
 997:Libraries/FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
 998:Libraries/FreeRTOS/Source/queue.c **** 							}
 999:Libraries/FreeRTOS/Source/queue.c **** 						}
1000:Libraries/FreeRTOS/Source/queue.c **** 						#endif
1001:Libraries/FreeRTOS/Source/queue.c **** 
1002:Libraries/FreeRTOS/Source/queue.c **** 						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
1003:Libraries/FreeRTOS/Source/queue.c **** 						portYIELD_WITHIN_API();
1004:Libraries/FreeRTOS/Source/queue.c **** 					}
1005:Libraries/FreeRTOS/Source/queue.c **** 					else
1006:Libraries/FreeRTOS/Source/queue.c **** 					{
1007:Libraries/FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1008:Libraries/FreeRTOS/Source/queue.c **** 					}
1009:Libraries/FreeRTOS/Source/queue.c **** 				}
1010:Libraries/FreeRTOS/Source/queue.c **** 				else
1011:Libraries/FreeRTOS/Source/queue.c **** 				{
1012:Libraries/FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
1013:Libraries/FreeRTOS/Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
1014:Libraries/FreeRTOS/Source/queue.c **** 					return errQUEUE_EMPTY;
1015:Libraries/FreeRTOS/Source/queue.c **** 				}
1016:Libraries/FreeRTOS/Source/queue.c **** 			}
1017:Libraries/FreeRTOS/Source/queue.c **** 			taskEXIT_CRITICAL();
1018:Libraries/FreeRTOS/Source/queue.c **** 		}
1019:Libraries/FreeRTOS/Source/queue.c **** 	}
1020:Libraries/FreeRTOS/Source/queue.c **** 
1021:Libraries/FreeRTOS/Source/queue.c **** 
1022:Libraries/FreeRTOS/Source/queue.c **** #endif /* configUSE_ALTERNATIVE_API */
1023:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1024:Libraries/FreeRTOS/Source/queue.c **** 
1025:Libraries/FreeRTOS/Source/queue.c **** BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseTy
1026:Libraries/FreeRTOS/Source/queue.c **** {
1027:Libraries/FreeRTOS/Source/queue.c **** BaseType_t xReturn;
1028:Libraries/FreeRTOS/Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
1029:Libraries/FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
1030:Libraries/FreeRTOS/Source/queue.c **** 
1031:Libraries/FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1032:Libraries/FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1033:Libraries/FreeRTOS/Source/queue.c **** 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
1034:Libraries/FreeRTOS/Source/queue.c **** 
1035:Libraries/FreeRTOS/Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1036:Libraries/FreeRTOS/Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1037:Libraries/FreeRTOS/Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1038:Libraries/FreeRTOS/Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1039:Libraries/FreeRTOS/Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1040:Libraries/FreeRTOS/Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1041:Libraries/FreeRTOS/Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1042:Libraries/FreeRTOS/Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
1043:Libraries/FreeRTOS/Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1044:Libraries/FreeRTOS/Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1045:Libraries/FreeRTOS/Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1046:Libraries/FreeRTOS/Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1047:Libraries/FreeRTOS/Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1048:Libraries/FreeRTOS/Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1049:Libraries/FreeRTOS/Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1050:Libraries/FreeRTOS/Source/queue.c **** 
1051:Libraries/FreeRTOS/Source/queue.c **** 	/* Similar to xQueueGenericSend, except without blocking if there is no room
1052:Libraries/FreeRTOS/Source/queue.c **** 	in the queue.  Also don't directly wake a task that was blocked on a queue
1053:Libraries/FreeRTOS/Source/queue.c **** 	read, instead return a flag to say whether a context switch is required or
1054:Libraries/FreeRTOS/Source/queue.c **** 	not (i.e. has a task with a higher priority than us been woken by this
1055:Libraries/FreeRTOS/Source/queue.c **** 	post). */
1056:Libraries/FreeRTOS/Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1057:Libraries/FreeRTOS/Source/queue.c **** 	{
1058:Libraries/FreeRTOS/Source/queue.c **** 		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
1059:Libraries/FreeRTOS/Source/queue.c **** 		{
1060:Libraries/FreeRTOS/Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR( pxQueue );
1061:Libraries/FreeRTOS/Source/queue.c **** 
1062:Libraries/FreeRTOS/Source/queue.c **** 			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
1063:Libraries/FreeRTOS/Source/queue.c **** 
1064:Libraries/FreeRTOS/Source/queue.c **** 			/* The event list is not altered if the queue is locked.  This will
1065:Libraries/FreeRTOS/Source/queue.c **** 			be done when the queue is unlocked later. */
1066:Libraries/FreeRTOS/Source/queue.c **** 			if( pxQueue->xTxLock == queueUNLOCKED )
1067:Libraries/FreeRTOS/Source/queue.c **** 			{
1068:Libraries/FreeRTOS/Source/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
1069:Libraries/FreeRTOS/Source/queue.c **** 				{
1070:Libraries/FreeRTOS/Source/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
1071:Libraries/FreeRTOS/Source/queue.c **** 					{
1072:Libraries/FreeRTOS/Source/queue.c **** 						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
1073:Libraries/FreeRTOS/Source/queue.c **** 						{
1074:Libraries/FreeRTOS/Source/queue.c **** 							/* The queue is a member of a queue set, and posting
1075:Libraries/FreeRTOS/Source/queue.c **** 							to the queue set caused a higher priority task to
1076:Libraries/FreeRTOS/Source/queue.c **** 							unblock.  A context switch is required. */
1077:Libraries/FreeRTOS/Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
1078:Libraries/FreeRTOS/Source/queue.c **** 							{
1079:Libraries/FreeRTOS/Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
1080:Libraries/FreeRTOS/Source/queue.c **** 							}
1081:Libraries/FreeRTOS/Source/queue.c **** 							else
1082:Libraries/FreeRTOS/Source/queue.c **** 							{
1083:Libraries/FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1084:Libraries/FreeRTOS/Source/queue.c **** 							}
1085:Libraries/FreeRTOS/Source/queue.c **** 						}
1086:Libraries/FreeRTOS/Source/queue.c **** 						else
1087:Libraries/FreeRTOS/Source/queue.c **** 						{
1088:Libraries/FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1089:Libraries/FreeRTOS/Source/queue.c **** 						}
1090:Libraries/FreeRTOS/Source/queue.c **** 					}
1091:Libraries/FreeRTOS/Source/queue.c **** 					else
1092:Libraries/FreeRTOS/Source/queue.c **** 					{
1093:Libraries/FreeRTOS/Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1094:Libraries/FreeRTOS/Source/queue.c **** 						{
1095:Libraries/FreeRTOS/Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1096:Libraries/FreeRTOS/Source/queue.c **** 							{
1097:Libraries/FreeRTOS/Source/queue.c **** 								/* The task waiting has a higher priority so record that a
1098:Libraries/FreeRTOS/Source/queue.c **** 								context	switch is required. */
1099:Libraries/FreeRTOS/Source/queue.c **** 								if( pxHigherPriorityTaskWoken != NULL )
1100:Libraries/FreeRTOS/Source/queue.c **** 								{
1101:Libraries/FreeRTOS/Source/queue.c **** 									*pxHigherPriorityTaskWoken = pdTRUE;
1102:Libraries/FreeRTOS/Source/queue.c **** 								}
1103:Libraries/FreeRTOS/Source/queue.c **** 								else
1104:Libraries/FreeRTOS/Source/queue.c **** 								{
1105:Libraries/FreeRTOS/Source/queue.c **** 									mtCOVERAGE_TEST_MARKER();
1106:Libraries/FreeRTOS/Source/queue.c **** 								}
1107:Libraries/FreeRTOS/Source/queue.c **** 							}
1108:Libraries/FreeRTOS/Source/queue.c **** 							else
1109:Libraries/FreeRTOS/Source/queue.c **** 							{
1110:Libraries/FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1111:Libraries/FreeRTOS/Source/queue.c **** 							}
1112:Libraries/FreeRTOS/Source/queue.c **** 						}
1113:Libraries/FreeRTOS/Source/queue.c **** 						else
1114:Libraries/FreeRTOS/Source/queue.c **** 						{
1115:Libraries/FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1116:Libraries/FreeRTOS/Source/queue.c **** 						}
1117:Libraries/FreeRTOS/Source/queue.c **** 					}
1118:Libraries/FreeRTOS/Source/queue.c **** 				}
1119:Libraries/FreeRTOS/Source/queue.c **** 				#else /* configUSE_QUEUE_SETS */
1120:Libraries/FreeRTOS/Source/queue.c **** 				{
1121:Libraries/FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1122:Libraries/FreeRTOS/Source/queue.c **** 					{
1123:Libraries/FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1124:Libraries/FreeRTOS/Source/queue.c **** 						{
1125:Libraries/FreeRTOS/Source/queue.c **** 							/* The task waiting has a higher priority so record that a
1126:Libraries/FreeRTOS/Source/queue.c **** 							context	switch is required. */
1127:Libraries/FreeRTOS/Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
1128:Libraries/FreeRTOS/Source/queue.c **** 							{
1129:Libraries/FreeRTOS/Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
1130:Libraries/FreeRTOS/Source/queue.c **** 							}
1131:Libraries/FreeRTOS/Source/queue.c **** 							else
1132:Libraries/FreeRTOS/Source/queue.c **** 							{
1133:Libraries/FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1134:Libraries/FreeRTOS/Source/queue.c **** 							}
1135:Libraries/FreeRTOS/Source/queue.c **** 						}
1136:Libraries/FreeRTOS/Source/queue.c **** 						else
1137:Libraries/FreeRTOS/Source/queue.c **** 						{
1138:Libraries/FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1139:Libraries/FreeRTOS/Source/queue.c **** 						}
1140:Libraries/FreeRTOS/Source/queue.c **** 					}
1141:Libraries/FreeRTOS/Source/queue.c **** 					else
1142:Libraries/FreeRTOS/Source/queue.c **** 					{
1143:Libraries/FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1144:Libraries/FreeRTOS/Source/queue.c **** 					}
1145:Libraries/FreeRTOS/Source/queue.c **** 				}
1146:Libraries/FreeRTOS/Source/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
1147:Libraries/FreeRTOS/Source/queue.c **** 			}
1148:Libraries/FreeRTOS/Source/queue.c **** 			else
1149:Libraries/FreeRTOS/Source/queue.c **** 			{
1150:Libraries/FreeRTOS/Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1151:Libraries/FreeRTOS/Source/queue.c **** 				knows that data was posted while it was locked. */
1152:Libraries/FreeRTOS/Source/queue.c **** 				++( pxQueue->xTxLock );
1153:Libraries/FreeRTOS/Source/queue.c **** 			}
1154:Libraries/FreeRTOS/Source/queue.c **** 
1155:Libraries/FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
1156:Libraries/FreeRTOS/Source/queue.c **** 		}
1157:Libraries/FreeRTOS/Source/queue.c **** 		else
1158:Libraries/FreeRTOS/Source/queue.c **** 		{
1159:Libraries/FreeRTOS/Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1160:Libraries/FreeRTOS/Source/queue.c **** 			xReturn = errQUEUE_FULL;
1161:Libraries/FreeRTOS/Source/queue.c **** 		}
1162:Libraries/FreeRTOS/Source/queue.c **** 	}
1163:Libraries/FreeRTOS/Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1164:Libraries/FreeRTOS/Source/queue.c **** 
1165:Libraries/FreeRTOS/Source/queue.c **** 	return xReturn;
1166:Libraries/FreeRTOS/Source/queue.c **** }
1167:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1168:Libraries/FreeRTOS/Source/queue.c **** 
1169:Libraries/FreeRTOS/Source/queue.c **** BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWa
1170:Libraries/FreeRTOS/Source/queue.c **** {
1171:Libraries/FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
1172:Libraries/FreeRTOS/Source/queue.c **** TimeOut_t xTimeOut;
1173:Libraries/FreeRTOS/Source/queue.c **** int8_t *pcOriginalReadPosition;
1174:Libraries/FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
1175:Libraries/FreeRTOS/Source/queue.c **** 
1176:Libraries/FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1177:Libraries/FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1178:Libraries/FreeRTOS/Source/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1179:Libraries/FreeRTOS/Source/queue.c **** 	{
1180:Libraries/FreeRTOS/Source/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
1181:Libraries/FreeRTOS/Source/queue.c **** 	}
1182:Libraries/FreeRTOS/Source/queue.c **** 	#endif
1183:Libraries/FreeRTOS/Source/queue.c **** 
1184:Libraries/FreeRTOS/Source/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
1185:Libraries/FreeRTOS/Source/queue.c **** 	statements within the function itself.  This is done in the interest
1186:Libraries/FreeRTOS/Source/queue.c **** 	of execution time efficiency. */
1187:Libraries/FreeRTOS/Source/queue.c **** 
1188:Libraries/FreeRTOS/Source/queue.c **** 	for( ;; )
1189:Libraries/FreeRTOS/Source/queue.c **** 	{
1190:Libraries/FreeRTOS/Source/queue.c **** 		taskENTER_CRITICAL();
1191:Libraries/FreeRTOS/Source/queue.c **** 		{
1192:Libraries/FreeRTOS/Source/queue.c **** 			/* Is there data in the queue now?  To be running we must be
1193:Libraries/FreeRTOS/Source/queue.c **** 			the highest priority task wanting to access the queue. */
1194:Libraries/FreeRTOS/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
1195:Libraries/FreeRTOS/Source/queue.c **** 			{
1196:Libraries/FreeRTOS/Source/queue.c **** 				/* Remember the read position in case the queue is only being
1197:Libraries/FreeRTOS/Source/queue.c **** 				peeked. */
1198:Libraries/FreeRTOS/Source/queue.c **** 				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
1199:Libraries/FreeRTOS/Source/queue.c **** 
1200:Libraries/FreeRTOS/Source/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
1201:Libraries/FreeRTOS/Source/queue.c **** 
1202:Libraries/FreeRTOS/Source/queue.c **** 				if( xJustPeeking == pdFALSE )
1203:Libraries/FreeRTOS/Source/queue.c **** 				{
1204:Libraries/FreeRTOS/Source/queue.c **** 					traceQUEUE_RECEIVE( pxQueue );
1205:Libraries/FreeRTOS/Source/queue.c **** 
1206:Libraries/FreeRTOS/Source/queue.c **** 					/* Actually removing data, not just peeking. */
1207:Libraries/FreeRTOS/Source/queue.c **** 					--( pxQueue->uxMessagesWaiting );
1208:Libraries/FreeRTOS/Source/queue.c **** 
1209:Libraries/FreeRTOS/Source/queue.c **** 					#if ( configUSE_MUTEXES == 1 )
1210:Libraries/FreeRTOS/Source/queue.c **** 					{
1211:Libraries/FreeRTOS/Source/queue.c **** 						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1212:Libraries/FreeRTOS/Source/queue.c **** 						{
1213:Libraries/FreeRTOS/Source/queue.c **** 							/* Record the information required to implement
1214:Libraries/FreeRTOS/Source/queue.c **** 							priority inheritance should it become necessary. */
1215:Libraries/FreeRTOS/Source/queue.c **** 							pxQueue->pxMutexHolder = ( int8_t * ) xTaskGetCurrentTaskHandle(); /*lint !e961 Cast is not 
1216:Libraries/FreeRTOS/Source/queue.c **** 						}
1217:Libraries/FreeRTOS/Source/queue.c **** 						else
1218:Libraries/FreeRTOS/Source/queue.c **** 						{
1219:Libraries/FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1220:Libraries/FreeRTOS/Source/queue.c **** 						}
1221:Libraries/FreeRTOS/Source/queue.c **** 					}
1222:Libraries/FreeRTOS/Source/queue.c **** 					#endif
1223:Libraries/FreeRTOS/Source/queue.c **** 
1224:Libraries/FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1225:Libraries/FreeRTOS/Source/queue.c **** 					{
1226:Libraries/FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
1227:Libraries/FreeRTOS/Source/queue.c **** 						{
1228:Libraries/FreeRTOS/Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
1229:Libraries/FreeRTOS/Source/queue.c **** 						}
1230:Libraries/FreeRTOS/Source/queue.c **** 						else
1231:Libraries/FreeRTOS/Source/queue.c **** 						{
1232:Libraries/FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1233:Libraries/FreeRTOS/Source/queue.c **** 						}
1234:Libraries/FreeRTOS/Source/queue.c **** 					}
1235:Libraries/FreeRTOS/Source/queue.c **** 					else
1236:Libraries/FreeRTOS/Source/queue.c **** 					{
1237:Libraries/FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1238:Libraries/FreeRTOS/Source/queue.c **** 					}
1239:Libraries/FreeRTOS/Source/queue.c **** 				}
1240:Libraries/FreeRTOS/Source/queue.c **** 				else
1241:Libraries/FreeRTOS/Source/queue.c **** 				{
1242:Libraries/FreeRTOS/Source/queue.c **** 					traceQUEUE_PEEK( pxQueue );
1243:Libraries/FreeRTOS/Source/queue.c **** 
1244:Libraries/FreeRTOS/Source/queue.c **** 					/* The data is not being removed, so reset the read
1245:Libraries/FreeRTOS/Source/queue.c **** 					pointer. */
1246:Libraries/FreeRTOS/Source/queue.c **** 					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
1247:Libraries/FreeRTOS/Source/queue.c **** 
1248:Libraries/FreeRTOS/Source/queue.c **** 					/* The data is being left in the queue, so see if there are
1249:Libraries/FreeRTOS/Source/queue.c **** 					any other tasks waiting for the data. */
1250:Libraries/FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1251:Libraries/FreeRTOS/Source/queue.c **** 					{
1252:Libraries/FreeRTOS/Source/queue.c **** 						/* Tasks that are removed from the event list will get added to
1253:Libraries/FreeRTOS/Source/queue.c **** 						the pending ready list as the scheduler is still suspended. */
1254:Libraries/FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1255:Libraries/FreeRTOS/Source/queue.c **** 						{
1256:Libraries/FreeRTOS/Source/queue.c **** 							/* The task waiting has a higher priority than this task. */
1257:Libraries/FreeRTOS/Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
1258:Libraries/FreeRTOS/Source/queue.c **** 						}
1259:Libraries/FreeRTOS/Source/queue.c **** 						else
1260:Libraries/FreeRTOS/Source/queue.c **** 						{
1261:Libraries/FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1262:Libraries/FreeRTOS/Source/queue.c **** 						}
1263:Libraries/FreeRTOS/Source/queue.c **** 					}
1264:Libraries/FreeRTOS/Source/queue.c **** 					else
1265:Libraries/FreeRTOS/Source/queue.c **** 					{
1266:Libraries/FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1267:Libraries/FreeRTOS/Source/queue.c **** 					}
1268:Libraries/FreeRTOS/Source/queue.c **** 				}
1269:Libraries/FreeRTOS/Source/queue.c **** 
1270:Libraries/FreeRTOS/Source/queue.c **** 				taskEXIT_CRITICAL();
1271:Libraries/FreeRTOS/Source/queue.c **** 				return pdPASS;
1272:Libraries/FreeRTOS/Source/queue.c **** 			}
1273:Libraries/FreeRTOS/Source/queue.c **** 			else
1274:Libraries/FreeRTOS/Source/queue.c **** 			{
1275:Libraries/FreeRTOS/Source/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
1276:Libraries/FreeRTOS/Source/queue.c **** 				{
1277:Libraries/FreeRTOS/Source/queue.c **** 					/* The queue was empty and no block time is specified (or
1278:Libraries/FreeRTOS/Source/queue.c **** 					the block time has expired) so leave now. */
1279:Libraries/FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
1280:Libraries/FreeRTOS/Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
1281:Libraries/FreeRTOS/Source/queue.c **** 					return errQUEUE_EMPTY;
1282:Libraries/FreeRTOS/Source/queue.c **** 				}
1283:Libraries/FreeRTOS/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
1284:Libraries/FreeRTOS/Source/queue.c **** 				{
1285:Libraries/FreeRTOS/Source/queue.c **** 					/* The queue was empty and a block time was specified so
1286:Libraries/FreeRTOS/Source/queue.c **** 					configure the timeout structure. */
1287:Libraries/FreeRTOS/Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
1288:Libraries/FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
1289:Libraries/FreeRTOS/Source/queue.c **** 				}
1290:Libraries/FreeRTOS/Source/queue.c **** 				else
1291:Libraries/FreeRTOS/Source/queue.c **** 				{
1292:Libraries/FreeRTOS/Source/queue.c **** 					/* Entry time was already set. */
1293:Libraries/FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1294:Libraries/FreeRTOS/Source/queue.c **** 				}
1295:Libraries/FreeRTOS/Source/queue.c **** 			}
1296:Libraries/FreeRTOS/Source/queue.c **** 		}
1297:Libraries/FreeRTOS/Source/queue.c **** 		taskEXIT_CRITICAL();
1298:Libraries/FreeRTOS/Source/queue.c **** 
1299:Libraries/FreeRTOS/Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
1300:Libraries/FreeRTOS/Source/queue.c **** 		now the critical section has been exited. */
1301:Libraries/FreeRTOS/Source/queue.c **** 
1302:Libraries/FreeRTOS/Source/queue.c **** 		vTaskSuspendAll();
1303:Libraries/FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
1304:Libraries/FreeRTOS/Source/queue.c **** 
1305:Libraries/FreeRTOS/Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
1306:Libraries/FreeRTOS/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
1307:Libraries/FreeRTOS/Source/queue.c **** 		{
1308:Libraries/FreeRTOS/Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1309:Libraries/FreeRTOS/Source/queue.c **** 			{
1310:Libraries/FreeRTOS/Source/queue.c **** 				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1311:Libraries/FreeRTOS/Source/queue.c **** 
1312:Libraries/FreeRTOS/Source/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
1313:Libraries/FreeRTOS/Source/queue.c **** 				{
1314:Libraries/FreeRTOS/Source/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1315:Libraries/FreeRTOS/Source/queue.c **** 					{
1316:Libraries/FreeRTOS/Source/queue.c **** 						taskENTER_CRITICAL();
1317:Libraries/FreeRTOS/Source/queue.c **** 						{
1318:Libraries/FreeRTOS/Source/queue.c **** 							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
1319:Libraries/FreeRTOS/Source/queue.c **** 						}
1320:Libraries/FreeRTOS/Source/queue.c **** 						taskEXIT_CRITICAL();
1321:Libraries/FreeRTOS/Source/queue.c **** 					}
1322:Libraries/FreeRTOS/Source/queue.c **** 					else
1323:Libraries/FreeRTOS/Source/queue.c **** 					{
1324:Libraries/FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1325:Libraries/FreeRTOS/Source/queue.c **** 					}
1326:Libraries/FreeRTOS/Source/queue.c **** 				}
1327:Libraries/FreeRTOS/Source/queue.c **** 				#endif
1328:Libraries/FreeRTOS/Source/queue.c **** 
1329:Libraries/FreeRTOS/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
1330:Libraries/FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
1331:Libraries/FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
1332:Libraries/FreeRTOS/Source/queue.c **** 				{
1333:Libraries/FreeRTOS/Source/queue.c **** 					portYIELD_WITHIN_API();
1334:Libraries/FreeRTOS/Source/queue.c **** 				}
1335:Libraries/FreeRTOS/Source/queue.c **** 				else
1336:Libraries/FreeRTOS/Source/queue.c **** 				{
1337:Libraries/FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1338:Libraries/FreeRTOS/Source/queue.c **** 				}
1339:Libraries/FreeRTOS/Source/queue.c **** 			}
1340:Libraries/FreeRTOS/Source/queue.c **** 			else
1341:Libraries/FreeRTOS/Source/queue.c **** 			{
1342:Libraries/FreeRTOS/Source/queue.c **** 				/* Try again. */
1343:Libraries/FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
1344:Libraries/FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
1345:Libraries/FreeRTOS/Source/queue.c **** 			}
1346:Libraries/FreeRTOS/Source/queue.c **** 		}
1347:Libraries/FreeRTOS/Source/queue.c **** 		else
1348:Libraries/FreeRTOS/Source/queue.c **** 		{
1349:Libraries/FreeRTOS/Source/queue.c **** 			prvUnlockQueue( pxQueue );
1350:Libraries/FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
1351:Libraries/FreeRTOS/Source/queue.c **** 			traceQUEUE_RECEIVE_FAILED( pxQueue );
1352:Libraries/FreeRTOS/Source/queue.c **** 			return errQUEUE_EMPTY;
1353:Libraries/FreeRTOS/Source/queue.c **** 		}
1354:Libraries/FreeRTOS/Source/queue.c **** 	}
1355:Libraries/FreeRTOS/Source/queue.c **** }
1356:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1357:Libraries/FreeRTOS/Source/queue.c **** 
1358:Libraries/FreeRTOS/Source/queue.c **** BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const px
1359:Libraries/FreeRTOS/Source/queue.c **** {
1360:Libraries/FreeRTOS/Source/queue.c **** BaseType_t xReturn;
1361:Libraries/FreeRTOS/Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
1362:Libraries/FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
1363:Libraries/FreeRTOS/Source/queue.c **** 
1364:Libraries/FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1365:Libraries/FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1366:Libraries/FreeRTOS/Source/queue.c **** 
1367:Libraries/FreeRTOS/Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1368:Libraries/FreeRTOS/Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1369:Libraries/FreeRTOS/Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1370:Libraries/FreeRTOS/Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1371:Libraries/FreeRTOS/Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1372:Libraries/FreeRTOS/Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1373:Libraries/FreeRTOS/Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1374:Libraries/FreeRTOS/Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
1375:Libraries/FreeRTOS/Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1376:Libraries/FreeRTOS/Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1377:Libraries/FreeRTOS/Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1378:Libraries/FreeRTOS/Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1379:Libraries/FreeRTOS/Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1380:Libraries/FreeRTOS/Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1381:Libraries/FreeRTOS/Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1382:Libraries/FreeRTOS/Source/queue.c **** 
1383:Libraries/FreeRTOS/Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1384:Libraries/FreeRTOS/Source/queue.c **** 	{
1385:Libraries/FreeRTOS/Source/queue.c **** 		/* Cannot block in an ISR, so check there is data available. */
1386:Libraries/FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
1387:Libraries/FreeRTOS/Source/queue.c **** 		{
1388:Libraries/FreeRTOS/Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
1389:Libraries/FreeRTOS/Source/queue.c **** 
1390:Libraries/FreeRTOS/Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
1391:Libraries/FreeRTOS/Source/queue.c **** 			--( pxQueue->uxMessagesWaiting );
1392:Libraries/FreeRTOS/Source/queue.c **** 
1393:Libraries/FreeRTOS/Source/queue.c **** 			/* If the queue is locked the event list will not be modified.
1394:Libraries/FreeRTOS/Source/queue.c **** 			Instead update the lock count so the task that unlocks the queue
1395:Libraries/FreeRTOS/Source/queue.c **** 			will know that an ISR has removed data while the queue was
1396:Libraries/FreeRTOS/Source/queue.c **** 			locked. */
1397:Libraries/FreeRTOS/Source/queue.c **** 			if( pxQueue->xRxLock == queueUNLOCKED )
1398:Libraries/FreeRTOS/Source/queue.c **** 			{
1399:Libraries/FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1400:Libraries/FreeRTOS/Source/queue.c **** 				{
1401:Libraries/FreeRTOS/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1402:Libraries/FreeRTOS/Source/queue.c **** 					{
1403:Libraries/FreeRTOS/Source/queue.c **** 						/* The task waiting has a higher priority than us so
1404:Libraries/FreeRTOS/Source/queue.c **** 						force a context switch. */
1405:Libraries/FreeRTOS/Source/queue.c **** 						if( pxHigherPriorityTaskWoken != NULL )
1406:Libraries/FreeRTOS/Source/queue.c **** 						{
1407:Libraries/FreeRTOS/Source/queue.c **** 							*pxHigherPriorityTaskWoken = pdTRUE;
1408:Libraries/FreeRTOS/Source/queue.c **** 						}
1409:Libraries/FreeRTOS/Source/queue.c **** 						else
1410:Libraries/FreeRTOS/Source/queue.c **** 						{
1411:Libraries/FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1412:Libraries/FreeRTOS/Source/queue.c **** 						}
1413:Libraries/FreeRTOS/Source/queue.c **** 					}
1414:Libraries/FreeRTOS/Source/queue.c **** 					else
1415:Libraries/FreeRTOS/Source/queue.c **** 					{
1416:Libraries/FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1417:Libraries/FreeRTOS/Source/queue.c **** 					}
1418:Libraries/FreeRTOS/Source/queue.c **** 				}
1419:Libraries/FreeRTOS/Source/queue.c **** 				else
1420:Libraries/FreeRTOS/Source/queue.c **** 				{
1421:Libraries/FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1422:Libraries/FreeRTOS/Source/queue.c **** 				}
1423:Libraries/FreeRTOS/Source/queue.c **** 			}
1424:Libraries/FreeRTOS/Source/queue.c **** 			else
1425:Libraries/FreeRTOS/Source/queue.c **** 			{
1426:Libraries/FreeRTOS/Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1427:Libraries/FreeRTOS/Source/queue.c **** 				knows that data was removed while it was locked. */
1428:Libraries/FreeRTOS/Source/queue.c **** 				++( pxQueue->xRxLock );
1429:Libraries/FreeRTOS/Source/queue.c **** 			}
1430:Libraries/FreeRTOS/Source/queue.c **** 
1431:Libraries/FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
1432:Libraries/FreeRTOS/Source/queue.c **** 		}
1433:Libraries/FreeRTOS/Source/queue.c **** 		else
1434:Libraries/FreeRTOS/Source/queue.c **** 		{
1435:Libraries/FreeRTOS/Source/queue.c **** 			xReturn = pdFAIL;
1436:Libraries/FreeRTOS/Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
1437:Libraries/FreeRTOS/Source/queue.c **** 		}
1438:Libraries/FreeRTOS/Source/queue.c **** 	}
1439:Libraries/FreeRTOS/Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1440:Libraries/FreeRTOS/Source/queue.c **** 
1441:Libraries/FreeRTOS/Source/queue.c **** 	return xReturn;
1442:Libraries/FreeRTOS/Source/queue.c **** }
1443:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1444:Libraries/FreeRTOS/Source/queue.c **** 
1445:Libraries/FreeRTOS/Source/queue.c **** BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
1446:Libraries/FreeRTOS/Source/queue.c **** {
1447:Libraries/FreeRTOS/Source/queue.c **** BaseType_t xReturn;
1448:Libraries/FreeRTOS/Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
1449:Libraries/FreeRTOS/Source/queue.c **** int8_t *pcOriginalReadPosition;
1450:Libraries/FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
1451:Libraries/FreeRTOS/Source/queue.c **** 
1452:Libraries/FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1453:Libraries/FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1454:Libraries/FreeRTOS/Source/queue.c **** 
1455:Libraries/FreeRTOS/Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1456:Libraries/FreeRTOS/Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1457:Libraries/FreeRTOS/Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1458:Libraries/FreeRTOS/Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1459:Libraries/FreeRTOS/Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1460:Libraries/FreeRTOS/Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1461:Libraries/FreeRTOS/Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1462:Libraries/FreeRTOS/Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
1463:Libraries/FreeRTOS/Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1464:Libraries/FreeRTOS/Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1465:Libraries/FreeRTOS/Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1466:Libraries/FreeRTOS/Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1467:Libraries/FreeRTOS/Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1468:Libraries/FreeRTOS/Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1469:Libraries/FreeRTOS/Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1470:Libraries/FreeRTOS/Source/queue.c **** 
1471:Libraries/FreeRTOS/Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1472:Libraries/FreeRTOS/Source/queue.c **** 	{
1473:Libraries/FreeRTOS/Source/queue.c **** 		/* Cannot block in an ISR, so check there is data available. */
1474:Libraries/FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
1475:Libraries/FreeRTOS/Source/queue.c **** 		{
1476:Libraries/FreeRTOS/Source/queue.c **** 			traceQUEUE_PEEK_FROM_ISR( pxQueue );
1477:Libraries/FreeRTOS/Source/queue.c **** 
1478:Libraries/FreeRTOS/Source/queue.c **** 			/* Remember the read position so it can be reset as nothing is
1479:Libraries/FreeRTOS/Source/queue.c **** 			actually being removed from the queue. */
1480:Libraries/FreeRTOS/Source/queue.c **** 			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
1481:Libraries/FreeRTOS/Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
1482:Libraries/FreeRTOS/Source/queue.c **** 			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
1483:Libraries/FreeRTOS/Source/queue.c **** 
1484:Libraries/FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
1485:Libraries/FreeRTOS/Source/queue.c **** 		}
1486:Libraries/FreeRTOS/Source/queue.c **** 		else
1487:Libraries/FreeRTOS/Source/queue.c **** 		{
1488:Libraries/FreeRTOS/Source/queue.c **** 			xReturn = pdFAIL;
1489:Libraries/FreeRTOS/Source/queue.c **** 			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
1490:Libraries/FreeRTOS/Source/queue.c **** 		}
1491:Libraries/FreeRTOS/Source/queue.c **** 	}
1492:Libraries/FreeRTOS/Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1493:Libraries/FreeRTOS/Source/queue.c **** 
1494:Libraries/FreeRTOS/Source/queue.c **** 	return xReturn;
1495:Libraries/FreeRTOS/Source/queue.c **** }
1496:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1497:Libraries/FreeRTOS/Source/queue.c **** 
1498:Libraries/FreeRTOS/Source/queue.c **** UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
1499:Libraries/FreeRTOS/Source/queue.c **** {
1500:Libraries/FreeRTOS/Source/queue.c **** UBaseType_t uxReturn;
1501:Libraries/FreeRTOS/Source/queue.c **** 
1502:Libraries/FreeRTOS/Source/queue.c **** 	configASSERT( xQueue );
1503:Libraries/FreeRTOS/Source/queue.c **** 
1504:Libraries/FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
1505:Libraries/FreeRTOS/Source/queue.c **** 	{
1506:Libraries/FreeRTOS/Source/queue.c **** 		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
1507:Libraries/FreeRTOS/Source/queue.c **** 	}
1508:Libraries/FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
1509:Libraries/FreeRTOS/Source/queue.c **** 
1510:Libraries/FreeRTOS/Source/queue.c **** 	return uxReturn;
1511:Libraries/FreeRTOS/Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
1512:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1513:Libraries/FreeRTOS/Source/queue.c **** 
1514:Libraries/FreeRTOS/Source/queue.c **** UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
1515:Libraries/FreeRTOS/Source/queue.c **** {
1516:Libraries/FreeRTOS/Source/queue.c **** UBaseType_t uxReturn;
1517:Libraries/FreeRTOS/Source/queue.c **** Queue_t *pxQueue;
1518:Libraries/FreeRTOS/Source/queue.c **** 
1519:Libraries/FreeRTOS/Source/queue.c **** 	pxQueue = ( Queue_t * ) xQueue;
1520:Libraries/FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1521:Libraries/FreeRTOS/Source/queue.c **** 
1522:Libraries/FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
1523:Libraries/FreeRTOS/Source/queue.c **** 	{
1524:Libraries/FreeRTOS/Source/queue.c **** 		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
1525:Libraries/FreeRTOS/Source/queue.c **** 	}
1526:Libraries/FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
1527:Libraries/FreeRTOS/Source/queue.c **** 
1528:Libraries/FreeRTOS/Source/queue.c **** 	return uxReturn;
1529:Libraries/FreeRTOS/Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
1530:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1531:Libraries/FreeRTOS/Source/queue.c **** 
1532:Libraries/FreeRTOS/Source/queue.c **** UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
1533:Libraries/FreeRTOS/Source/queue.c **** {
1534:Libraries/FreeRTOS/Source/queue.c **** UBaseType_t uxReturn;
1535:Libraries/FreeRTOS/Source/queue.c **** 
1536:Libraries/FreeRTOS/Source/queue.c **** 	configASSERT( xQueue );
1537:Libraries/FreeRTOS/Source/queue.c **** 
1538:Libraries/FreeRTOS/Source/queue.c **** 	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
1539:Libraries/FreeRTOS/Source/queue.c **** 
1540:Libraries/FreeRTOS/Source/queue.c **** 	return uxReturn;
1541:Libraries/FreeRTOS/Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
1542:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1543:Libraries/FreeRTOS/Source/queue.c **** 
1544:Libraries/FreeRTOS/Source/queue.c **** void vQueueDelete( QueueHandle_t xQueue )
1545:Libraries/FreeRTOS/Source/queue.c **** {
1546:Libraries/FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
1547:Libraries/FreeRTOS/Source/queue.c **** 
1548:Libraries/FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1549:Libraries/FreeRTOS/Source/queue.c **** 
1550:Libraries/FreeRTOS/Source/queue.c **** 	traceQUEUE_DELETE( pxQueue );
1551:Libraries/FreeRTOS/Source/queue.c **** 	#if ( configQUEUE_REGISTRY_SIZE > 0 )
1552:Libraries/FreeRTOS/Source/queue.c **** 	{
1553:Libraries/FreeRTOS/Source/queue.c **** 		vQueueUnregisterQueue( pxQueue );
1554:Libraries/FreeRTOS/Source/queue.c **** 	}
1555:Libraries/FreeRTOS/Source/queue.c **** 	#endif
1556:Libraries/FreeRTOS/Source/queue.c **** 	if( pxQueue->pcHead != NULL )
1557:Libraries/FreeRTOS/Source/queue.c **** 	{
1558:Libraries/FreeRTOS/Source/queue.c **** 		vPortFree( pxQueue->pcHead );
1559:Libraries/FreeRTOS/Source/queue.c **** 	}
1560:Libraries/FreeRTOS/Source/queue.c **** 	vPortFree( pxQueue );
1561:Libraries/FreeRTOS/Source/queue.c **** }
1562:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1563:Libraries/FreeRTOS/Source/queue.c **** 
1564:Libraries/FreeRTOS/Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1565:Libraries/FreeRTOS/Source/queue.c **** 
1566:Libraries/FreeRTOS/Source/queue.c **** 	UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
1567:Libraries/FreeRTOS/Source/queue.c **** 	{
1568:Libraries/FreeRTOS/Source/queue.c **** 		return ( ( Queue_t * ) xQueue )->uxQueueNumber;
1569:Libraries/FreeRTOS/Source/queue.c **** 	}
1570:Libraries/FreeRTOS/Source/queue.c **** 
1571:Libraries/FreeRTOS/Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
1572:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1573:Libraries/FreeRTOS/Source/queue.c **** 
1574:Libraries/FreeRTOS/Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1575:Libraries/FreeRTOS/Source/queue.c **** 
1576:Libraries/FreeRTOS/Source/queue.c **** 	void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )
1577:Libraries/FreeRTOS/Source/queue.c **** 	{
1578:Libraries/FreeRTOS/Source/queue.c **** 		( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
1579:Libraries/FreeRTOS/Source/queue.c **** 	}
1580:Libraries/FreeRTOS/Source/queue.c **** 
1581:Libraries/FreeRTOS/Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
1582:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1583:Libraries/FreeRTOS/Source/queue.c **** 
1584:Libraries/FreeRTOS/Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1585:Libraries/FreeRTOS/Source/queue.c **** 
1586:Libraries/FreeRTOS/Source/queue.c **** 	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
1587:Libraries/FreeRTOS/Source/queue.c **** 	{
1588:Libraries/FreeRTOS/Source/queue.c **** 		return ( ( Queue_t * ) xQueue )->ucQueueType;
1589:Libraries/FreeRTOS/Source/queue.c **** 	}
1590:Libraries/FreeRTOS/Source/queue.c **** 
1591:Libraries/FreeRTOS/Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
1592:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1593:Libraries/FreeRTOS/Source/queue.c **** 
1594:Libraries/FreeRTOS/Source/queue.c **** static void prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_
1595:Libraries/FreeRTOS/Source/queue.c **** {
1596:Libraries/FreeRTOS/Source/queue.c **** 	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
1597:Libraries/FreeRTOS/Source/queue.c **** 	{
1598:Libraries/FreeRTOS/Source/queue.c **** 		#if ( configUSE_MUTEXES == 1 )
1599:Libraries/FreeRTOS/Source/queue.c **** 		{
1600:Libraries/FreeRTOS/Source/queue.c **** 			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1601:Libraries/FreeRTOS/Source/queue.c **** 			{
1602:Libraries/FreeRTOS/Source/queue.c **** 				/* The mutex is no longer being held. */
1603:Libraries/FreeRTOS/Source/queue.c **** 				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
1604:Libraries/FreeRTOS/Source/queue.c **** 				pxQueue->pxMutexHolder = NULL;
1605:Libraries/FreeRTOS/Source/queue.c **** 			}
1606:Libraries/FreeRTOS/Source/queue.c **** 			else
1607:Libraries/FreeRTOS/Source/queue.c **** 			{
1608:Libraries/FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1609:Libraries/FreeRTOS/Source/queue.c **** 			}
1610:Libraries/FreeRTOS/Source/queue.c **** 		}
1611:Libraries/FreeRTOS/Source/queue.c **** 		#endif /* configUSE_MUTEXES */
1612:Libraries/FreeRTOS/Source/queue.c **** 	}
1613:Libraries/FreeRTOS/Source/queue.c **** 	else if( xPosition == queueSEND_TO_BACK )
1614:Libraries/FreeRTOS/Source/queue.c **** 	{
1615:Libraries/FreeRTOS/Source/queue.c **** 		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); 
1616:Libraries/FreeRTOS/Source/queue.c **** 		pxQueue->pcWriteTo += pxQueue->uxItemSize;
1617:Libraries/FreeRTOS/Source/queue.c **** 		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison 
1618:Libraries/FreeRTOS/Source/queue.c **** 		{
1619:Libraries/FreeRTOS/Source/queue.c **** 			pxQueue->pcWriteTo = pxQueue->pcHead;
1620:Libraries/FreeRTOS/Source/queue.c **** 		}
1621:Libraries/FreeRTOS/Source/queue.c **** 		else
1622:Libraries/FreeRTOS/Source/queue.c **** 		{
1623:Libraries/FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
1624:Libraries/FreeRTOS/Source/queue.c **** 		}
1625:Libraries/FreeRTOS/Source/queue.c **** 	}
1626:Libraries/FreeRTOS/Source/queue.c **** 	else
1627:Libraries/FreeRTOS/Source/queue.c **** 	{
1628:Libraries/FreeRTOS/Source/queue.c **** 		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize 
1629:Libraries/FreeRTOS/Source/queue.c **** 		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
1630:Libraries/FreeRTOS/Source/queue.c **** 		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as compariso
1631:Libraries/FreeRTOS/Source/queue.c **** 		{
1632:Libraries/FreeRTOS/Source/queue.c **** 			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
1633:Libraries/FreeRTOS/Source/queue.c **** 		}
1634:Libraries/FreeRTOS/Source/queue.c **** 		else
1635:Libraries/FreeRTOS/Source/queue.c **** 		{
1636:Libraries/FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
1637:Libraries/FreeRTOS/Source/queue.c **** 		}
1638:Libraries/FreeRTOS/Source/queue.c **** 
1639:Libraries/FreeRTOS/Source/queue.c **** 		if( xPosition == queueOVERWRITE )
1640:Libraries/FreeRTOS/Source/queue.c **** 		{
1641:Libraries/FreeRTOS/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
1642:Libraries/FreeRTOS/Source/queue.c **** 			{
1643:Libraries/FreeRTOS/Source/queue.c **** 				/* An item is not being added but overwritten, so subtract
1644:Libraries/FreeRTOS/Source/queue.c **** 				one from the recorded number of items in the queue so when
1645:Libraries/FreeRTOS/Source/queue.c **** 				one is added again below the number of recorded items remains
1646:Libraries/FreeRTOS/Source/queue.c **** 				correct. */
1647:Libraries/FreeRTOS/Source/queue.c **** 				--( pxQueue->uxMessagesWaiting );
1648:Libraries/FreeRTOS/Source/queue.c **** 			}
1649:Libraries/FreeRTOS/Source/queue.c **** 			else
1650:Libraries/FreeRTOS/Source/queue.c **** 			{
1651:Libraries/FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1652:Libraries/FreeRTOS/Source/queue.c **** 			}
1653:Libraries/FreeRTOS/Source/queue.c **** 		}
1654:Libraries/FreeRTOS/Source/queue.c **** 		else
1655:Libraries/FreeRTOS/Source/queue.c **** 		{
1656:Libraries/FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
1657:Libraries/FreeRTOS/Source/queue.c **** 		}
1658:Libraries/FreeRTOS/Source/queue.c **** 	}
1659:Libraries/FreeRTOS/Source/queue.c **** 
1660:Libraries/FreeRTOS/Source/queue.c **** 	++( pxQueue->uxMessagesWaiting );
1661:Libraries/FreeRTOS/Source/queue.c **** }
1662:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1663:Libraries/FreeRTOS/Source/queue.c **** 
1664:Libraries/FreeRTOS/Source/queue.c **** static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
1665:Libraries/FreeRTOS/Source/queue.c **** {
  28              		.loc 1 1665 0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 0
  31              		@ frame_needed = 0, uses_anonymous_args = 0
  32              		@ link register save eliminated.
  33              	.LVL0:
  34 0000 30B4     		push	{r4, r5}
  35              	.LCFI0:
  36              		.cfi_def_cfa_offset 8
  37              		.cfi_offset 4, -8
  38              		.cfi_offset 5, -4
1666:Libraries/FreeRTOS/Source/queue.c **** 	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
  39              		.loc 1 1666 0
  40 0002 0568     		ldr	r5, [r0]
1665:Libraries/FreeRTOS/Source/queue.c **** 	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
  41              		.loc 1 1665 0
  42 0004 0346     		mov	r3, r0
  43              		.loc 1 1666 0
  44 0006 65B1     		cbz	r5, .L1
1667:Libraries/FreeRTOS/Source/queue.c **** 	{
1668:Libraries/FreeRTOS/Source/queue.c **** 		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
  45              		.loc 1 1668 0
  46 0008 026C     		ldr	r2, [r0, #64]
  47 000a C468     		ldr	r4, [r0, #12]
1669:Libraries/FreeRTOS/Source/queue.c **** 		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of t
  48              		.loc 1 1669 0
  49 000c 4068     		ldr	r0, [r0, #4]
  50              	.LVL1:
1668:Libraries/FreeRTOS/Source/queue.c **** 		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of t
  51              		.loc 1 1668 0
  52 000e 1444     		add	r4, r4, r2
  53              		.loc 1 1669 0
  54 0010 8442     		cmp	r4, r0
1668:Libraries/FreeRTOS/Source/queue.c **** 		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of t
  55              		.loc 1 1668 0
  56 0012 DC60     		str	r4, [r3, #12]
1670:Libraries/FreeRTOS/Source/queue.c **** 		{
1671:Libraries/FreeRTOS/Source/queue.c **** 			pxQueue->u.pcReadFrom = pxQueue->pcHead;
  57              		.loc 1 1671 0
  58 0014 28BF     		it	cs
  59 0016 DD60     		strcs	r5, [r3, #12]
1672:Libraries/FreeRTOS/Source/queue.c **** 		}
1673:Libraries/FreeRTOS/Source/queue.c **** 		else
1674:Libraries/FreeRTOS/Source/queue.c **** 		{
1675:Libraries/FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
1676:Libraries/FreeRTOS/Source/queue.c **** 		}
1677:Libraries/FreeRTOS/Source/queue.c **** 		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxIte
  60              		.loc 1 1677 0
  61 0018 0846     		mov	r0, r1
1678:Libraries/FreeRTOS/Source/queue.c **** 	}
1679:Libraries/FreeRTOS/Source/queue.c **** 	else
1680:Libraries/FreeRTOS/Source/queue.c **** 	{
1681:Libraries/FreeRTOS/Source/queue.c **** 		mtCOVERAGE_TEST_MARKER();
1682:Libraries/FreeRTOS/Source/queue.c **** 	}
1683:Libraries/FreeRTOS/Source/queue.c **** }
  62              		.loc 1 1683 0
  63 001a 30BC     		pop	{r4, r5}
1677:Libraries/FreeRTOS/Source/queue.c **** 	}
  64              		.loc 1 1677 0
  65 001c D968     		ldr	r1, [r3, #12]
  66              	.LVL2:
  67 001e FFF7FEBF 		b	memcpy
  68              	.LVL3:
  69              	.L1:
  70              		.loc 1 1683 0
  71 0022 30BC     		pop	{r4, r5}
  72 0024 7047     		bx	lr
  73              		.cfi_endproc
  74              	.LFE139:
  76 0026 00BF     		.section	.text.prvUnlockQueue,"ax",%progbits
  77              		.align	2
  78              		.thumb
  79              		.thumb_func
  81              	prvUnlockQueue:
  82              	.LFB140:
1684:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1685:Libraries/FreeRTOS/Source/queue.c **** 
1686:Libraries/FreeRTOS/Source/queue.c **** static void prvUnlockQueue( Queue_t * const pxQueue )
1687:Libraries/FreeRTOS/Source/queue.c **** {
  83              		.loc 1 1687 0
  84              		.cfi_startproc
  85              		@ args = 0, pretend = 0, frame = 0
  86              		@ frame_needed = 0, uses_anonymous_args = 0
  87              	.LVL4:
  88 0000 38B5     		push	{r3, r4, r5, lr}
  89              	.LCFI1:
  90              		.cfi_def_cfa_offset 16
  91              		.cfi_offset 3, -16
  92              		.cfi_offset 4, -12
  93              		.cfi_offset 5, -8
  94              		.cfi_offset 14, -4
  95              		.loc 1 1687 0
  96 0002 0446     		mov	r4, r0
1688:Libraries/FreeRTOS/Source/queue.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
1689:Libraries/FreeRTOS/Source/queue.c **** 
1690:Libraries/FreeRTOS/Source/queue.c **** 	/* The lock counts contains the number of extra data items placed or
1691:Libraries/FreeRTOS/Source/queue.c **** 	removed from the queue while the queue was locked.  When a queue is
1692:Libraries/FreeRTOS/Source/queue.c **** 	locked items can be added or removed, but the event lists cannot be
1693:Libraries/FreeRTOS/Source/queue.c **** 	updated. */
1694:Libraries/FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
  97              		.loc 1 1694 0
  98 0004 FFF7FEFF 		bl	vPortEnterCritical
  99              	.LVL5:
1695:Libraries/FreeRTOS/Source/queue.c **** 	{
1696:Libraries/FreeRTOS/Source/queue.c **** 		/* See if data was added to the queue while it was locked. */
1697:Libraries/FreeRTOS/Source/queue.c **** 		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 100              		.loc 1 1697 0
 101 0008 A36C     		ldr	r3, [r4, #72]
 102 000a 002B     		cmp	r3, #0
 103 000c 14DD     		ble	.L9
1698:Libraries/FreeRTOS/Source/queue.c **** 		{
1699:Libraries/FreeRTOS/Source/queue.c **** 			/* Data was posted while the queue was locked.  Are any tasks
1700:Libraries/FreeRTOS/Source/queue.c **** 			blocked waiting for data to become available? */
1701:Libraries/FreeRTOS/Source/queue.c **** 			#if ( configUSE_QUEUE_SETS == 1 )
1702:Libraries/FreeRTOS/Source/queue.c **** 			{
1703:Libraries/FreeRTOS/Source/queue.c **** 				if( pxQueue->pxQueueSetContainer != NULL )
1704:Libraries/FreeRTOS/Source/queue.c **** 				{
1705:Libraries/FreeRTOS/Source/queue.c **** 					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) == pdTRUE )
1706:Libraries/FreeRTOS/Source/queue.c **** 					{
1707:Libraries/FreeRTOS/Source/queue.c **** 						/* The queue is a member of a queue set, and posting to
1708:Libraries/FreeRTOS/Source/queue.c **** 						the queue set caused a higher priority task to unblock.
1709:Libraries/FreeRTOS/Source/queue.c **** 						A context switch is required. */
1710:Libraries/FreeRTOS/Source/queue.c **** 						vTaskMissedYield();
1711:Libraries/FreeRTOS/Source/queue.c **** 					}
1712:Libraries/FreeRTOS/Source/queue.c **** 					else
1713:Libraries/FreeRTOS/Source/queue.c **** 					{
1714:Libraries/FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1715:Libraries/FreeRTOS/Source/queue.c **** 					}
1716:Libraries/FreeRTOS/Source/queue.c **** 				}
1717:Libraries/FreeRTOS/Source/queue.c **** 				else
1718:Libraries/FreeRTOS/Source/queue.c **** 				{
1719:Libraries/FreeRTOS/Source/queue.c **** 					/* Tasks that are removed from the event list will get added to
1720:Libraries/FreeRTOS/Source/queue.c **** 					the pending ready list as the scheduler is still suspended. */
1721:Libraries/FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1722:Libraries/FreeRTOS/Source/queue.c **** 					{
1723:Libraries/FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1724:Libraries/FreeRTOS/Source/queue.c **** 						{
1725:Libraries/FreeRTOS/Source/queue.c **** 							/* The task waiting has a higher priority so record that a
1726:Libraries/FreeRTOS/Source/queue.c **** 							context	switch is required. */
1727:Libraries/FreeRTOS/Source/queue.c **** 							vTaskMissedYield();
1728:Libraries/FreeRTOS/Source/queue.c **** 						}
1729:Libraries/FreeRTOS/Source/queue.c **** 						else
1730:Libraries/FreeRTOS/Source/queue.c **** 						{
1731:Libraries/FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1732:Libraries/FreeRTOS/Source/queue.c **** 						}
1733:Libraries/FreeRTOS/Source/queue.c **** 					}
1734:Libraries/FreeRTOS/Source/queue.c **** 					else
1735:Libraries/FreeRTOS/Source/queue.c **** 					{
1736:Libraries/FreeRTOS/Source/queue.c **** 						break;
1737:Libraries/FreeRTOS/Source/queue.c **** 					}
1738:Libraries/FreeRTOS/Source/queue.c **** 				}
1739:Libraries/FreeRTOS/Source/queue.c **** 			}
1740:Libraries/FreeRTOS/Source/queue.c **** 			#else /* configUSE_QUEUE_SETS */
1741:Libraries/FreeRTOS/Source/queue.c **** 			{
1742:Libraries/FreeRTOS/Source/queue.c **** 				/* Tasks that are removed from the event list will get added to
1743:Libraries/FreeRTOS/Source/queue.c **** 				the pending ready list as the scheduler is still suspended. */
1744:Libraries/FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 104              		.loc 1 1744 0
 105 000e 636A     		ldr	r3, [r4, #36]
 106 0010 93B1     		cbz	r3, .L9
 107 0012 04F12405 		add	r5, r4, #36
 108 0016 07E0     		b	.L10
 109              	.L11:
1745:Libraries/FreeRTOS/Source/queue.c **** 				{
1746:Libraries/FreeRTOS/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1747:Libraries/FreeRTOS/Source/queue.c **** 					{
1748:Libraries/FreeRTOS/Source/queue.c **** 						/* The task waiting has a higher priority so record that a
1749:Libraries/FreeRTOS/Source/queue.c **** 						context	switch is required. */
1750:Libraries/FreeRTOS/Source/queue.c **** 						vTaskMissedYield();
1751:Libraries/FreeRTOS/Source/queue.c **** 					}
1752:Libraries/FreeRTOS/Source/queue.c **** 					else
1753:Libraries/FreeRTOS/Source/queue.c **** 					{
1754:Libraries/FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1755:Libraries/FreeRTOS/Source/queue.c **** 					}
1756:Libraries/FreeRTOS/Source/queue.c **** 				}
1757:Libraries/FreeRTOS/Source/queue.c **** 				else
1758:Libraries/FreeRTOS/Source/queue.c **** 				{
1759:Libraries/FreeRTOS/Source/queue.c **** 					break;
1760:Libraries/FreeRTOS/Source/queue.c **** 				}
1761:Libraries/FreeRTOS/Source/queue.c **** 			}
1762:Libraries/FreeRTOS/Source/queue.c **** 			#endif /* configUSE_QUEUE_SETS */
1763:Libraries/FreeRTOS/Source/queue.c **** 
1764:Libraries/FreeRTOS/Source/queue.c **** 			--( pxQueue->xTxLock );
 110              		.loc 1 1764 0
 111 0018 A36C     		ldr	r3, [r4, #72]
 112 001a 013B     		subs	r3, r3, #1
 113 001c A364     		str	r3, [r4, #72]
1697:Libraries/FreeRTOS/Source/queue.c **** 		{
 114              		.loc 1 1697 0
 115 001e A36C     		ldr	r3, [r4, #72]
 116 0020 002B     		cmp	r3, #0
 117 0022 09DD     		ble	.L9
1744:Libraries/FreeRTOS/Source/queue.c **** 				{
 118              		.loc 1 1744 0
 119 0024 636A     		ldr	r3, [r4, #36]
 120 0026 3BB1     		cbz	r3, .L9
 121              	.L10:
1746:Libraries/FreeRTOS/Source/queue.c **** 					{
 122              		.loc 1 1746 0
 123 0028 2846     		mov	r0, r5
 124 002a FFF7FEFF 		bl	xTaskRemoveFromEventList
 125              	.LVL6:
 126 002e 0028     		cmp	r0, #0
 127 0030 F2D0     		beq	.L11
1750:Libraries/FreeRTOS/Source/queue.c **** 					}
 128              		.loc 1 1750 0
 129 0032 FFF7FEFF 		bl	vTaskMissedYield
 130              	.LVL7:
 131 0036 EFE7     		b	.L11
 132              	.L9:
1765:Libraries/FreeRTOS/Source/queue.c **** 		}
1766:Libraries/FreeRTOS/Source/queue.c **** 
1767:Libraries/FreeRTOS/Source/queue.c **** 		pxQueue->xTxLock = queueUNLOCKED;
 133              		.loc 1 1767 0
 134 0038 4FF0FF33 		mov	r3, #-1
 135 003c A364     		str	r3, [r4, #72]
1768:Libraries/FreeRTOS/Source/queue.c **** 	}
1769:Libraries/FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 136              		.loc 1 1769 0
 137 003e FFF7FEFF 		bl	vPortExitCritical
 138              	.LVL8:
1770:Libraries/FreeRTOS/Source/queue.c **** 
1771:Libraries/FreeRTOS/Source/queue.c **** 	/* Do the same for the Rx lock. */
1772:Libraries/FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 139              		.loc 1 1772 0
 140 0042 FFF7FEFF 		bl	vPortEnterCritical
 141              	.LVL9:
1773:Libraries/FreeRTOS/Source/queue.c **** 	{
1774:Libraries/FreeRTOS/Source/queue.c **** 		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 142              		.loc 1 1774 0
 143 0046 636C     		ldr	r3, [r4, #68]
 144 0048 002B     		cmp	r3, #0
 145 004a 14DD     		ble	.L8
1775:Libraries/FreeRTOS/Source/queue.c **** 		{
1776:Libraries/FreeRTOS/Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 146              		.loc 1 1776 0
 147 004c 2369     		ldr	r3, [r4, #16]
 148 004e 93B1     		cbz	r3, .L8
 149 0050 04F11005 		add	r5, r4, #16
 150 0054 07E0     		b	.L13
 151              	.L14:
1777:Libraries/FreeRTOS/Source/queue.c **** 			{
1778:Libraries/FreeRTOS/Source/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1779:Libraries/FreeRTOS/Source/queue.c **** 				{
1780:Libraries/FreeRTOS/Source/queue.c **** 					vTaskMissedYield();
1781:Libraries/FreeRTOS/Source/queue.c **** 				}
1782:Libraries/FreeRTOS/Source/queue.c **** 				else
1783:Libraries/FreeRTOS/Source/queue.c **** 				{
1784:Libraries/FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1785:Libraries/FreeRTOS/Source/queue.c **** 				}
1786:Libraries/FreeRTOS/Source/queue.c **** 
1787:Libraries/FreeRTOS/Source/queue.c **** 				--( pxQueue->xRxLock );
 152              		.loc 1 1787 0
 153 0056 636C     		ldr	r3, [r4, #68]
 154 0058 013B     		subs	r3, r3, #1
 155 005a 6364     		str	r3, [r4, #68]
1774:Libraries/FreeRTOS/Source/queue.c **** 		{
 156              		.loc 1 1774 0
 157 005c 636C     		ldr	r3, [r4, #68]
 158 005e 002B     		cmp	r3, #0
 159 0060 09DD     		ble	.L8
1776:Libraries/FreeRTOS/Source/queue.c **** 			{
 160              		.loc 1 1776 0
 161 0062 2369     		ldr	r3, [r4, #16]
 162 0064 3BB1     		cbz	r3, .L8
 163              	.L13:
1778:Libraries/FreeRTOS/Source/queue.c **** 				{
 164              		.loc 1 1778 0
 165 0066 2846     		mov	r0, r5
 166 0068 FFF7FEFF 		bl	xTaskRemoveFromEventList
 167              	.LVL10:
 168 006c 0028     		cmp	r0, #0
 169 006e F2D0     		beq	.L14
1780:Libraries/FreeRTOS/Source/queue.c **** 				}
 170              		.loc 1 1780 0
 171 0070 FFF7FEFF 		bl	vTaskMissedYield
 172              	.LVL11:
 173 0074 EFE7     		b	.L14
 174              	.L8:
1788:Libraries/FreeRTOS/Source/queue.c **** 			}
1789:Libraries/FreeRTOS/Source/queue.c **** 			else
1790:Libraries/FreeRTOS/Source/queue.c **** 			{
1791:Libraries/FreeRTOS/Source/queue.c **** 				break;
1792:Libraries/FreeRTOS/Source/queue.c **** 			}
1793:Libraries/FreeRTOS/Source/queue.c **** 		}
1794:Libraries/FreeRTOS/Source/queue.c **** 
1795:Libraries/FreeRTOS/Source/queue.c **** 		pxQueue->xRxLock = queueUNLOCKED;
 175              		.loc 1 1795 0
 176 0076 4FF0FF33 		mov	r3, #-1
 177 007a 6364     		str	r3, [r4, #68]
1796:Libraries/FreeRTOS/Source/queue.c **** 	}
1797:Libraries/FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
1798:Libraries/FreeRTOS/Source/queue.c **** }
 178              		.loc 1 1798 0
 179 007c BDE83840 		pop	{r3, r4, r5, lr}
 180              	.LVL12:
1797:Libraries/FreeRTOS/Source/queue.c **** }
 181              		.loc 1 1797 0
 182 0080 FFF7FEBF 		b	vPortExitCritical
 183              	.LVL13:
 184              		.cfi_endproc
 185              	.LFE140:
 187              		.section	.text.xQueueGenericReset,"ax",%progbits
 188              		.align	2
 189              		.global	xQueueGenericReset
 190              		.thumb
 191              		.thumb_func
 193              	xQueueGenericReset:
 194              	.LFB123:
 256:Libraries/FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 195              		.loc 1 256 0
 196              		.cfi_startproc
 197              		@ args = 0, pretend = 0, frame = 0
 198              		@ frame_needed = 0, uses_anonymous_args = 0
 199              	.LVL14:
 200 0000 70B5     		push	{r4, r5, r6, lr}
 201              	.LCFI2:
 202              		.cfi_def_cfa_offset 16
 203              		.cfi_offset 4, -16
 204              		.cfi_offset 5, -12
 205              		.cfi_offset 6, -8
 206              		.cfi_offset 14, -4
 259:Libraries/FreeRTOS/Source/queue.c **** 
 207              		.loc 1 259 0
 208 0002 0446     		mov	r4, r0
 256:Libraries/FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 209              		.loc 1 256 0
 210 0004 0D46     		mov	r5, r1
 259:Libraries/FreeRTOS/Source/queue.c **** 
 211              		.loc 1 259 0
 212 0006 88B3     		cbz	r0, .L41
 261:Libraries/FreeRTOS/Source/queue.c **** 	{
 213              		.loc 1 261 0
 214 0008 FFF7FEFF 		bl	vPortEnterCritical
 215              	.LVL15:
 263:Libraries/FreeRTOS/Source/queue.c **** 		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 216              		.loc 1 263 0
 217 000c 206C     		ldr	r0, [r4, #64]
 218 000e E26B     		ldr	r2, [r4, #60]
 219 0010 2368     		ldr	r3, [r4]
 220 0012 02FB00F2 		mul	r2, r2, r0
 266:Libraries/FreeRTOS/Source/queue.c **** 		pxQueue->xRxLock = queueUNLOCKED;
 221              		.loc 1 266 0
 222 0016 101A     		subs	r0, r2, r0
 223 0018 1E18     		adds	r6, r3, r0
 264:Libraries/FreeRTOS/Source/queue.c **** 		pxQueue->pcWriteTo = pxQueue->pcHead;
 224              		.loc 1 264 0
 225 001a 0021     		movs	r1, #0
 263:Libraries/FreeRTOS/Source/queue.c **** 		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 226              		.loc 1 263 0
 227 001c 9818     		adds	r0, r3, r2
 267:Libraries/FreeRTOS/Source/queue.c **** 		pxQueue->xTxLock = queueUNLOCKED;
 228              		.loc 1 267 0
 229 001e 4FF0FF32 		mov	r2, #-1
 264:Libraries/FreeRTOS/Source/queue.c **** 		pxQueue->pcWriteTo = pxQueue->pcHead;
 230              		.loc 1 264 0
 231 0022 A163     		str	r1, [r4, #56]
 266:Libraries/FreeRTOS/Source/queue.c **** 		pxQueue->xRxLock = queueUNLOCKED;
 232              		.loc 1 266 0
 233 0024 E660     		str	r6, [r4, #12]
 267:Libraries/FreeRTOS/Source/queue.c **** 		pxQueue->xTxLock = queueUNLOCKED;
 234              		.loc 1 267 0
 235 0026 6264     		str	r2, [r4, #68]
 263:Libraries/FreeRTOS/Source/queue.c **** 		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 236              		.loc 1 263 0
 237 0028 6060     		str	r0, [r4, #4]
 265:Libraries/FreeRTOS/Source/queue.c **** 		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue-
 238              		.loc 1 265 0
 239 002a A360     		str	r3, [r4, #8]
 268:Libraries/FreeRTOS/Source/queue.c **** 
 240              		.loc 1 268 0
 241 002c A264     		str	r2, [r4, #72]
 270:Libraries/FreeRTOS/Source/queue.c **** 		{
 242              		.loc 1 270 0
 243 002e 8DB9     		cbnz	r5, .L37
 277:Libraries/FreeRTOS/Source/queue.c **** 			{
 244              		.loc 1 277 0
 245 0030 2369     		ldr	r3, [r4, #16]
 246 0032 1BB9     		cbnz	r3, .L42
 247              	.L39:
 300:Libraries/FreeRTOS/Source/queue.c **** 
 248              		.loc 1 300 0
 249 0034 FFF7FEFF 		bl	vPortExitCritical
 250              	.LVL16:
 305:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 251              		.loc 1 305 0
 252 0038 0120     		movs	r0, #1
 253 003a 70BD     		pop	{r4, r5, r6, pc}
 254              	.LVL17:
 255              	.L42:
 279:Libraries/FreeRTOS/Source/queue.c **** 				{
 256              		.loc 1 279 0
 257 003c 04F11000 		add	r0, r4, #16
 258 0040 FFF7FEFF 		bl	xTaskRemoveFromEventList
 259              	.LVL18:
 260 0044 0128     		cmp	r0, #1
 261 0046 F5D1     		bne	.L39
 281:Libraries/FreeRTOS/Source/queue.c **** 				}
 262              		.loc 1 281 0
 263 0048 FFF7FEFF 		bl	vPortYield
 264              	.LVL19:
 300:Libraries/FreeRTOS/Source/queue.c **** 
 265              		.loc 1 300 0
 266 004c FFF7FEFF 		bl	vPortExitCritical
 267              	.LVL20:
 305:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 268              		.loc 1 305 0
 269 0050 0120     		movs	r0, #1
 270 0052 70BD     		pop	{r4, r5, r6, pc}
 271              	.LVL21:
 272              	.L37:
 296:Libraries/FreeRTOS/Source/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 273              		.loc 1 296 0
 274 0054 04F11000 		add	r0, r4, #16
 275 0058 FFF7FEFF 		bl	vListInitialise
 276              	.LVL22:
 297:Libraries/FreeRTOS/Source/queue.c **** 		}
 277              		.loc 1 297 0
 278 005c 04F12400 		add	r0, r4, #36
 279 0060 FFF7FEFF 		bl	vListInitialise
 280              	.LVL23:
 300:Libraries/FreeRTOS/Source/queue.c **** 
 281              		.loc 1 300 0
 282 0064 FFF7FEFF 		bl	vPortExitCritical
 283              	.LVL24:
 305:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 284              		.loc 1 305 0
 285 0068 0120     		movs	r0, #1
 286 006a 70BD     		pop	{r4, r5, r6, pc}
 287              	.LVL25:
 288              	.L41:
 259:Libraries/FreeRTOS/Source/queue.c **** 
 289              		.loc 1 259 0 discriminator 1
 290 006c FFF7FEFF 		bl	ulPortSetInterruptMask
 291              	.LVL26:
 292              	.L36:
 293 0070 FEE7     		b	.L36
 294              		.cfi_endproc
 295              	.LFE123:
 297 0072 00BF     		.section	.text.xQueueGenericCreate,"ax",%progbits
 298              		.align	2
 299              		.global	xQueueGenericCreate
 300              		.thumb
 301              		.thumb_func
 303              	xQueueGenericCreate:
 304              	.LFB124:
 309:Libraries/FreeRTOS/Source/queue.c **** Queue_t *pxNewQueue;
 305              		.loc 1 309 0
 306              		.cfi_startproc
 307              		@ args = 0, pretend = 0, frame = 0
 308              		@ frame_needed = 0, uses_anonymous_args = 0
 309              	.LVL27:
 310 0000 70B5     		push	{r4, r5, r6, lr}
 311              	.LCFI3:
 312              		.cfi_def_cfa_offset 16
 313              		.cfi_offset 4, -16
 314              		.cfi_offset 5, -12
 315              		.cfi_offset 6, -8
 316              		.cfi_offset 14, -4
 319:Libraries/FreeRTOS/Source/queue.c **** 	{
 317              		.loc 1 319 0
 318 0002 0546     		mov	r5, r0
 309:Libraries/FreeRTOS/Source/queue.c **** Queue_t *pxNewQueue;
 319              		.loc 1 309 0
 320 0004 0E46     		mov	r6, r1
 319:Libraries/FreeRTOS/Source/queue.c **** 	{
 321              		.loc 1 319 0
 322 0006 78B3     		cbz	r0, .L46
 321:Libraries/FreeRTOS/Source/queue.c **** 		if( pxNewQueue != NULL )
 323              		.loc 1 321 0
 324 0008 4C20     		movs	r0, #76
 325              	.LVL28:
 326 000a FFF7FEFF 		bl	pvPortMalloc
 327              	.LVL29:
 322:Libraries/FreeRTOS/Source/queue.c **** 		{
 328              		.loc 1 322 0
 329 000e 0446     		mov	r4, r0
 330 0010 50B3     		cbz	r0, .L46
 331              	.LVL30:
 326:Libraries/FreeRTOS/Source/queue.c **** 
 332              		.loc 1 326 0
 333 0012 06FB05F0 		mul	r0, r6, r5
 334              	.LVL31:
 328:Libraries/FreeRTOS/Source/queue.c **** 			if( pxNewQueue->pcHead != NULL )
 335              		.loc 1 328 0
 336 0016 0130     		adds	r0, r0, #1
 337              	.LVL32:
 338 0018 FFF7FEFF 		bl	pvPortMalloc
 339              	.LVL33:
 340 001c 2060     		str	r0, [r4]
 329:Libraries/FreeRTOS/Source/queue.c **** 			{
 341              		.loc 1 329 0
 342 001e 00B3     		cbz	r0, .L57
 333:Libraries/FreeRTOS/Source/queue.c **** 				pxNewQueue->uxItemSize = uxItemSize;
 343              		.loc 1 333 0
 344 0020 E563     		str	r5, [r4, #60]
 334:Libraries/FreeRTOS/Source/queue.c **** 				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 345              		.loc 1 334 0
 346 0022 2664     		str	r6, [r4, #64]
 347              	.LVL34:
 348              	.LBB10:
 349              	.LBB11:
 261:Libraries/FreeRTOS/Source/queue.c **** 	{
 350              		.loc 1 261 0
 351 0024 FFF7FEFF 		bl	vPortEnterCritical
 352              	.LVL35:
 263:Libraries/FreeRTOS/Source/queue.c **** 		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 353              		.loc 1 263 0
 354 0028 216C     		ldr	r1, [r4, #64]
 355 002a E26B     		ldr	r2, [r4, #60]
 356 002c 2368     		ldr	r3, [r4]
 357 002e 02FB01F2 		mul	r2, r2, r1
 266:Libraries/FreeRTOS/Source/queue.c **** 		pxQueue->xRxLock = queueUNLOCKED;
 358              		.loc 1 266 0
 359 0032 511A     		subs	r1, r2, r1
 263:Libraries/FreeRTOS/Source/queue.c **** 		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 360              		.loc 1 263 0
 361 0034 9818     		adds	r0, r3, r2
 266:Libraries/FreeRTOS/Source/queue.c **** 		pxQueue->xRxLock = queueUNLOCKED;
 362              		.loc 1 266 0
 363 0036 5D18     		adds	r5, r3, r1
 364              	.LVL36:
 267:Libraries/FreeRTOS/Source/queue.c **** 		pxQueue->xTxLock = queueUNLOCKED;
 365              		.loc 1 267 0
 366 0038 4FF0FF32 		mov	r2, #-1
 264:Libraries/FreeRTOS/Source/queue.c **** 		pxQueue->pcWriteTo = pxQueue->pcHead;
 367              		.loc 1 264 0
 368 003c 0021     		movs	r1, #0
 369 003e A163     		str	r1, [r4, #56]
 265:Libraries/FreeRTOS/Source/queue.c **** 		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue-
 370              		.loc 1 265 0
 371 0040 A360     		str	r3, [r4, #8]
 267:Libraries/FreeRTOS/Source/queue.c **** 		pxQueue->xTxLock = queueUNLOCKED;
 372              		.loc 1 267 0
 373 0042 6264     		str	r2, [r4, #68]
 263:Libraries/FreeRTOS/Source/queue.c **** 		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 374              		.loc 1 263 0
 375 0044 6060     		str	r0, [r4, #4]
 268:Libraries/FreeRTOS/Source/queue.c **** 
 376              		.loc 1 268 0
 377 0046 A264     		str	r2, [r4, #72]
 296:Libraries/FreeRTOS/Source/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 378              		.loc 1 296 0
 379 0048 04F11000 		add	r0, r4, #16
 266:Libraries/FreeRTOS/Source/queue.c **** 		pxQueue->xRxLock = queueUNLOCKED;
 380              		.loc 1 266 0
 381 004c E560     		str	r5, [r4, #12]
 296:Libraries/FreeRTOS/Source/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 382              		.loc 1 296 0
 383 004e FFF7FEFF 		bl	vListInitialise
 384              	.LVL37:
 297:Libraries/FreeRTOS/Source/queue.c **** 		}
 385              		.loc 1 297 0
 386 0052 04F12400 		add	r0, r4, #36
 387 0056 FFF7FEFF 		bl	vListInitialise
 388              	.LVL38:
 300:Libraries/FreeRTOS/Source/queue.c **** 
 389              		.loc 1 300 0
 390 005a FFF7FEFF 		bl	vPortExitCritical
 391              	.LVL39:
 392              	.LBE11:
 393              	.LBE10:
 371:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 394              		.loc 1 371 0
 395 005e 2046     		mov	r0, r4
 396 0060 70BD     		pop	{r4, r5, r6, pc}
 397              	.LVL40:
 398              	.L57:
 355:Libraries/FreeRTOS/Source/queue.c **** 			}
 399              		.loc 1 355 0
 400 0062 2046     		mov	r0, r4
 401 0064 FFF7FEFF 		bl	vPortFree
 402              	.LVL41:
 403              	.L46:
 368:Libraries/FreeRTOS/Source/queue.c **** 
 404              		.loc 1 368 0
 405 0068 FFF7FEFF 		bl	ulPortSetInterruptMask
 406              	.LVL42:
 407              	.L48:
 408 006c FEE7     		b	.L48
 409              		.cfi_endproc
 410              	.LFE124:
 412 006e 00BF     		.section	.text.xQueueCreateCountingSemaphore,"ax",%progbits
 413              		.align	2
 414              		.global	xQueueCreateCountingSemaphore
 415              		.thumb
 416              		.thumb_func
 418              	xQueueCreateCountingSemaphore:
 419              	.LFB128:
 567:Libraries/FreeRTOS/Source/queue.c **** 	QueueHandle_t xHandle;
 420              		.loc 1 567 0
 421              		.cfi_startproc
 422              		@ args = 0, pretend = 0, frame = 0
 423              		@ frame_needed = 0, uses_anonymous_args = 0
 424              	.LVL43:
 425 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 426              	.LCFI4:
 427              		.cfi_def_cfa_offset 24
 428              		.cfi_offset 3, -24
 429              		.cfi_offset 4, -20
 430              		.cfi_offset 5, -16
 431              		.cfi_offset 6, -12
 432              		.cfi_offset 7, -8
 433              		.cfi_offset 14, -4
 570:Libraries/FreeRTOS/Source/queue.c **** 		configASSERT( uxInitialCount <= uxMaxCount );
 434              		.loc 1 570 0
 435 0002 0546     		mov	r5, r0
 567:Libraries/FreeRTOS/Source/queue.c **** 	QueueHandle_t xHandle;
 436              		.loc 1 567 0
 437 0004 0E46     		mov	r6, r1
 570:Libraries/FreeRTOS/Source/queue.c **** 		configASSERT( uxInitialCount <= uxMaxCount );
 438              		.loc 1 570 0
 439 0006 0028     		cmp	r0, #0
 440 0008 30D0     		beq	.L72
 571:Libraries/FreeRTOS/Source/queue.c **** 
 441              		.loc 1 571 0
 442 000a 8842     		cmp	r0, r1
 443 000c 02D2     		bcs	.L61
 571:Libraries/FreeRTOS/Source/queue.c **** 
 444              		.loc 1 571 0 is_stmt 0 discriminator 1
 445 000e FFF7FEFF 		bl	ulPortSetInterruptMask
 446              	.LVL44:
 447              	.L62:
 448 0012 FEE7     		b	.L62
 449              	.LVL45:
 450              	.L61:
 451              	.LBB16:
 452              	.LBB17:
 321:Libraries/FreeRTOS/Source/queue.c **** 		if( pxNewQueue != NULL )
 453              		.loc 1 321 0 is_stmt 1
 454 0014 4C20     		movs	r0, #76
 455              	.LVL46:
 456 0016 FFF7FEFF 		bl	pvPortMalloc
 457              	.LVL47:
 322:Libraries/FreeRTOS/Source/queue.c **** 		{
 458              		.loc 1 322 0
 459 001a 0446     		mov	r4, r0
 460 001c 60B3     		cbz	r0, .L63
 461              	.LVL48:
 328:Libraries/FreeRTOS/Source/queue.c **** 			if( pxNewQueue->pcHead != NULL )
 462              		.loc 1 328 0
 463 001e 0120     		movs	r0, #1
 464              	.LVL49:
 465 0020 FFF7FEFF 		bl	pvPortMalloc
 466              	.LVL50:
 467 0024 2060     		str	r0, [r4]
 329:Libraries/FreeRTOS/Source/queue.c **** 			{
 468              		.loc 1 329 0
 469 0026 20B3     		cbz	r0, .L73
 334:Libraries/FreeRTOS/Source/queue.c **** 				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 470              		.loc 1 334 0
 471 0028 0027     		movs	r7, #0
 333:Libraries/FreeRTOS/Source/queue.c **** 				pxNewQueue->uxItemSize = uxItemSize;
 472              		.loc 1 333 0
 473 002a E563     		str	r5, [r4, #60]
 334:Libraries/FreeRTOS/Source/queue.c **** 				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 474              		.loc 1 334 0
 475 002c 2764     		str	r7, [r4, #64]
 476              	.LVL51:
 477              	.LBB18:
 478              	.LBB19:
 261:Libraries/FreeRTOS/Source/queue.c **** 	{
 479              		.loc 1 261 0
 480 002e FFF7FEFF 		bl	vPortEnterCritical
 481              	.LVL52:
 263:Libraries/FreeRTOS/Source/queue.c **** 		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 482              		.loc 1 263 0
 483 0032 216C     		ldr	r1, [r4, #64]
 484 0034 E26B     		ldr	r2, [r4, #60]
 485 0036 2368     		ldr	r3, [r4]
 264:Libraries/FreeRTOS/Source/queue.c **** 		pxQueue->pcWriteTo = pxQueue->pcHead;
 486              		.loc 1 264 0
 487 0038 A763     		str	r7, [r4, #56]
 263:Libraries/FreeRTOS/Source/queue.c **** 		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 488              		.loc 1 263 0
 489 003a 02FB01F2 		mul	r2, r2, r1
 266:Libraries/FreeRTOS/Source/queue.c **** 		pxQueue->xRxLock = queueUNLOCKED;
 490              		.loc 1 266 0
 491 003e 511A     		subs	r1, r2, r1
 492 0040 5818     		adds	r0, r3, r1
 263:Libraries/FreeRTOS/Source/queue.c **** 		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 493              		.loc 1 263 0
 494 0042 9918     		adds	r1, r3, r2
 267:Libraries/FreeRTOS/Source/queue.c **** 		pxQueue->xTxLock = queueUNLOCKED;
 495              		.loc 1 267 0
 496 0044 4FF0FF32 		mov	r2, #-1
 497 0048 6264     		str	r2, [r4, #68]
 263:Libraries/FreeRTOS/Source/queue.c **** 		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 498              		.loc 1 263 0
 499 004a 6160     		str	r1, [r4, #4]
 265:Libraries/FreeRTOS/Source/queue.c **** 		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue-
 500              		.loc 1 265 0
 501 004c A360     		str	r3, [r4, #8]
 268:Libraries/FreeRTOS/Source/queue.c **** 
 502              		.loc 1 268 0
 503 004e A264     		str	r2, [r4, #72]
 266:Libraries/FreeRTOS/Source/queue.c **** 		pxQueue->xRxLock = queueUNLOCKED;
 504              		.loc 1 266 0
 505 0050 E060     		str	r0, [r4, #12]
 296:Libraries/FreeRTOS/Source/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 506              		.loc 1 296 0
 507 0052 04F11000 		add	r0, r4, #16
 508 0056 FFF7FEFF 		bl	vListInitialise
 509              	.LVL53:
 297:Libraries/FreeRTOS/Source/queue.c **** 		}
 510              		.loc 1 297 0
 511 005a 04F12400 		add	r0, r4, #36
 512 005e FFF7FEFF 		bl	vListInitialise
 513              	.LVL54:
 300:Libraries/FreeRTOS/Source/queue.c **** 
 514              		.loc 1 300 0
 515 0062 FFF7FEFF 		bl	vPortExitCritical
 516              	.LVL55:
 517              	.LBE19:
 518              	.LBE18:
 519              	.LBE17:
 520              	.LBE16:
 577:Libraries/FreeRTOS/Source/queue.c **** 
 521              		.loc 1 577 0
 522 0066 A663     		str	r6, [r4, #56]
 588:Libraries/FreeRTOS/Source/queue.c **** 
 523              		.loc 1 588 0
 524 0068 2046     		mov	r0, r4
 525 006a F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 526              	.LVL56:
 527              	.L72:
 570:Libraries/FreeRTOS/Source/queue.c **** 		configASSERT( uxInitialCount <= uxMaxCount );
 528              		.loc 1 570 0 discriminator 1
 529 006c FFF7FEFF 		bl	ulPortSetInterruptMask
 530              	.LVL57:
 531              	.L60:
 532 0070 FEE7     		b	.L60
 533              	.LVL58:
 534              	.L73:
 535              	.LBB21:
 536              	.LBB20:
 355:Libraries/FreeRTOS/Source/queue.c **** 			}
 537              		.loc 1 355 0
 538 0072 2046     		mov	r0, r4
 539 0074 FFF7FEFF 		bl	vPortFree
 540              	.LVL59:
 541              	.L63:
 368:Libraries/FreeRTOS/Source/queue.c **** 
 542              		.loc 1 368 0
 543 0078 FFF7FEFF 		bl	ulPortSetInterruptMask
 544              	.LVL60:
 545              	.L66:
 546 007c FEE7     		b	.L66
 547              	.LBE20:
 548              	.LBE21:
 549              		.cfi_endproc
 550              	.LFE128:
 552 007e 00BF     		.section	.text.xQueueGenericSend,"ax",%progbits
 553              		.align	2
 554              		.global	xQueueGenericSend
 555              		.thumb
 556              		.thumb_func
 558              	xQueueGenericSend:
 559              	.LFB129:
 594:Libraries/FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 560              		.loc 1 594 0
 561              		.cfi_startproc
 562              		@ args = 0, pretend = 0, frame = 16
 563              		@ frame_needed = 0, uses_anonymous_args = 0
 564              	.LVL61:
 565 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 566              	.LCFI5:
 567              		.cfi_def_cfa_offset 36
 568              		.cfi_offset 4, -36
 569              		.cfi_offset 5, -32
 570              		.cfi_offset 6, -28
 571              		.cfi_offset 7, -24
 572              		.cfi_offset 8, -20
 573              		.cfi_offset 9, -16
 574              		.cfi_offset 10, -12
 575              		.cfi_offset 11, -8
 576              		.cfi_offset 14, -4
 577 0004 85B0     		sub	sp, sp, #20
 578              	.LCFI6:
 579              		.cfi_def_cfa_offset 56
 599:Libraries/FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 580              		.loc 1 599 0
 581 0006 0446     		mov	r4, r0
 594:Libraries/FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 582              		.loc 1 594 0
 583 0008 8946     		mov	r9, r1
 584 000a 0192     		str	r2, [sp, #4]
 585 000c 1F46     		mov	r7, r3
 599:Libraries/FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 586              		.loc 1 599 0
 587 000e 0028     		cmp	r0, #0
 588 0010 00F0E580 		beq	.L188
 600:Libraries/FreeRTOS/Source/queue.c **** 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 589              		.loc 1 600 0
 590 0014 0029     		cmp	r1, #0
 591 0016 00F02381 		beq	.L189
 592              	.LVL62:
 593              	.L77:
 601:Libraries/FreeRTOS/Source/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
 594              		.loc 1 601 0
 595 001a 022F     		cmp	r7, #2
 596 001c 57D0     		beq	.L190
 597              	.L80:
 604:Libraries/FreeRTOS/Source/queue.c **** 	}
 598              		.loc 1 604 0
 599 001e FFF7FEFF 		bl	xTaskGetSchedulerState
 600              	.LVL63:
 601 0022 18B9     		cbnz	r0, .L129
 604:Libraries/FreeRTOS/Source/queue.c **** 	}
 602              		.loc 1 604 0 is_stmt 0 discriminator 2
 603 0024 019B     		ldr	r3, [sp, #4]
 604 0026 002B     		cmp	r3, #0
 605 0028 40F01781 		bne	.L83
 606              	.L129:
 614:Libraries/FreeRTOS/Source/queue.c **** 		{
 607              		.loc 1 614 0 is_stmt 1
 608 002c FFF7FEFF 		bl	vPortEnterCritical
 609              	.LVL64:
 620:Libraries/FreeRTOS/Source/queue.c **** 			{
 610              		.loc 1 620 0
 611 0030 A26B     		ldr	r2, [r4, #56]
 612 0032 E36B     		ldr	r3, [r4, #60]
 594:Libraries/FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 613              		.loc 1 594 0
 614 0034 4FF0000B 		mov	fp, #0
 620:Libraries/FreeRTOS/Source/queue.c **** 			{
 615              		.loc 1 620 0
 616 0038 9A42     		cmp	r2, r3
 731:Libraries/FreeRTOS/Source/queue.c **** 
 617              		.loc 1 731 0
 618 003a DA46     		mov	r10, fp
 739:Libraries/FreeRTOS/Source/queue.c **** 
 619              		.loc 1 739 0
 620 003c 04F11005 		add	r5, r4, #16
 621 0040 04F12406 		add	r6, r4, #36
 622              	.LBB30:
 623              	.LBB31:
1767:Libraries/FreeRTOS/Source/queue.c **** 	}
 624              		.loc 1 1767 0
 625 0044 4FF0FF38 		mov	r8, #-1
 626              	.LVL65:
 627              	.LBE31:
 628              	.LBE30:
 620:Libraries/FreeRTOS/Source/queue.c **** 			{
 629              		.loc 1 620 0
 630 0048 71D3     		bcc	.L86
 631              	.LVL66:
 632              	.L195:
 620:Libraries/FreeRTOS/Source/queue.c **** 			{
 633              		.loc 1 620 0 is_stmt 0 discriminator 1
 634 004a 022F     		cmp	r7, #2
 635 004c 00F0DA80 		beq	.L191
 700:Libraries/FreeRTOS/Source/queue.c **** 				{
 636              		.loc 1 700 0 is_stmt 1
 637 0050 0198     		ldr	r0, [sp, #4]
 638 0052 0028     		cmp	r0, #0
 639 0054 00F0CF80 		beq	.L192
 711:Libraries/FreeRTOS/Source/queue.c **** 				{
 640              		.loc 1 711 0
 641 0058 BBF1000F 		cmp	fp, #0
 642 005c 00F0BB80 		beq	.L193
 643              	.LVL67:
 644              	.L100:
 725:Libraries/FreeRTOS/Source/queue.c **** 
 645              		.loc 1 725 0
 646 0060 FFF7FEFF 		bl	vPortExitCritical
 647              	.LVL68:
 730:Libraries/FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 648              		.loc 1 730 0
 649 0064 FFF7FEFF 		bl	vTaskSuspendAll
 650              	.LVL69:
 731:Libraries/FreeRTOS/Source/queue.c **** 
 651              		.loc 1 731 0
 652 0068 FFF7FEFF 		bl	vPortEnterCritical
 653              	.LVL70:
 654 006c 636C     		ldr	r3, [r4, #68]
 655 006e 0133     		adds	r3, r3, #1
 656 0070 08BF     		it	eq
 657 0072 C4F844A0 		streq	r10, [r4, #68]
 658 0076 A36C     		ldr	r3, [r4, #72]
 659 0078 0133     		adds	r3, r3, #1
 660 007a 08BF     		it	eq
 661 007c C4F848A0 		streq	r10, [r4, #72]
 662 0080 FFF7FEFF 		bl	vPortExitCritical
 663              	.LVL71:
 734:Libraries/FreeRTOS/Source/queue.c **** 		{
 664              		.loc 1 734 0
 665 0084 02A8     		add	r0, sp, #8
 666 0086 01A9     		add	r1, sp, #4
 667              	.LVL72:
 668 0088 FFF7FEFF 		bl	xTaskCheckForTimeOut
 669              	.LVL73:
 670 008c 0028     		cmp	r0, #0
 671 008e 40F0A980 		bne	.L103
 672              	.LVL74:
 673              	.LBB33:
 674              	.LBB34:
1799:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1800:Libraries/FreeRTOS/Source/queue.c **** 
1801:Libraries/FreeRTOS/Source/queue.c **** static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
1802:Libraries/FreeRTOS/Source/queue.c **** {
1803:Libraries/FreeRTOS/Source/queue.c **** BaseType_t xReturn;
1804:Libraries/FreeRTOS/Source/queue.c **** 
1805:Libraries/FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
1806:Libraries/FreeRTOS/Source/queue.c **** 	{
1807:Libraries/FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
1808:Libraries/FreeRTOS/Source/queue.c **** 		{
1809:Libraries/FreeRTOS/Source/queue.c **** 			xReturn = pdTRUE;
1810:Libraries/FreeRTOS/Source/queue.c **** 		}
1811:Libraries/FreeRTOS/Source/queue.c **** 		else
1812:Libraries/FreeRTOS/Source/queue.c **** 		{
1813:Libraries/FreeRTOS/Source/queue.c **** 			xReturn = pdFALSE;
1814:Libraries/FreeRTOS/Source/queue.c **** 		}
1815:Libraries/FreeRTOS/Source/queue.c **** 	}
1816:Libraries/FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
1817:Libraries/FreeRTOS/Source/queue.c **** 
1818:Libraries/FreeRTOS/Source/queue.c **** 	return xReturn;
1819:Libraries/FreeRTOS/Source/queue.c **** }
1820:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1821:Libraries/FreeRTOS/Source/queue.c **** 
1822:Libraries/FreeRTOS/Source/queue.c **** BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
1823:Libraries/FreeRTOS/Source/queue.c **** {
1824:Libraries/FreeRTOS/Source/queue.c **** BaseType_t xReturn;
1825:Libraries/FreeRTOS/Source/queue.c **** 
1826:Libraries/FreeRTOS/Source/queue.c **** 	configASSERT( xQueue );
1827:Libraries/FreeRTOS/Source/queue.c **** 	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
1828:Libraries/FreeRTOS/Source/queue.c **** 	{
1829:Libraries/FreeRTOS/Source/queue.c **** 		xReturn = pdTRUE;
1830:Libraries/FreeRTOS/Source/queue.c **** 	}
1831:Libraries/FreeRTOS/Source/queue.c **** 	else
1832:Libraries/FreeRTOS/Source/queue.c **** 	{
1833:Libraries/FreeRTOS/Source/queue.c **** 		xReturn = pdFALSE;
1834:Libraries/FreeRTOS/Source/queue.c **** 	}
1835:Libraries/FreeRTOS/Source/queue.c **** 
1836:Libraries/FreeRTOS/Source/queue.c **** 	return xReturn;
1837:Libraries/FreeRTOS/Source/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
1838:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1839:Libraries/FreeRTOS/Source/queue.c **** 
1840:Libraries/FreeRTOS/Source/queue.c **** static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
1841:Libraries/FreeRTOS/Source/queue.c **** {
1842:Libraries/FreeRTOS/Source/queue.c **** BaseType_t xReturn;
1843:Libraries/FreeRTOS/Source/queue.c **** 
1844:Libraries/FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 675              		.loc 1 1844 0
 676 0092 FFF7FEFF 		bl	vPortEnterCritical
 677              	.LVL75:
1845:Libraries/FreeRTOS/Source/queue.c **** 	{
1846:Libraries/FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 678              		.loc 1 1846 0
 679 0096 A26B     		ldr	r2, [r4, #56]
 680 0098 E36B     		ldr	r3, [r4, #60]
 681 009a 9A42     		cmp	r2, r3
 682 009c 5AD0     		beq	.L194
 683              	.LVL76:
1847:Libraries/FreeRTOS/Source/queue.c **** 		{
1848:Libraries/FreeRTOS/Source/queue.c **** 			xReturn = pdTRUE;
1849:Libraries/FreeRTOS/Source/queue.c **** 		}
1850:Libraries/FreeRTOS/Source/queue.c **** 		else
1851:Libraries/FreeRTOS/Source/queue.c **** 		{
1852:Libraries/FreeRTOS/Source/queue.c **** 			xReturn = pdFALSE;
1853:Libraries/FreeRTOS/Source/queue.c **** 		}
1854:Libraries/FreeRTOS/Source/queue.c **** 	}
1855:Libraries/FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 684              		.loc 1 1855 0
 685 009e FFF7FEFF 		bl	vPortExitCritical
 686              	.LVL77:
 687              	.LBE34:
 688              	.LBE33:
 689              	.LBB36:
 690              	.LBB37:
1694:Libraries/FreeRTOS/Source/queue.c **** 	{
 691              		.loc 1 1694 0
 692 00a2 FFF7FEFF 		bl	vPortEnterCritical
 693              	.LVL78:
1697:Libraries/FreeRTOS/Source/queue.c **** 		{
 694              		.loc 1 1697 0
 695 00a6 A36C     		ldr	r3, [r4, #72]
 696 00a8 002B     		cmp	r3, #0
 697 00aa 06DC     		bgt	.L121
 698 00ac 15E0     		b	.L122
 699              	.L120:
1764:Libraries/FreeRTOS/Source/queue.c **** 		}
 700              		.loc 1 1764 0
 701 00ae A36C     		ldr	r3, [r4, #72]
 702 00b0 013B     		subs	r3, r3, #1
 703 00b2 A364     		str	r3, [r4, #72]
1697:Libraries/FreeRTOS/Source/queue.c **** 		{
 704              		.loc 1 1697 0
 705 00b4 A36C     		ldr	r3, [r4, #72]
 706 00b6 002B     		cmp	r3, #0
 707 00b8 0FDD     		ble	.L122
 708              	.L121:
1744:Libraries/FreeRTOS/Source/queue.c **** 				{
 709              		.loc 1 1744 0
 710 00ba 636A     		ldr	r3, [r4, #36]
 711 00bc 6BB1     		cbz	r3, .L122
1746:Libraries/FreeRTOS/Source/queue.c **** 					{
 712              		.loc 1 1746 0
 713 00be 3046     		mov	r0, r6
 714 00c0 FFF7FEFF 		bl	xTaskRemoveFromEventList
 715              	.LVL79:
 716 00c4 0028     		cmp	r0, #0
 717 00c6 F2D0     		beq	.L120
1750:Libraries/FreeRTOS/Source/queue.c **** 					}
 718              		.loc 1 1750 0
 719 00c8 FFF7FEFF 		bl	vTaskMissedYield
 720              	.LVL80:
 721 00cc EFE7     		b	.L120
 722              	.LVL81:
 723              	.L190:
 724              	.LBE37:
 725              	.LBE36:
 601:Libraries/FreeRTOS/Source/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
 726              		.loc 1 601 0 discriminator 2
 727 00ce E36B     		ldr	r3, [r4, #60]
 728 00d0 012B     		cmp	r3, #1
 729 00d2 A4D0     		beq	.L80
 601:Libraries/FreeRTOS/Source/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
 730              		.loc 1 601 0 is_stmt 0
 731 00d4 FFF7FEFF 		bl	ulPortSetInterruptMask
 732              	.LVL82:
 733              	.L128:
 734 00d8 FEE7     		b	.L128
 735              	.LVL83:
 736              	.L122:
 737              	.LBB39:
 738              	.LBB38:
1767:Libraries/FreeRTOS/Source/queue.c **** 	}
 739              		.loc 1 1767 0 is_stmt 1
 740 00da C4F84880 		str	r8, [r4, #72]
1769:Libraries/FreeRTOS/Source/queue.c **** 
 741              		.loc 1 1769 0
 742 00de FFF7FEFF 		bl	vPortExitCritical
 743              	.LVL84:
1772:Libraries/FreeRTOS/Source/queue.c **** 	{
 744              		.loc 1 1772 0
 745 00e2 FFF7FEFF 		bl	vPortEnterCritical
 746              	.LVL85:
1774:Libraries/FreeRTOS/Source/queue.c **** 		{
 747              		.loc 1 1774 0
 748 00e6 636C     		ldr	r3, [r4, #68]
 749 00e8 002B     		cmp	r3, #0
 750 00ea 12DD     		ble	.L119
1776:Libraries/FreeRTOS/Source/queue.c **** 			{
 751              		.loc 1 1776 0
 752 00ec 2369     		ldr	r3, [r4, #16]
 753 00ee 43B9     		cbnz	r3, .L123
 754 00f0 0FE0     		b	.L119
 755              	.L124:
1787:Libraries/FreeRTOS/Source/queue.c **** 			}
 756              		.loc 1 1787 0
 757 00f2 636C     		ldr	r3, [r4, #68]
 758 00f4 013B     		subs	r3, r3, #1
 759 00f6 6364     		str	r3, [r4, #68]
1774:Libraries/FreeRTOS/Source/queue.c **** 		{
 760              		.loc 1 1774 0
 761 00f8 636C     		ldr	r3, [r4, #68]
 762 00fa 002B     		cmp	r3, #0
 763 00fc 09DD     		ble	.L119
1776:Libraries/FreeRTOS/Source/queue.c **** 			{
 764              		.loc 1 1776 0
 765 00fe 2269     		ldr	r2, [r4, #16]
 766 0100 3AB1     		cbz	r2, .L119
 767              	.L123:
1778:Libraries/FreeRTOS/Source/queue.c **** 				{
 768              		.loc 1 1778 0
 769 0102 2846     		mov	r0, r5
 770 0104 FFF7FEFF 		bl	xTaskRemoveFromEventList
 771              	.LVL86:
 772 0108 0028     		cmp	r0, #0
 773 010a F2D0     		beq	.L124
1780:Libraries/FreeRTOS/Source/queue.c **** 				}
 774              		.loc 1 1780 0
 775 010c FFF7FEFF 		bl	vTaskMissedYield
 776              	.LVL87:
 777 0110 EFE7     		b	.L124
 778              	.L119:
1795:Libraries/FreeRTOS/Source/queue.c **** 	}
 779              		.loc 1 1795 0
 780 0112 C4F84480 		str	r8, [r4, #68]
1797:Libraries/FreeRTOS/Source/queue.c **** }
 781              		.loc 1 1797 0
 782 0116 FFF7FEFF 		bl	vPortExitCritical
 783              	.LVL88:
 784              	.LBE38:
 785              	.LBE39:
 762:Libraries/FreeRTOS/Source/queue.c **** 			}
 786              		.loc 1 762 0
 787 011a FFF7FEFF 		bl	xTaskResumeAll
 788              	.LVL89:
 789              	.L113:
 614:Libraries/FreeRTOS/Source/queue.c **** 		{
 790              		.loc 1 614 0
 791 011e FFF7FEFF 		bl	vPortEnterCritical
 792              	.LVL90:
 620:Libraries/FreeRTOS/Source/queue.c **** 			{
 793              		.loc 1 620 0
 794 0122 A26B     		ldr	r2, [r4, #56]
 795 0124 E36B     		ldr	r3, [r4, #60]
 796 0126 9A42     		cmp	r2, r3
 797 0128 4FF0010B 		mov	fp, #1
 798              	.LVL91:
 799 012c 8DD2     		bcs	.L195
 800              	.LVL92:
 801              	.L86:
 802              	.LBB40:
 803              	.LBB41:
1596:Libraries/FreeRTOS/Source/queue.c **** 	{
 804              		.loc 1 1596 0
 805 012e 226C     		ldr	r2, [r4, #64]
 806 0130 002A     		cmp	r2, #0
 807 0132 69D0     		beq	.L134
1613:Libraries/FreeRTOS/Source/queue.c **** 	{
 808              		.loc 1 1613 0
 809 0134 002F     		cmp	r7, #0
 810 0136 78D1     		bne	.L92
1615:Libraries/FreeRTOS/Source/queue.c **** 		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 811              		.loc 1 1615 0
 812 0138 4946     		mov	r1, r9
 813 013a A068     		ldr	r0, [r4, #8]
 814 013c FFF7FEFF 		bl	memcpy
 815              	.LVL93:
1616:Libraries/FreeRTOS/Source/queue.c **** 		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison 
 816              		.loc 1 1616 0
 817 0140 A168     		ldr	r1, [r4, #8]
 818 0142 236C     		ldr	r3, [r4, #64]
1617:Libraries/FreeRTOS/Source/queue.c **** 		{
 819              		.loc 1 1617 0
 820 0144 6268     		ldr	r2, [r4, #4]
1616:Libraries/FreeRTOS/Source/queue.c **** 		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison 
 821              		.loc 1 1616 0
 822 0146 0B44     		add	r3, r3, r1
1617:Libraries/FreeRTOS/Source/queue.c **** 		{
 823              		.loc 1 1617 0
 824 0148 9342     		cmp	r3, r2
1616:Libraries/FreeRTOS/Source/queue.c **** 		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison 
 825              		.loc 1 1616 0
 826 014a A360     		str	r3, [r4, #8]
1617:Libraries/FreeRTOS/Source/queue.c **** 		{
 827              		.loc 1 1617 0
 828 014c 62D3     		bcc	.L91
1619:Libraries/FreeRTOS/Source/queue.c **** 		}
 829              		.loc 1 1619 0
 830 014e 2368     		ldr	r3, [r4]
 831 0150 A360     		str	r3, [r4, #8]
 832 0152 5FE0     		b	.L91
 833              	.LVL94:
 834              	.L194:
 835              	.LBE41:
 836              	.LBE40:
 837              	.LBB45:
 838              	.LBB35:
 839              		.loc 1 1855 0
 840 0154 FFF7FEFF 		bl	vPortExitCritical
 841              	.LVL95:
 842              	.LBE35:
 843              	.LBE45:
 739:Libraries/FreeRTOS/Source/queue.c **** 
 844              		.loc 1 739 0
 845 0158 2846     		mov	r0, r5
 846 015a 0199     		ldr	r1, [sp, #4]
 847 015c FFF7FEFF 		bl	vTaskPlaceOnEventList
 848              	.LVL96:
 849              	.LBB46:
 850              	.LBB32:
1694:Libraries/FreeRTOS/Source/queue.c **** 	{
 851              		.loc 1 1694 0
 852 0160 FFF7FEFF 		bl	vPortEnterCritical
 853              	.LVL97:
1697:Libraries/FreeRTOS/Source/queue.c **** 		{
 854              		.loc 1 1697 0
 855 0164 A36C     		ldr	r3, [r4, #72]
 856 0166 002B     		cmp	r3, #0
 857 0168 06DC     		bgt	.L110
 858 016a 0FE0     		b	.L111
 859              	.L109:
1764:Libraries/FreeRTOS/Source/queue.c **** 		}
 860              		.loc 1 1764 0
 861 016c A36C     		ldr	r3, [r4, #72]
 862 016e 013B     		subs	r3, r3, #1
 863 0170 A364     		str	r3, [r4, #72]
1697:Libraries/FreeRTOS/Source/queue.c **** 		{
 864              		.loc 1 1697 0
 865 0172 A36C     		ldr	r3, [r4, #72]
 866 0174 002B     		cmp	r3, #0
 867 0176 09DD     		ble	.L111
 868              	.L110:
1744:Libraries/FreeRTOS/Source/queue.c **** 				{
 869              		.loc 1 1744 0
 870 0178 636A     		ldr	r3, [r4, #36]
 871 017a 3BB1     		cbz	r3, .L111
1746:Libraries/FreeRTOS/Source/queue.c **** 					{
 872              		.loc 1 1746 0
 873 017c 3046     		mov	r0, r6
 874 017e FFF7FEFF 		bl	xTaskRemoveFromEventList
 875              	.LVL98:
 876 0182 0028     		cmp	r0, #0
 877 0184 F2D0     		beq	.L109
1750:Libraries/FreeRTOS/Source/queue.c **** 					}
 878              		.loc 1 1750 0
 879 0186 FFF7FEFF 		bl	vTaskMissedYield
 880              	.LVL99:
 881 018a EFE7     		b	.L109
 882              	.L111:
1767:Libraries/FreeRTOS/Source/queue.c **** 	}
 883              		.loc 1 1767 0
 884 018c C4F84880 		str	r8, [r4, #72]
1769:Libraries/FreeRTOS/Source/queue.c **** 
 885              		.loc 1 1769 0
 886 0190 FFF7FEFF 		bl	vPortExitCritical
 887              	.LVL100:
1772:Libraries/FreeRTOS/Source/queue.c **** 	{
 888              		.loc 1 1772 0
 889 0194 FFF7FEFF 		bl	vPortEnterCritical
 890              	.LVL101:
1774:Libraries/FreeRTOS/Source/queue.c **** 		{
 891              		.loc 1 1774 0
 892 0198 636C     		ldr	r3, [r4, #68]
 893 019a 002B     		cmp	r3, #0
 894 019c 06DC     		bgt	.L116
 895 019e 0FE0     		b	.L108
 896              	.L115:
1787:Libraries/FreeRTOS/Source/queue.c **** 			}
 897              		.loc 1 1787 0
 898 01a0 636C     		ldr	r3, [r4, #68]
 899 01a2 013B     		subs	r3, r3, #1
 900 01a4 6364     		str	r3, [r4, #68]
1774:Libraries/FreeRTOS/Source/queue.c **** 		{
 901              		.loc 1 1774 0
 902 01a6 636C     		ldr	r3, [r4, #68]
 903 01a8 002B     		cmp	r3, #0
 904 01aa 09DD     		ble	.L108
 905              	.L116:
1776:Libraries/FreeRTOS/Source/queue.c **** 			{
 906              		.loc 1 1776 0
 907 01ac 2369     		ldr	r3, [r4, #16]
 908 01ae 3BB1     		cbz	r3, .L108
1778:Libraries/FreeRTOS/Source/queue.c **** 				{
 909              		.loc 1 1778 0
 910 01b0 2846     		mov	r0, r5
 911 01b2 FFF7FEFF 		bl	xTaskRemoveFromEventList
 912              	.LVL102:
 913 01b6 0028     		cmp	r0, #0
 914 01b8 F2D0     		beq	.L115
1780:Libraries/FreeRTOS/Source/queue.c **** 				}
 915              		.loc 1 1780 0
 916 01ba FFF7FEFF 		bl	vTaskMissedYield
 917              	.LVL103:
 918 01be EFE7     		b	.L115
 919              	.L108:
1795:Libraries/FreeRTOS/Source/queue.c **** 	}
 920              		.loc 1 1795 0
 921 01c0 C4F84480 		str	r8, [r4, #68]
1797:Libraries/FreeRTOS/Source/queue.c **** }
 922              		.loc 1 1797 0
 923 01c4 FFF7FEFF 		bl	vPortExitCritical
 924              	.LVL104:
 925              	.LBE32:
 926              	.LBE46:
 753:Libraries/FreeRTOS/Source/queue.c **** 				{
 927              		.loc 1 753 0
 928 01c8 FFF7FEFF 		bl	xTaskResumeAll
 929              	.LVL105:
 930 01cc 0028     		cmp	r0, #0
 931 01ce A6D1     		bne	.L113
 755:Libraries/FreeRTOS/Source/queue.c **** 				}
 932              		.loc 1 755 0
 933 01d0 FFF7FEFF 		bl	vPortYield
 934              	.LVL106:
 935 01d4 A3E7     		b	.L113
 936              	.LVL107:
 937              	.L193:
 715:Libraries/FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 938              		.loc 1 715 0
 939 01d6 02A8     		add	r0, sp, #8
 940 01d8 FFF7FEFF 		bl	vTaskSetTimeOutState
 941              	.LVL108:
 942 01dc 40E7     		b	.L100
 943              	.LVL109:
 944              	.L188:
 599:Libraries/FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 945              		.loc 1 599 0 discriminator 1
 946 01de FFF7FEFF 		bl	ulPortSetInterruptMask
 947              	.LVL110:
 948              	.L76:
 949 01e2 FEE7     		b	.L76
 950              	.LVL111:
 951              	.L103:
 768:Libraries/FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
 952              		.loc 1 768 0
 953 01e4 2046     		mov	r0, r4
 954 01e6 FFF7FEFF 		bl	prvUnlockQueue
 955              	.LVL112:
 769:Libraries/FreeRTOS/Source/queue.c **** 
 956              		.loc 1 769 0
 957 01ea FFF7FEFF 		bl	xTaskResumeAll
 958              	.LVL113:
 774:Libraries/FreeRTOS/Source/queue.c **** 		}
 959              		.loc 1 774 0
 960 01ee 0020     		movs	r0, #0
 777:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 961              		.loc 1 777 0
 962 01f0 05B0     		add	sp, sp, #20
 963              		@ sp needed
 964 01f2 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 965              	.LVL114:
 966              	.L192:
 704:Libraries/FreeRTOS/Source/queue.c **** 
 967              		.loc 1 704 0
 968 01f6 0090     		str	r0, [sp]
 969 01f8 FFF7FEFF 		bl	vPortExitCritical
 970              	.LVL115:
 709:Libraries/FreeRTOS/Source/queue.c **** 				}
 971              		.loc 1 709 0
 972 01fc 0098     		ldr	r0, [sp]
 777:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 973              		.loc 1 777 0
 974 01fe 05B0     		add	sp, sp, #20
 975              		@ sp needed
 976 0200 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 977              	.LVL116:
 978              	.L191:
 979              	.LBB47:
 980              	.LBB42:
1596:Libraries/FreeRTOS/Source/queue.c **** 	{
 981              		.loc 1 1596 0
 982 0204 226C     		ldr	r2, [r4, #64]
 983 0206 82B9     		cbnz	r2, .L92
 984              	.LVL117:
 985              	.L134:
1600:Libraries/FreeRTOS/Source/queue.c **** 			{
 986              		.loc 1 1600 0
 987 0208 2568     		ldr	r5, [r4]
 988 020a 1DB9     		cbnz	r5, .L91
1603:Libraries/FreeRTOS/Source/queue.c **** 				pxQueue->pxMutexHolder = NULL;
 989              		.loc 1 1603 0
 990 020c 6068     		ldr	r0, [r4, #4]
 991 020e FFF7FEFF 		bl	vTaskPriorityDisinherit
 992              	.LVL118:
1604:Libraries/FreeRTOS/Source/queue.c **** 			}
 993              		.loc 1 1604 0
 994 0212 6560     		str	r5, [r4, #4]
 995              	.L91:
1660:Libraries/FreeRTOS/Source/queue.c **** }
 996              		.loc 1 1660 0
 997 0214 A26B     		ldr	r2, [r4, #56]
 998              	.LBE42:
 999              	.LBE47:
 670:Libraries/FreeRTOS/Source/queue.c **** 					{
 1000              		.loc 1 670 0
 1001 0216 636A     		ldr	r3, [r4, #36]
 1002              	.LBB48:
 1003              	.LBB43:
1660:Libraries/FreeRTOS/Source/queue.c **** }
 1004              		.loc 1 1660 0
 1005 0218 0132     		adds	r2, r2, #1
 1006 021a A263     		str	r2, [r4, #56]
 1007              	.LBE43:
 1008              	.LBE48:
 670:Libraries/FreeRTOS/Source/queue.c **** 					{
 1009              		.loc 1 670 0
 1010 021c 3BBB     		cbnz	r3, .L196
 1011              	.L96:
 692:Libraries/FreeRTOS/Source/queue.c **** 
 1012              		.loc 1 692 0
 1013 021e FFF7FEFF 		bl	vPortExitCritical
 1014              	.LVL119:
 696:Libraries/FreeRTOS/Source/queue.c **** 			}
 1015              		.loc 1 696 0
 1016 0222 0120     		movs	r0, #1
 777:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 1017              		.loc 1 777 0
 1018 0224 05B0     		add	sp, sp, #20
 1019              		@ sp needed
 1020 0226 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1021              	.LVL120:
 1022              	.L92:
 1023              	.LBB49:
 1024              	.LBB44:
1628:Libraries/FreeRTOS/Source/queue.c **** 		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 1025              		.loc 1 1628 0
 1026 022a 4946     		mov	r1, r9
 1027 022c E068     		ldr	r0, [r4, #12]
 1028 022e FFF7FEFF 		bl	memcpy
 1029              	.LVL121:
1629:Libraries/FreeRTOS/Source/queue.c **** 		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as compariso
 1030              		.loc 1 1629 0
 1031 0232 236C     		ldr	r3, [r4, #64]
 1032 0234 E268     		ldr	r2, [r4, #12]
1630:Libraries/FreeRTOS/Source/queue.c **** 		{
 1033              		.loc 1 1630 0
 1034 0236 2168     		ldr	r1, [r4]
1629:Libraries/FreeRTOS/Source/queue.c **** 		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as compariso
 1035              		.loc 1 1629 0
 1036 0238 5B42     		negs	r3, r3
 1037 023a 1A44     		add	r2, r2, r3
1630:Libraries/FreeRTOS/Source/queue.c **** 		{
 1038              		.loc 1 1630 0
 1039 023c 8A42     		cmp	r2, r1
1629:Libraries/FreeRTOS/Source/queue.c **** 		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as compariso
 1040              		.loc 1 1629 0
 1041 023e E260     		str	r2, [r4, #12]
1632:Libraries/FreeRTOS/Source/queue.c **** 		}
 1042              		.loc 1 1632 0
 1043 0240 3EBF     		ittt	cc
 1044 0242 6268     		ldrcc	r2, [r4, #4]
 1045 0244 9B18     		addcc	r3, r3, r2
 1046 0246 E360     		strcc	r3, [r4, #12]
1639:Libraries/FreeRTOS/Source/queue.c **** 		{
 1047              		.loc 1 1639 0
 1048 0248 022F     		cmp	r7, #2
 1049 024a E3D1     		bne	.L91
1641:Libraries/FreeRTOS/Source/queue.c **** 			{
 1050              		.loc 1 1641 0
 1051 024c A36B     		ldr	r3, [r4, #56]
 1052 024e 002B     		cmp	r3, #0
 1053 0250 E0D0     		beq	.L91
1647:Libraries/FreeRTOS/Source/queue.c **** 			}
 1054              		.loc 1 1647 0
 1055 0252 A36B     		ldr	r3, [r4, #56]
 1056 0254 013B     		subs	r3, r3, #1
 1057 0256 A363     		str	r3, [r4, #56]
 1058 0258 DCE7     		b	.L91
 1059              	.LVL122:
 1060              	.L83:
 1061              	.LBE44:
 1062              	.LBE49:
 604:Libraries/FreeRTOS/Source/queue.c **** 	}
 1063              		.loc 1 604 0
 1064 025a FFF7FEFF 		bl	ulPortSetInterruptMask
 1065              	.LVL123:
 1066              	.L131:
 1067 025e FEE7     		b	.L131
 1068              	.LVL124:
 1069              	.L189:
 600:Libraries/FreeRTOS/Source/queue.c **** 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 1070              		.loc 1 600 0 discriminator 2
 1071 0260 036C     		ldr	r3, [r0, #64]
 1072              	.LVL125:
 1073 0262 002B     		cmp	r3, #0
 1074 0264 3FF4D9AE 		beq	.L77
 600:Libraries/FreeRTOS/Source/queue.c **** 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 1075              		.loc 1 600 0 is_stmt 0
 1076 0268 FFF7FEFF 		bl	ulPortSetInterruptMask
 1077              	.LVL126:
 1078              	.L126:
 1079 026c FEE7     		b	.L126
 1080              	.LVL127:
 1081              	.L196:
 672:Libraries/FreeRTOS/Source/queue.c **** 						{
 1082              		.loc 1 672 0 is_stmt 1
 1083 026e 04F12400 		add	r0, r4, #36
 1084 0272 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1085              	.LVL128:
 1086 0276 0128     		cmp	r0, #1
 1087 0278 D1D1     		bne	.L96
 678:Libraries/FreeRTOS/Source/queue.c **** 						}
 1088              		.loc 1 678 0
 1089 027a FFF7FEFF 		bl	vPortYield
 1090              	.LVL129:
 1091 027e CEE7     		b	.L96
 1092              		.cfi_endproc
 1093              	.LFE129:
 1095              		.section	.text.xQueueCreateMutex,"ax",%progbits
 1096              		.align	2
 1097              		.global	xQueueCreateMutex
 1098              		.thumb
 1099              		.thumb_func
 1101              	xQueueCreateMutex:
 1102              	.LFB125:
 377:Libraries/FreeRTOS/Source/queue.c **** 	Queue_t *pxNewQueue;
 1103              		.loc 1 377 0
 1104              		.cfi_startproc
 1105              		@ args = 0, pretend = 0, frame = 0
 1106              		@ frame_needed = 0, uses_anonymous_args = 0
 1107              	.LVL130:
 1108 0000 38B5     		push	{r3, r4, r5, lr}
 1109              	.LCFI7:
 1110              		.cfi_def_cfa_offset 16
 1111              		.cfi_offset 3, -16
 1112              		.cfi_offset 4, -12
 1113              		.cfi_offset 5, -8
 1114              		.cfi_offset 14, -4
 385:Libraries/FreeRTOS/Source/queue.c **** 		if( pxNewQueue != NULL )
 1115              		.loc 1 385 0
 1116 0002 4C20     		movs	r0, #76
 1117              	.LVL131:
 1118 0004 FFF7FEFF 		bl	pvPortMalloc
 1119              	.LVL132:
 386:Libraries/FreeRTOS/Source/queue.c **** 		{
 1120              		.loc 1 386 0
 1121 0008 0446     		mov	r4, r0
 1122 000a D8B1     		cbz	r0, .L198
 389:Libraries/FreeRTOS/Source/queue.c **** 			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 1123              		.loc 1 389 0
 1124 000c 0025     		movs	r5, #0
 403:Libraries/FreeRTOS/Source/queue.c **** 			pxNewQueue->xTxLock = queueUNLOCKED;
 1125              		.loc 1 403 0
 1126 000e 4FF0FF33 		mov	r3, #-1
 401:Libraries/FreeRTOS/Source/queue.c **** 			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
 1127              		.loc 1 401 0
 1128 0012 0122     		movs	r2, #1
 400:Libraries/FreeRTOS/Source/queue.c **** 			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
 1129              		.loc 1 400 0
 1130 0014 8563     		str	r5, [r0, #56]
 401:Libraries/FreeRTOS/Source/queue.c **** 			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
 1131              		.loc 1 401 0
 1132 0016 C263     		str	r2, [r0, #60]
 403:Libraries/FreeRTOS/Source/queue.c **** 			pxNewQueue->xTxLock = queueUNLOCKED;
 1133              		.loc 1 403 0
 1134 0018 4364     		str	r3, [r0, #68]
 389:Libraries/FreeRTOS/Source/queue.c **** 			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 1135              		.loc 1 389 0
 1136 001a 4560     		str	r5, [r0, #4]
 404:Libraries/FreeRTOS/Source/queue.c **** 
 1137              		.loc 1 404 0
 1138 001c 8364     		str	r3, [r0, #72]
 390:Libraries/FreeRTOS/Source/queue.c **** 
 1139              		.loc 1 390 0
 1140 001e 0560     		str	r5, [r0]
 394:Libraries/FreeRTOS/Source/queue.c **** 			pxNewQueue->u.pcReadFrom = NULL;
 1141              		.loc 1 394 0
 1142 0020 8560     		str	r5, [r0, #8]
 395:Libraries/FreeRTOS/Source/queue.c **** 
 1143              		.loc 1 395 0
 1144 0022 C560     		str	r5, [r0, #12]
 402:Libraries/FreeRTOS/Source/queue.c **** 			pxNewQueue->xRxLock = queueUNLOCKED;
 1145              		.loc 1 402 0
 1146 0024 0564     		str	r5, [r0, #64]
 419:Libraries/FreeRTOS/Source/queue.c **** 			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 1147              		.loc 1 419 0
 1148 0026 1030     		adds	r0, r0, #16
 1149              	.LVL133:
 1150 0028 FFF7FEFF 		bl	vListInitialise
 1151              	.LVL134:
 420:Libraries/FreeRTOS/Source/queue.c **** 
 1152              		.loc 1 420 0
 1153 002c 04F12400 		add	r0, r4, #36
 1154 0030 FFF7FEFF 		bl	vListInitialise
 1155              	.LVL135:
 425:Libraries/FreeRTOS/Source/queue.c **** 		}
 1156              		.loc 1 425 0
 1157 0034 2046     		mov	r0, r4
 1158 0036 2946     		mov	r1, r5
 1159 0038 2A46     		mov	r2, r5
 1160 003a 2B46     		mov	r3, r5
 1161 003c FFF7FEFF 		bl	xQueueGenericSend
 1162              	.LVL136:
 434:Libraries/FreeRTOS/Source/queue.c **** 
 1163              		.loc 1 434 0
 1164 0040 2046     		mov	r0, r4
 1165 0042 38BD     		pop	{r3, r4, r5, pc}
 1166              	.LVL137:
 1167              	.L198:
 432:Libraries/FreeRTOS/Source/queue.c **** 		return pxNewQueue;
 1168              		.loc 1 432 0
 1169 0044 FFF7FEFF 		bl	ulPortSetInterruptMask
 1170              	.LVL138:
 1171              	.L200:
 1172 0048 FEE7     		b	.L200
 1173              		.cfi_endproc
 1174              	.LFE125:
 1176 004a 00BF     		.section	.text.xQueueGiveMutexRecursive,"ax",%progbits
 1177              		.align	2
 1178              		.global	xQueueGiveMutexRecursive
 1179              		.thumb
 1180              		.thumb_func
 1182              	xQueueGiveMutexRecursive:
 1183              	.LFB126:
 472:Libraries/FreeRTOS/Source/queue.c **** 	BaseType_t xReturn;
 1184              		.loc 1 472 0
 1185              		.cfi_startproc
 1186              		@ args = 0, pretend = 0, frame = 0
 1187              		@ frame_needed = 0, uses_anonymous_args = 0
 1188              	.LVL139:
 1189 0000 38B5     		push	{r3, r4, r5, lr}
 1190              	.LCFI8:
 1191              		.cfi_def_cfa_offset 16
 1192              		.cfi_offset 3, -16
 1193              		.cfi_offset 4, -12
 1194              		.cfi_offset 5, -8
 1195              		.cfi_offset 14, -4
 476:Libraries/FreeRTOS/Source/queue.c **** 
 1196              		.loc 1 476 0
 1197 0002 0446     		mov	r4, r0
 1198 0004 30B1     		cbz	r0, .L209
 484:Libraries/FreeRTOS/Source/queue.c **** 		{
 1199              		.loc 1 484 0
 1200 0006 4568     		ldr	r5, [r0, #4]
 1201 0008 FFF7FEFF 		bl	xTaskGetCurrentTaskHandle
 1202              	.LVL140:
 1203 000c 8542     		cmp	r5, r0
 1204 000e 04D0     		beq	.L210
 512:Libraries/FreeRTOS/Source/queue.c **** 
 1205              		.loc 1 512 0
 1206 0010 0020     		movs	r0, #0
 1207 0012 38BD     		pop	{r3, r4, r5, pc}
 1208              	.LVL141:
 1209              	.L209:
 476:Libraries/FreeRTOS/Source/queue.c **** 
 1210              		.loc 1 476 0 discriminator 1
 1211 0014 FFF7FEFF 		bl	ulPortSetInterruptMask
 1212              	.LVL142:
 1213              	.L205:
 1214 0018 FEE7     		b	.L205
 1215              	.L210:
 493:Libraries/FreeRTOS/Source/queue.c **** 
 1216              		.loc 1 493 0
 1217 001a E168     		ldr	r1, [r4, #12]
 1218 001c 0139     		subs	r1, r1, #1
 1219 001e E160     		str	r1, [r4, #12]
 496:Libraries/FreeRTOS/Source/queue.c **** 			{
 1220              		.loc 1 496 0
 1221 0020 09B1     		cbz	r1, .L211
 507:Libraries/FreeRTOS/Source/queue.c **** 		}
 1222              		.loc 1 507 0
 1223 0022 0120     		movs	r0, #1
 1224              	.LVL143:
 518:Libraries/FreeRTOS/Source/queue.c **** 
 1225              		.loc 1 518 0
 1226 0024 38BD     		pop	{r3, r4, r5, pc}
 1227              	.LVL144:
 1228              	.L211:
 500:Libraries/FreeRTOS/Source/queue.c **** 			}
 1229              		.loc 1 500 0
 1230 0026 2046     		mov	r0, r4
 1231 0028 0A46     		mov	r2, r1
 1232 002a 0B46     		mov	r3, r1
 1233 002c FFF7FEFF 		bl	xQueueGenericSend
 1234              	.LVL145:
 507:Libraries/FreeRTOS/Source/queue.c **** 		}
 1235              		.loc 1 507 0
 1236 0030 0120     		movs	r0, #1
 1237 0032 38BD     		pop	{r3, r4, r5, pc}
 1238              		.cfi_endproc
 1239              	.LFE126:
 1241              		.section	.text.xQueueGenericSendFromISR,"ax",%progbits
 1242              		.align	2
 1243              		.global	xQueueGenericSendFromISR
 1244              		.thumb
 1245              		.thumb_func
 1247              	xQueueGenericSendFromISR:
 1248              	.LFB130:
1026:Libraries/FreeRTOS/Source/queue.c **** BaseType_t xReturn;
 1249              		.loc 1 1026 0
 1250              		.cfi_startproc
 1251              		@ args = 0, pretend = 0, frame = 0
 1252              		@ frame_needed = 0, uses_anonymous_args = 0
 1253              	.LVL146:
 1254 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 1255              	.LCFI9:
 1256              		.cfi_def_cfa_offset 24
 1257              		.cfi_offset 4, -24
 1258              		.cfi_offset 5, -20
 1259              		.cfi_offset 6, -16
 1260              		.cfi_offset 7, -12
 1261              		.cfi_offset 8, -8
 1262              		.cfi_offset 14, -4
1031:Libraries/FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 1263              		.loc 1 1031 0
 1264 0004 0446     		mov	r4, r0
1026:Libraries/FreeRTOS/Source/queue.c **** BaseType_t xReturn;
 1265              		.loc 1 1026 0
 1266 0006 0E46     		mov	r6, r1
 1267 0008 9046     		mov	r8, r2
 1268 000a 1D46     		mov	r5, r3
1031:Libraries/FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 1269              		.loc 1 1031 0
 1270 000c 0028     		cmp	r0, #0
 1271 000e 2FD0     		beq	.L254
1032:Libraries/FreeRTOS/Source/queue.c **** 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 1272              		.loc 1 1032 0
 1273 0010 0029     		cmp	r1, #0
 1274 0012 6FD0     		beq	.L255
 1275              	.LVL147:
 1276              	.L215:
1033:Libraries/FreeRTOS/Source/queue.c **** 
 1277              		.loc 1 1033 0
 1278 0014 022D     		cmp	r5, #2
 1279 0016 10D0     		beq	.L256
1049:Libraries/FreeRTOS/Source/queue.c **** 
 1280              		.loc 1 1049 0
 1281 0018 FFF7FEFF 		bl	vPortValidateInterruptPriority
 1282              	.LVL148:
1056:Libraries/FreeRTOS/Source/queue.c **** 	{
 1283              		.loc 1 1056 0
 1284 001c FFF7FEFF 		bl	ulPortSetInterruptMask
 1285              	.LVL149:
1058:Libraries/FreeRTOS/Source/queue.c **** 		{
 1286              		.loc 1 1058 0
 1287 0020 A26B     		ldr	r2, [r4, #56]
 1288 0022 E36B     		ldr	r3, [r4, #60]
 1289 0024 9342     		cmp	r3, r2
1056:Libraries/FreeRTOS/Source/queue.c **** 	{
 1290              		.loc 1 1056 0
 1291 0026 0746     		mov	r7, r0
 1292              	.LVL150:
1160:Libraries/FreeRTOS/Source/queue.c **** 		}
 1293              		.loc 1 1160 0
 1294 0028 98BF     		it	ls
 1295 002a 0024     		movls	r4, #0
 1296              	.LVL151:
1058:Libraries/FreeRTOS/Source/queue.c **** 		{
 1297              		.loc 1 1058 0
 1298 002c 0BD8     		bhi	.L257
 1299              	.LVL152:
 1300              	.L226:
1163:Libraries/FreeRTOS/Source/queue.c **** 
 1301              		.loc 1 1163 0
 1302 002e 3846     		mov	r0, r7
 1303 0030 FFF7FEFF 		bl	vPortClearInterruptMask
 1304              	.LVL153:
1166:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 1305              		.loc 1 1166 0
 1306 0034 2046     		mov	r0, r4
 1307 0036 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1308              	.LVL154:
 1309              	.L256:
1033:Libraries/FreeRTOS/Source/queue.c **** 
 1310              		.loc 1 1033 0 discriminator 2
 1311 003a E36B     		ldr	r3, [r4, #60]
 1312 003c 012B     		cmp	r3, #1
 1313 003e 33D0     		beq	.L258
1033:Libraries/FreeRTOS/Source/queue.c **** 
 1314              		.loc 1 1033 0 is_stmt 0
 1315 0040 FFF7FEFF 		bl	ulPortSetInterruptMask
 1316              	.LVL155:
 1317              	.L230:
 1318 0044 FEE7     		b	.L230
 1319              	.LVL156:
 1320              	.L257:
 1321              	.LBB52:
 1322              	.LBB53:
1596:Libraries/FreeRTOS/Source/queue.c **** 	{
 1323              		.loc 1 1596 0 is_stmt 1
 1324 0046 226C     		ldr	r2, [r4, #64]
 1325 0048 AAB9     		cbnz	r2, .L221
 1326              	.L231:
1600:Libraries/FreeRTOS/Source/queue.c **** 			{
 1327              		.loc 1 1600 0
 1328 004a 2568     		ldr	r5, [r4]
 1329              	.LVL157:
 1330 004c 002D     		cmp	r5, #0
 1331 004e 4CD0     		beq	.L259
 1332              	.LVL158:
 1333              	.L222:
1660:Libraries/FreeRTOS/Source/queue.c **** }
 1334              		.loc 1 1660 0
 1335 0050 A36B     		ldr	r3, [r4, #56]
 1336 0052 0133     		adds	r3, r3, #1
 1337 0054 A363     		str	r3, [r4, #56]
 1338              	.LBE53:
 1339              	.LBE52:
1066:Libraries/FreeRTOS/Source/queue.c **** 			{
 1340              		.loc 1 1066 0
 1341 0056 A36C     		ldr	r3, [r4, #72]
 1342 0058 0133     		adds	r3, r3, #1
 1343 005a 1BD0     		beq	.L260
1152:Libraries/FreeRTOS/Source/queue.c **** 			}
 1344              		.loc 1 1152 0
 1345 005c A36C     		ldr	r3, [r4, #72]
 1346 005e 0133     		adds	r3, r3, #1
 1347 0060 A364     		str	r3, [r4, #72]
1163:Libraries/FreeRTOS/Source/queue.c **** 
 1348              		.loc 1 1163 0
 1349 0062 3846     		mov	r0, r7
1155:Libraries/FreeRTOS/Source/queue.c **** 		}
 1350              		.loc 1 1155 0
 1351 0064 0124     		movs	r4, #1
 1352              	.LVL159:
1163:Libraries/FreeRTOS/Source/queue.c **** 
 1353              		.loc 1 1163 0
 1354 0066 FFF7FEFF 		bl	vPortClearInterruptMask
 1355              	.LVL160:
1166:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 1356              		.loc 1 1166 0
 1357 006a 2046     		mov	r0, r4
 1358 006c BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1359              	.LVL161:
 1360              	.L254:
1031:Libraries/FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 1361              		.loc 1 1031 0 discriminator 1
 1362 0070 FFF7FEFF 		bl	ulPortSetInterruptMask
 1363              	.LVL162:
 1364              	.L214:
 1365 0074 FEE7     		b	.L214
 1366              	.LVL163:
 1367              	.L221:
 1368              	.LBB57:
 1369              	.LBB54:
1613:Libraries/FreeRTOS/Source/queue.c **** 	{
 1370              		.loc 1 1613 0
 1371 0076 05BB     		cbnz	r5, .L223
1615:Libraries/FreeRTOS/Source/queue.c **** 		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 1372              		.loc 1 1615 0
 1373 0078 3146     		mov	r1, r6
 1374 007a A068     		ldr	r0, [r4, #8]
 1375              	.LVL164:
 1376 007c FFF7FEFF 		bl	memcpy
 1377              	.LVL165:
1616:Libraries/FreeRTOS/Source/queue.c **** 		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison 
 1378              		.loc 1 1616 0
 1379 0080 A168     		ldr	r1, [r4, #8]
 1380 0082 236C     		ldr	r3, [r4, #64]
1617:Libraries/FreeRTOS/Source/queue.c **** 		{
 1381              		.loc 1 1617 0
 1382 0084 6268     		ldr	r2, [r4, #4]
1616:Libraries/FreeRTOS/Source/queue.c **** 		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison 
 1383              		.loc 1 1616 0
 1384 0086 0B44     		add	r3, r3, r1
1617:Libraries/FreeRTOS/Source/queue.c **** 		{
 1385              		.loc 1 1617 0
 1386 0088 9342     		cmp	r3, r2
1616:Libraries/FreeRTOS/Source/queue.c **** 		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison 
 1387              		.loc 1 1616 0
 1388 008a A360     		str	r3, [r4, #8]
1617:Libraries/FreeRTOS/Source/queue.c **** 		{
 1389              		.loc 1 1617 0
 1390 008c E0D3     		bcc	.L222
1619:Libraries/FreeRTOS/Source/queue.c **** 		}
 1391              		.loc 1 1619 0
 1392 008e 2368     		ldr	r3, [r4]
 1393 0090 A360     		str	r3, [r4, #8]
 1394 0092 DDE7     		b	.L222
 1395              	.LVL166:
 1396              	.L260:
 1397              	.LBE54:
 1398              	.LBE57:
1121:Libraries/FreeRTOS/Source/queue.c **** 					{
 1399              		.loc 1 1121 0
 1400 0094 636A     		ldr	r3, [r4, #36]
 1401 0096 002B     		cmp	r3, #0
 1402 0098 32D1     		bne	.L261
 1403              	.L235:
1163:Libraries/FreeRTOS/Source/queue.c **** 
 1404              		.loc 1 1163 0
 1405 009a 3846     		mov	r0, r7
1155:Libraries/FreeRTOS/Source/queue.c **** 		}
 1406              		.loc 1 1155 0
 1407 009c 0124     		movs	r4, #1
 1408              	.LVL167:
1163:Libraries/FreeRTOS/Source/queue.c **** 
 1409              		.loc 1 1163 0
 1410 009e FFF7FEFF 		bl	vPortClearInterruptMask
 1411              	.LVL168:
1166:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 1412              		.loc 1 1166 0
 1413 00a2 2046     		mov	r0, r4
 1414 00a4 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1415              	.LVL169:
 1416              	.L258:
1049:Libraries/FreeRTOS/Source/queue.c **** 
 1417              		.loc 1 1049 0
 1418 00a8 FFF7FEFF 		bl	vPortValidateInterruptPriority
 1419              	.LVL170:
1056:Libraries/FreeRTOS/Source/queue.c **** 	{
 1420              		.loc 1 1056 0
 1421 00ac FFF7FEFF 		bl	ulPortSetInterruptMask
 1422              	.LVL171:
1058:Libraries/FreeRTOS/Source/queue.c **** 		{
 1423              		.loc 1 1058 0
 1424 00b0 A26B     		ldr	r2, [r4, #56]
 1425              	.LBB58:
 1426              	.LBB55:
1596:Libraries/FreeRTOS/Source/queue.c **** 	{
 1427              		.loc 1 1596 0
 1428 00b2 226C     		ldr	r2, [r4, #64]
 1429              	.LBE55:
 1430              	.LBE58:
1056:Libraries/FreeRTOS/Source/queue.c **** 	{
 1431              		.loc 1 1056 0
 1432 00b4 0746     		mov	r7, r0
 1433              	.LVL172:
 1434              	.LBB59:
 1435              	.LBB56:
1596:Libraries/FreeRTOS/Source/queue.c **** 	{
 1436              		.loc 1 1596 0
 1437 00b6 002A     		cmp	r2, #0
 1438 00b8 C7D0     		beq	.L231
 1439              	.LVL173:
 1440              	.L223:
1628:Libraries/FreeRTOS/Source/queue.c **** 		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 1441              		.loc 1 1628 0
 1442 00ba 3146     		mov	r1, r6
 1443 00bc E068     		ldr	r0, [r4, #12]
 1444              	.LVL174:
 1445 00be FFF7FEFF 		bl	memcpy
 1446              	.LVL175:
1629:Libraries/FreeRTOS/Source/queue.c **** 		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as compariso
 1447              		.loc 1 1629 0
 1448 00c2 236C     		ldr	r3, [r4, #64]
 1449 00c4 E268     		ldr	r2, [r4, #12]
1630:Libraries/FreeRTOS/Source/queue.c **** 		{
 1450              		.loc 1 1630 0
 1451 00c6 2168     		ldr	r1, [r4]
1629:Libraries/FreeRTOS/Source/queue.c **** 		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as compariso
 1452              		.loc 1 1629 0
 1453 00c8 5B42     		negs	r3, r3
 1454 00ca 1A44     		add	r2, r2, r3
1630:Libraries/FreeRTOS/Source/queue.c **** 		{
 1455              		.loc 1 1630 0
 1456 00cc 8A42     		cmp	r2, r1
1629:Libraries/FreeRTOS/Source/queue.c **** 		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as compariso
 1457              		.loc 1 1629 0
 1458 00ce E260     		str	r2, [r4, #12]
1632:Libraries/FreeRTOS/Source/queue.c **** 		}
 1459              		.loc 1 1632 0
 1460 00d0 3EBF     		ittt	cc
 1461 00d2 6268     		ldrcc	r2, [r4, #4]
 1462 00d4 9B18     		addcc	r3, r3, r2
 1463 00d6 E360     		strcc	r3, [r4, #12]
1639:Libraries/FreeRTOS/Source/queue.c **** 		{
 1464              		.loc 1 1639 0
 1465 00d8 022D     		cmp	r5, #2
 1466 00da B9D1     		bne	.L222
1641:Libraries/FreeRTOS/Source/queue.c **** 			{
 1467              		.loc 1 1641 0
 1468 00dc A36B     		ldr	r3, [r4, #56]
 1469 00de 002B     		cmp	r3, #0
 1470 00e0 B6D0     		beq	.L222
1647:Libraries/FreeRTOS/Source/queue.c **** 			}
 1471              		.loc 1 1647 0
 1472 00e2 A36B     		ldr	r3, [r4, #56]
 1473 00e4 013B     		subs	r3, r3, #1
 1474 00e6 A363     		str	r3, [r4, #56]
 1475 00e8 B2E7     		b	.L222
 1476              	.LVL176:
 1477              	.L259:
1603:Libraries/FreeRTOS/Source/queue.c **** 				pxQueue->pxMutexHolder = NULL;
 1478              		.loc 1 1603 0
 1479 00ea 6068     		ldr	r0, [r4, #4]
 1480              	.LVL177:
 1481 00ec FFF7FEFF 		bl	vTaskPriorityDisinherit
 1482              	.LVL178:
1604:Libraries/FreeRTOS/Source/queue.c **** 			}
 1483              		.loc 1 1604 0
 1484 00f0 6560     		str	r5, [r4, #4]
 1485 00f2 ADE7     		b	.L222
 1486              	.LVL179:
 1487              	.L255:
 1488              	.LBE56:
 1489              	.LBE59:
1032:Libraries/FreeRTOS/Source/queue.c **** 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 1490              		.loc 1 1032 0 discriminator 2
 1491 00f4 036C     		ldr	r3, [r0, #64]
 1492              	.LVL180:
 1493 00f6 002B     		cmp	r3, #0
 1494 00f8 8CD0     		beq	.L215
1032:Libraries/FreeRTOS/Source/queue.c **** 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 1495              		.loc 1 1032 0 is_stmt 0
 1496 00fa FFF7FEFF 		bl	ulPortSetInterruptMask
 1497              	.LVL181:
 1498              	.L227:
 1499 00fe FEE7     		b	.L227
 1500              	.LVL182:
 1501              	.L261:
1123:Libraries/FreeRTOS/Source/queue.c **** 						{
 1502              		.loc 1 1123 0 is_stmt 1
 1503 0100 04F12400 		add	r0, r4, #36
 1504 0104 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1505              	.LVL183:
 1506 0108 0028     		cmp	r0, #0
 1507 010a C6D0     		beq	.L235
1129:Libraries/FreeRTOS/Source/queue.c **** 							}
 1508              		.loc 1 1129 0
 1509 010c 0124     		movs	r4, #1
 1510              	.LVL184:
1127:Libraries/FreeRTOS/Source/queue.c **** 							{
 1511              		.loc 1 1127 0
 1512 010e B8F1000F 		cmp	r8, #0
 1513 0112 8CD0     		beq	.L226
1163:Libraries/FreeRTOS/Source/queue.c **** 
 1514              		.loc 1 1163 0
 1515 0114 3846     		mov	r0, r7
1129:Libraries/FreeRTOS/Source/queue.c **** 							}
 1516              		.loc 1 1129 0
 1517 0116 C8F80040 		str	r4, [r8]
 1518              	.LVL185:
1163:Libraries/FreeRTOS/Source/queue.c **** 
 1519              		.loc 1 1163 0
 1520 011a FFF7FEFF 		bl	vPortClearInterruptMask
 1521              	.LVL186:
1166:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 1522              		.loc 1 1166 0
 1523 011e 2046     		mov	r0, r4
 1524 0120 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1525              		.cfi_endproc
 1526              	.LFE130:
 1528              		.section	.text.xQueueGenericReceive,"ax",%progbits
 1529              		.align	2
 1530              		.global	xQueueGenericReceive
 1531              		.thumb
 1532              		.thumb_func
 1534              	xQueueGenericReceive:
 1535              	.LFB131:
1170:Libraries/FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 1536              		.loc 1 1170 0
 1537              		.cfi_startproc
 1538              		@ args = 0, pretend = 0, frame = 16
 1539              		@ frame_needed = 0, uses_anonymous_args = 0
 1540              	.LVL187:
 1541 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 1542              	.LCFI10:
 1543              		.cfi_def_cfa_offset 36
 1544              		.cfi_offset 4, -36
 1545              		.cfi_offset 5, -32
 1546              		.cfi_offset 6, -28
 1547              		.cfi_offset 7, -24
 1548              		.cfi_offset 8, -20
 1549              		.cfi_offset 9, -16
 1550              		.cfi_offset 10, -12
 1551              		.cfi_offset 11, -8
 1552              		.cfi_offset 14, -4
 1553 0004 85B0     		sub	sp, sp, #20
 1554              	.LCFI11:
 1555              		.cfi_def_cfa_offset 56
1176:Libraries/FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 1556              		.loc 1 1176 0
 1557 0006 0446     		mov	r4, r0
1170:Libraries/FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 1558              		.loc 1 1170 0
 1559 0008 8846     		mov	r8, r1
 1560 000a 0192     		str	r2, [sp, #4]
 1561 000c 9A46     		mov	r10, r3
1176:Libraries/FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 1562              		.loc 1 1176 0
 1563 000e 0028     		cmp	r0, #0
 1564 0010 00F0DC80 		beq	.L361
1177:Libraries/FreeRTOS/Source/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
 1565              		.loc 1 1177 0
 1566 0014 0029     		cmp	r1, #0
 1567 0016 00F00B81 		beq	.L362
 1568              	.LVL188:
 1569              	.L265:
1180:Libraries/FreeRTOS/Source/queue.c **** 	}
 1570              		.loc 1 1180 0
 1571 001a FFF7FEFF 		bl	xTaskGetSchedulerState
 1572              	.LVL189:
 1573 001e 18B9     		cbnz	r0, .L308
1180:Libraries/FreeRTOS/Source/queue.c **** 	}
 1574              		.loc 1 1180 0 is_stmt 0 discriminator 2
 1575 0020 019B     		ldr	r3, [sp, #4]
 1576 0022 002B     		cmp	r3, #0
 1577 0024 40F00181 		bne	.L268
 1578              	.L308:
1190:Libraries/FreeRTOS/Source/queue.c **** 		{
 1579              		.loc 1 1190 0 is_stmt 1
 1580 0028 FFF7FEFF 		bl	vPortEnterCritical
 1581              	.LVL190:
1194:Libraries/FreeRTOS/Source/queue.c **** 			{
 1582              		.loc 1 1194 0
 1583 002c A36B     		ldr	r3, [r4, #56]
1170:Libraries/FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 1584              		.loc 1 1170 0
 1585 002e 4FF0000B 		mov	fp, #0
 1586              	.LVL191:
1303:Libraries/FreeRTOS/Source/queue.c **** 
 1587              		.loc 1 1303 0
 1588 0032 D946     		mov	r9, fp
1329:Libraries/FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1589              		.loc 1 1329 0
 1590 0034 04F12405 		add	r5, r4, #36
 1591              	.LBB66:
 1592              	.LBB67:
1767:Libraries/FreeRTOS/Source/queue.c **** 	}
 1593              		.loc 1 1767 0
 1594 0038 4FF0FF37 		mov	r7, #-1
 1595 003c 04F11006 		add	r6, r4, #16
 1596              	.LBE67:
 1597              	.LBE66:
1194:Libraries/FreeRTOS/Source/queue.c **** 			{
 1598              		.loc 1 1194 0
 1599 0040 002B     		cmp	r3, #0
 1600 0042 6FD1     		bne	.L363
 1601              	.L271:
1275:Libraries/FreeRTOS/Source/queue.c **** 				{
 1602              		.loc 1 1275 0
 1603 0044 0198     		ldr	r0, [sp, #4]
 1604 0046 0028     		cmp	r0, #0
 1605 0048 00F0D480 		beq	.L364
1283:Libraries/FreeRTOS/Source/queue.c **** 				{
 1606              		.loc 1 1283 0
 1607 004c BBF1000F 		cmp	fp, #0
 1608 0050 00F0B880 		beq	.L365
 1609              	.LVL192:
 1610              	.L280:
1297:Libraries/FreeRTOS/Source/queue.c **** 
 1611              		.loc 1 1297 0
 1612 0054 FFF7FEFF 		bl	vPortExitCritical
 1613              	.LVL193:
1302:Libraries/FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 1614              		.loc 1 1302 0
 1615 0058 FFF7FEFF 		bl	vTaskSuspendAll
 1616              	.LVL194:
1303:Libraries/FreeRTOS/Source/queue.c **** 
 1617              		.loc 1 1303 0
 1618 005c FFF7FEFF 		bl	vPortEnterCritical
 1619              	.LVL195:
 1620 0060 636C     		ldr	r3, [r4, #68]
 1621 0062 0133     		adds	r3, r3, #1
 1622 0064 08BF     		it	eq
 1623 0066 C4F84490 		streq	r9, [r4, #68]
 1624 006a A36C     		ldr	r3, [r4, #72]
 1625 006c 0133     		adds	r3, r3, #1
 1626 006e 08BF     		it	eq
 1627 0070 C4F84890 		streq	r9, [r4, #72]
 1628 0074 FFF7FEFF 		bl	vPortExitCritical
 1629              	.LVL196:
1306:Libraries/FreeRTOS/Source/queue.c **** 		{
 1630              		.loc 1 1306 0
 1631 0078 02A8     		add	r0, sp, #8
 1632 007a 01A9     		add	r1, sp, #4
 1633              	.LVL197:
 1634 007c FFF7FEFF 		bl	xTaskCheckForTimeOut
 1635              	.LVL198:
 1636 0080 0028     		cmp	r0, #0
 1637 0082 40F0AE80 		bne	.L283
 1638              	.LVL199:
 1639              	.LBB69:
 1640              	.LBB70:
1805:Libraries/FreeRTOS/Source/queue.c **** 	{
 1641              		.loc 1 1805 0
 1642 0086 FFF7FEFF 		bl	vPortEnterCritical
 1643              	.LVL200:
1807:Libraries/FreeRTOS/Source/queue.c **** 		{
 1644              		.loc 1 1807 0
 1645 008a A36B     		ldr	r3, [r4, #56]
 1646 008c 002B     		cmp	r3, #0
 1647 008e 62D1     		bne	.L366
 1648              	.LVL201:
1816:Libraries/FreeRTOS/Source/queue.c **** 
 1649              		.loc 1 1816 0
 1650 0090 FFF7FEFF 		bl	vPortExitCritical
 1651              	.LVL202:
 1652              	.LBE70:
 1653              	.LBE69:
1314:Libraries/FreeRTOS/Source/queue.c **** 					{
 1654              		.loc 1 1314 0
 1655 0094 2368     		ldr	r3, [r4]
 1656 0096 002B     		cmp	r3, #0
 1657 0098 00F09B80 		beq	.L367
 1658              	.L313:
1329:Libraries/FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1659              		.loc 1 1329 0
 1660 009c 2846     		mov	r0, r5
 1661 009e 0199     		ldr	r1, [sp, #4]
 1662 00a0 FFF7FEFF 		bl	vTaskPlaceOnEventList
 1663              	.LVL203:
 1664              	.LBB72:
 1665              	.LBB68:
1694:Libraries/FreeRTOS/Source/queue.c **** 	{
 1666              		.loc 1 1694 0
 1667 00a4 FFF7FEFF 		bl	vPortEnterCritical
 1668              	.LVL204:
1697:Libraries/FreeRTOS/Source/queue.c **** 		{
 1669              		.loc 1 1697 0
 1670 00a8 A36C     		ldr	r3, [r4, #72]
 1671 00aa 002B     		cmp	r3, #0
 1672 00ac 06DC     		bgt	.L292
 1673 00ae 0FE0     		b	.L289
 1674              	.L291:
1764:Libraries/FreeRTOS/Source/queue.c **** 		}
 1675              		.loc 1 1764 0
 1676 00b0 A36C     		ldr	r3, [r4, #72]
 1677 00b2 013B     		subs	r3, r3, #1
 1678 00b4 A364     		str	r3, [r4, #72]
1697:Libraries/FreeRTOS/Source/queue.c **** 		{
 1679              		.loc 1 1697 0
 1680 00b6 A36C     		ldr	r3, [r4, #72]
 1681 00b8 002B     		cmp	r3, #0
 1682 00ba 09DD     		ble	.L289
 1683              	.L292:
1744:Libraries/FreeRTOS/Source/queue.c **** 				{
 1684              		.loc 1 1744 0
 1685 00bc 636A     		ldr	r3, [r4, #36]
 1686 00be 3BB1     		cbz	r3, .L289
1746:Libraries/FreeRTOS/Source/queue.c **** 					{
 1687              		.loc 1 1746 0
 1688 00c0 2846     		mov	r0, r5
 1689 00c2 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1690              	.LVL205:
 1691 00c6 0028     		cmp	r0, #0
 1692 00c8 F2D0     		beq	.L291
1750:Libraries/FreeRTOS/Source/queue.c **** 					}
 1693              		.loc 1 1750 0
 1694 00ca FFF7FEFF 		bl	vTaskMissedYield
 1695              	.LVL206:
 1696 00ce EFE7     		b	.L291
 1697              	.L289:
1767:Libraries/FreeRTOS/Source/queue.c **** 	}
 1698              		.loc 1 1767 0
 1699 00d0 A764     		str	r7, [r4, #72]
1769:Libraries/FreeRTOS/Source/queue.c **** 
 1700              		.loc 1 1769 0
 1701 00d2 FFF7FEFF 		bl	vPortExitCritical
 1702              	.LVL207:
1772:Libraries/FreeRTOS/Source/queue.c **** 	{
 1703              		.loc 1 1772 0
 1704 00d6 FFF7FEFF 		bl	vPortEnterCritical
 1705              	.LVL208:
1774:Libraries/FreeRTOS/Source/queue.c **** 		{
 1706              		.loc 1 1774 0
 1707 00da 636C     		ldr	r3, [r4, #68]
 1708 00dc 002B     		cmp	r3, #0
 1709 00de 12DD     		ble	.L288
1776:Libraries/FreeRTOS/Source/queue.c **** 			{
 1710              		.loc 1 1776 0
 1711 00e0 2369     		ldr	r3, [r4, #16]
 1712 00e2 43B9     		cbnz	r3, .L295
 1713 00e4 0FE0     		b	.L288
 1714              	.L296:
1787:Libraries/FreeRTOS/Source/queue.c **** 			}
 1715              		.loc 1 1787 0
 1716 00e6 636C     		ldr	r3, [r4, #68]
 1717 00e8 013B     		subs	r3, r3, #1
 1718 00ea 6364     		str	r3, [r4, #68]
1774:Libraries/FreeRTOS/Source/queue.c **** 		{
 1719              		.loc 1 1774 0
 1720 00ec 636C     		ldr	r3, [r4, #68]
 1721 00ee 002B     		cmp	r3, #0
 1722 00f0 09DD     		ble	.L288
1776:Libraries/FreeRTOS/Source/queue.c **** 			{
 1723              		.loc 1 1776 0
 1724 00f2 2269     		ldr	r2, [r4, #16]
 1725 00f4 3AB1     		cbz	r2, .L288
 1726              	.L295:
1778:Libraries/FreeRTOS/Source/queue.c **** 				{
 1727              		.loc 1 1778 0
 1728 00f6 3046     		mov	r0, r6
 1729 00f8 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1730              	.LVL209:
 1731 00fc 0028     		cmp	r0, #0
 1732 00fe F2D0     		beq	.L296
1780:Libraries/FreeRTOS/Source/queue.c **** 				}
 1733              		.loc 1 1780 0
 1734 0100 FFF7FEFF 		bl	vTaskMissedYield
 1735              	.LVL210:
 1736 0104 EFE7     		b	.L296
 1737              	.L288:
1795:Libraries/FreeRTOS/Source/queue.c **** 	}
 1738              		.loc 1 1795 0
 1739 0106 6764     		str	r7, [r4, #68]
1797:Libraries/FreeRTOS/Source/queue.c **** }
 1740              		.loc 1 1797 0
 1741 0108 FFF7FEFF 		bl	vPortExitCritical
 1742              	.LVL211:
 1743              	.LBE68:
 1744              	.LBE72:
1331:Libraries/FreeRTOS/Source/queue.c **** 				{
 1745              		.loc 1 1331 0
 1746 010c FFF7FEFF 		bl	xTaskResumeAll
 1747              	.LVL212:
 1748 0110 08B9     		cbnz	r0, .L294
1333:Libraries/FreeRTOS/Source/queue.c **** 				}
 1749              		.loc 1 1333 0
 1750 0112 FFF7FEFF 		bl	vPortYield
 1751              	.LVL213:
 1752              	.L294:
1190:Libraries/FreeRTOS/Source/queue.c **** 		{
 1753              		.loc 1 1190 0
 1754 0116 FFF7FEFF 		bl	vPortEnterCritical
 1755              	.LVL214:
1194:Libraries/FreeRTOS/Source/queue.c **** 			{
 1756              		.loc 1 1194 0
 1757 011a A36B     		ldr	r3, [r4, #56]
 1758 011c 4FF0010B 		mov	fp, #1
 1759              	.LVL215:
 1760 0120 002B     		cmp	r3, #0
 1761 0122 8FD0     		beq	.L271
 1762              	.LVL216:
 1763              	.L363:
1200:Libraries/FreeRTOS/Source/queue.c **** 
 1764              		.loc 1 1200 0
 1765 0124 4146     		mov	r1, r8
 1766 0126 2046     		mov	r0, r4
1198:Libraries/FreeRTOS/Source/queue.c **** 
 1767              		.loc 1 1198 0
 1768 0128 E568     		ldr	r5, [r4, #12]
 1769              	.LVL217:
1200:Libraries/FreeRTOS/Source/queue.c **** 
 1770              		.loc 1 1200 0
 1771 012a FFF7FEFF 		bl	prvCopyDataFromQueue
 1772              	.LVL218:
1202:Libraries/FreeRTOS/Source/queue.c **** 				{
 1773              		.loc 1 1202 0
 1774 012e BAF1000F 		cmp	r10, #0
 1775 0132 66D1     		bne	.L272
1207:Libraries/FreeRTOS/Source/queue.c **** 
 1776              		.loc 1 1207 0
 1777 0134 A26B     		ldr	r2, [r4, #56]
1211:Libraries/FreeRTOS/Source/queue.c **** 						{
 1778              		.loc 1 1211 0
 1779 0136 2368     		ldr	r3, [r4]
1207:Libraries/FreeRTOS/Source/queue.c **** 
 1780              		.loc 1 1207 0
 1781 0138 013A     		subs	r2, r2, #1
 1782 013a A263     		str	r2, [r4, #56]
1211:Libraries/FreeRTOS/Source/queue.c **** 						{
 1783              		.loc 1 1211 0
 1784 013c 13B9     		cbnz	r3, .L273
1215:Libraries/FreeRTOS/Source/queue.c **** 						}
 1785              		.loc 1 1215 0
 1786 013e FFF7FEFF 		bl	xTaskGetCurrentTaskHandle
 1787              	.LVL219:
 1788 0142 6060     		str	r0, [r4, #4]
 1789              	.L273:
1224:Libraries/FreeRTOS/Source/queue.c **** 					{
 1790              		.loc 1 1224 0
 1791 0144 2369     		ldr	r3, [r4, #16]
 1792 0146 002B     		cmp	r3, #0
 1793 0148 68D1     		bne	.L368
 1794              	.L275:
1270:Libraries/FreeRTOS/Source/queue.c **** 				return pdPASS;
 1795              		.loc 1 1270 0
 1796 014a FFF7FEFF 		bl	vPortExitCritical
 1797              	.LVL220:
1271:Libraries/FreeRTOS/Source/queue.c **** 			}
 1798              		.loc 1 1271 0
 1799 014e 0120     		movs	r0, #1
1355:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 1800              		.loc 1 1355 0
 1801 0150 05B0     		add	sp, sp, #20
 1802              		@ sp needed
 1803 0152 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1804              	.LVL221:
 1805              	.L366:
 1806              	.LBB73:
 1807              	.LBB71:
1816:Libraries/FreeRTOS/Source/queue.c **** 
 1808              		.loc 1 1816 0
 1809 0156 FFF7FEFF 		bl	vPortExitCritical
 1810              	.LVL222:
 1811              	.LBE71:
 1812              	.LBE73:
 1813              	.LBB74:
 1814              	.LBB75:
1694:Libraries/FreeRTOS/Source/queue.c **** 	{
 1815              		.loc 1 1694 0
 1816 015a FFF7FEFF 		bl	vPortEnterCritical
 1817              	.LVL223:
1697:Libraries/FreeRTOS/Source/queue.c **** 		{
 1818              		.loc 1 1697 0
 1819 015e A36C     		ldr	r3, [r4, #72]
 1820 0160 002B     		cmp	r3, #0
 1821 0162 06DC     		bgt	.L302
 1822 0164 0FE0     		b	.L303
 1823              	.L301:
1764:Libraries/FreeRTOS/Source/queue.c **** 		}
 1824              		.loc 1 1764 0
 1825 0166 A36C     		ldr	r3, [r4, #72]
 1826 0168 013B     		subs	r3, r3, #1
 1827 016a A364     		str	r3, [r4, #72]
1697:Libraries/FreeRTOS/Source/queue.c **** 		{
 1828              		.loc 1 1697 0
 1829 016c A36C     		ldr	r3, [r4, #72]
 1830 016e 002B     		cmp	r3, #0
 1831 0170 09DD     		ble	.L303
 1832              	.L302:
1744:Libraries/FreeRTOS/Source/queue.c **** 				{
 1833              		.loc 1 1744 0
 1834 0172 636A     		ldr	r3, [r4, #36]
 1835 0174 3BB1     		cbz	r3, .L303
1746:Libraries/FreeRTOS/Source/queue.c **** 					{
 1836              		.loc 1 1746 0
 1837 0176 2846     		mov	r0, r5
 1838 0178 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1839              	.LVL224:
 1840 017c 0028     		cmp	r0, #0
 1841 017e F2D0     		beq	.L301
1750:Libraries/FreeRTOS/Source/queue.c **** 					}
 1842              		.loc 1 1750 0
 1843 0180 FFF7FEFF 		bl	vTaskMissedYield
 1844              	.LVL225:
 1845 0184 EFE7     		b	.L301
 1846              	.L303:
1767:Libraries/FreeRTOS/Source/queue.c **** 	}
 1847              		.loc 1 1767 0
 1848 0186 A764     		str	r7, [r4, #72]
1769:Libraries/FreeRTOS/Source/queue.c **** 
 1849              		.loc 1 1769 0
 1850 0188 FFF7FEFF 		bl	vPortExitCritical
 1851              	.LVL226:
1772:Libraries/FreeRTOS/Source/queue.c **** 	{
 1852              		.loc 1 1772 0
 1853 018c FFF7FEFF 		bl	vPortEnterCritical
 1854              	.LVL227:
1774:Libraries/FreeRTOS/Source/queue.c **** 		{
 1855              		.loc 1 1774 0
 1856 0190 636C     		ldr	r3, [r4, #68]
 1857 0192 002B     		cmp	r3, #0
 1858 0194 06DC     		bgt	.L306
 1859 0196 0FE0     		b	.L300
 1860              	.L305:
1787:Libraries/FreeRTOS/Source/queue.c **** 			}
 1861              		.loc 1 1787 0
 1862 0198 636C     		ldr	r3, [r4, #68]
 1863 019a 013B     		subs	r3, r3, #1
 1864 019c 6364     		str	r3, [r4, #68]
1774:Libraries/FreeRTOS/Source/queue.c **** 		{
 1865              		.loc 1 1774 0
 1866 019e 636C     		ldr	r3, [r4, #68]
 1867 01a0 002B     		cmp	r3, #0
 1868 01a2 09DD     		ble	.L300
 1869              	.L306:
1776:Libraries/FreeRTOS/Source/queue.c **** 			{
 1870              		.loc 1 1776 0
 1871 01a4 2369     		ldr	r3, [r4, #16]
 1872 01a6 3BB1     		cbz	r3, .L300
1778:Libraries/FreeRTOS/Source/queue.c **** 				{
 1873              		.loc 1 1778 0
 1874 01a8 3046     		mov	r0, r6
 1875 01aa FFF7FEFF 		bl	xTaskRemoveFromEventList
 1876              	.LVL228:
 1877 01ae 0028     		cmp	r0, #0
 1878 01b0 F2D0     		beq	.L305
1780:Libraries/FreeRTOS/Source/queue.c **** 				}
 1879              		.loc 1 1780 0
 1880 01b2 FFF7FEFF 		bl	vTaskMissedYield
 1881              	.LVL229:
 1882 01b6 EFE7     		b	.L305
 1883              	.L300:
1795:Libraries/FreeRTOS/Source/queue.c **** 	}
 1884              		.loc 1 1795 0
 1885 01b8 6764     		str	r7, [r4, #68]
1797:Libraries/FreeRTOS/Source/queue.c **** }
 1886              		.loc 1 1797 0
 1887 01ba FFF7FEFF 		bl	vPortExitCritical
 1888              	.LVL230:
 1889              	.LBE75:
 1890              	.LBE74:
1344:Libraries/FreeRTOS/Source/queue.c **** 			}
 1891              		.loc 1 1344 0
 1892 01be FFF7FEFF 		bl	xTaskResumeAll
 1893              	.LVL231:
 1894 01c2 A8E7     		b	.L294
 1895              	.LVL232:
 1896              	.L365:
1287:Libraries/FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 1897              		.loc 1 1287 0
 1898 01c4 02A8     		add	r0, sp, #8
 1899 01c6 FFF7FEFF 		bl	vTaskSetTimeOutState
 1900              	.LVL233:
 1901 01ca 43E7     		b	.L280
 1902              	.LVL234:
 1903              	.L361:
1176:Libraries/FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 1904              		.loc 1 1176 0 discriminator 1
 1905 01cc FFF7FEFF 		bl	ulPortSetInterruptMask
 1906              	.LVL235:
 1907              	.L264:
 1908 01d0 FEE7     		b	.L264
 1909              	.LVL236:
 1910              	.L367:
1316:Libraries/FreeRTOS/Source/queue.c **** 						{
 1911              		.loc 1 1316 0
 1912 01d2 FFF7FEFF 		bl	vPortEnterCritical
 1913              	.LVL237:
1318:Libraries/FreeRTOS/Source/queue.c **** 						}
 1914              		.loc 1 1318 0
 1915 01d6 6068     		ldr	r0, [r4, #4]
 1916 01d8 FFF7FEFF 		bl	vTaskPriorityInherit
 1917              	.LVL238:
1320:Libraries/FreeRTOS/Source/queue.c **** 					}
 1918              		.loc 1 1320 0
 1919 01dc FFF7FEFF 		bl	vPortExitCritical
 1920              	.LVL239:
 1921 01e0 5CE7     		b	.L313
 1922              	.LVL240:
 1923              	.L283:
1349:Libraries/FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
 1924              		.loc 1 1349 0
 1925 01e2 2046     		mov	r0, r4
 1926 01e4 FFF7FEFF 		bl	prvUnlockQueue
 1927              	.LVL241:
1350:Libraries/FreeRTOS/Source/queue.c **** 			traceQUEUE_RECEIVE_FAILED( pxQueue );
 1928              		.loc 1 1350 0
 1929 01e8 FFF7FEFF 		bl	xTaskResumeAll
 1930              	.LVL242:
1352:Libraries/FreeRTOS/Source/queue.c **** 		}
 1931              		.loc 1 1352 0
 1932 01ec 0020     		movs	r0, #0
1355:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 1933              		.loc 1 1355 0
 1934 01ee 05B0     		add	sp, sp, #20
 1935              		@ sp needed
 1936 01f0 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1937              	.LVL243:
 1938              	.L364:
1279:Libraries/FreeRTOS/Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
 1939              		.loc 1 1279 0
 1940 01f4 0090     		str	r0, [sp]
 1941 01f6 FFF7FEFF 		bl	vPortExitCritical
 1942              	.LVL244:
1281:Libraries/FreeRTOS/Source/queue.c **** 				}
 1943              		.loc 1 1281 0
 1944 01fa 0098     		ldr	r0, [sp]
1355:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 1945              		.loc 1 1355 0
 1946 01fc 05B0     		add	sp, sp, #20
 1947              		@ sp needed
 1948 01fe BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1949              	.LVL245:
 1950              	.L272:
1250:Libraries/FreeRTOS/Source/queue.c **** 					{
 1951              		.loc 1 1250 0
 1952 0202 636A     		ldr	r3, [r4, #36]
1246:Libraries/FreeRTOS/Source/queue.c **** 
 1953              		.loc 1 1246 0
 1954 0204 E560     		str	r5, [r4, #12]
1250:Libraries/FreeRTOS/Source/queue.c **** 					{
 1955              		.loc 1 1250 0
 1956 0206 002B     		cmp	r3, #0
 1957 0208 9FD0     		beq	.L275
1254:Libraries/FreeRTOS/Source/queue.c **** 						{
 1958              		.loc 1 1254 0
 1959 020a 04F12400 		add	r0, r4, #36
 1960 020e FFF7FEFF 		bl	xTaskRemoveFromEventList
 1961              	.LVL246:
 1962 0212 0028     		cmp	r0, #0
 1963 0214 99D0     		beq	.L275
 1964              	.L277:
1228:Libraries/FreeRTOS/Source/queue.c **** 						}
 1965              		.loc 1 1228 0
 1966 0216 FFF7FEFF 		bl	vPortYield
 1967              	.LVL247:
 1968 021a 96E7     		b	.L275
 1969              	.L368:
1226:Libraries/FreeRTOS/Source/queue.c **** 						{
 1970              		.loc 1 1226 0
 1971 021c 04F11000 		add	r0, r4, #16
 1972 0220 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1973              	.LVL248:
 1974 0224 0128     		cmp	r0, #1
 1975 0226 90D1     		bne	.L275
 1976 0228 F5E7     		b	.L277
 1977              	.LVL249:
 1978              	.L268:
1180:Libraries/FreeRTOS/Source/queue.c **** 	}
 1979              		.loc 1 1180 0
 1980 022a FFF7FEFF 		bl	ulPortSetInterruptMask
 1981              	.LVL250:
 1982              	.L310:
 1983 022e FEE7     		b	.L310
 1984              	.LVL251:
 1985              	.L362:
1177:Libraries/FreeRTOS/Source/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
 1986              		.loc 1 1177 0 discriminator 2
 1987 0230 036C     		ldr	r3, [r0, #64]
 1988              	.LVL252:
 1989 0232 002B     		cmp	r3, #0
 1990 0234 3FF4F1AE 		beq	.L265
1177:Libraries/FreeRTOS/Source/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
 1991              		.loc 1 1177 0 is_stmt 0
 1992 0238 FFF7FEFF 		bl	ulPortSetInterruptMask
 1993              	.LVL253:
 1994              	.L307:
 1995 023c FEE7     		b	.L307
 1996              		.cfi_endproc
 1997              	.LFE131:
 1999 023e 00BF     		.section	.text.xQueueTakeMutexRecursive,"ax",%progbits
 2000              		.align	2
 2001              		.global	xQueueTakeMutexRecursive
 2002              		.thumb
 2003              		.thumb_func
 2005              	xQueueTakeMutexRecursive:
 2006              	.LFB127:
 526:Libraries/FreeRTOS/Source/queue.c **** 	BaseType_t xReturn;
 2007              		.loc 1 526 0 is_stmt 1
 2008              		.cfi_startproc
 2009              		@ args = 0, pretend = 0, frame = 0
 2010              		@ frame_needed = 0, uses_anonymous_args = 0
 2011              	.LVL254:
 2012 0000 70B5     		push	{r4, r5, r6, lr}
 2013              	.LCFI12:
 2014              		.cfi_def_cfa_offset 16
 2015              		.cfi_offset 4, -16
 2016              		.cfi_offset 5, -12
 2017              		.cfi_offset 6, -8
 2018              		.cfi_offset 14, -4
 530:Libraries/FreeRTOS/Source/queue.c **** 
 2019              		.loc 1 530 0
 2020 0002 0446     		mov	r4, r0
 526:Libraries/FreeRTOS/Source/queue.c **** 	BaseType_t xReturn;
 2021              		.loc 1 526 0
 2022 0004 0D46     		mov	r5, r1
 530:Libraries/FreeRTOS/Source/queue.c **** 
 2023              		.loc 1 530 0
 2024 0006 80B1     		cbz	r0, .L374
 537:Libraries/FreeRTOS/Source/queue.c **** 		{
 2025              		.loc 1 537 0
 2026 0008 4668     		ldr	r6, [r0, #4]
 2027 000a FFF7FEFF 		bl	xTaskGetCurrentTaskHandle
 2028              	.LVL255:
 2029 000e 8642     		cmp	r6, r0
 2030 0010 0ED0     		beq	.L375
 544:Libraries/FreeRTOS/Source/queue.c **** 
 2031              		.loc 1 544 0
 2032 0012 0021     		movs	r1, #0
 2033 0014 0B46     		mov	r3, r1
 2034 0016 2A46     		mov	r2, r5
 2035 0018 2046     		mov	r0, r4
 2036 001a FFF7FEFF 		bl	xQueueGenericReceive
 2037              	.LVL256:
 548:Libraries/FreeRTOS/Source/queue.c **** 			{
 2038              		.loc 1 548 0
 2039 001e 0128     		cmp	r0, #1
 550:Libraries/FreeRTOS/Source/queue.c **** 			}
 2040              		.loc 1 550 0
 2041 0020 02BF     		ittt	eq
 2042 0022 E368     		ldreq	r3, [r4, #12]
 2043 0024 0133     		addeq	r3, r3, #1
 2044 0026 E360     		streq	r3, [r4, #12]
 559:Libraries/FreeRTOS/Source/queue.c **** 
 2045              		.loc 1 559 0
 2046 0028 70BD     		pop	{r4, r5, r6, pc}
 2047              	.LVL257:
 2048              	.L374:
 530:Libraries/FreeRTOS/Source/queue.c **** 
 2049              		.loc 1 530 0 discriminator 1
 2050 002a FFF7FEFF 		bl	ulPortSetInterruptMask
 2051              	.LVL258:
 2052              	.L371:
 2053 002e FEE7     		b	.L371
 2054              	.L375:
 539:Libraries/FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
 2055              		.loc 1 539 0
 2056 0030 E368     		ldr	r3, [r4, #12]
 2057 0032 0133     		adds	r3, r3, #1
 2058 0034 E360     		str	r3, [r4, #12]
 2059              	.LVL259:
 540:Libraries/FreeRTOS/Source/queue.c **** 		}
 2060              		.loc 1 540 0
 2061 0036 0120     		movs	r0, #1
 2062 0038 70BD     		pop	{r4, r5, r6, pc}
 2063              		.cfi_endproc
 2064              	.LFE127:
 2066 003a 00BF     		.section	.text.xQueueReceiveFromISR,"ax",%progbits
 2067              		.align	2
 2068              		.global	xQueueReceiveFromISR
 2069              		.thumb
 2070              		.thumb_func
 2072              	xQueueReceiveFromISR:
 2073              	.LFB132:
1359:Libraries/FreeRTOS/Source/queue.c **** BaseType_t xReturn;
 2074              		.loc 1 1359 0
 2075              		.cfi_startproc
 2076              		@ args = 0, pretend = 0, frame = 0
 2077              		@ frame_needed = 0, uses_anonymous_args = 0
 2078              	.LVL260:
 2079 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 2080              	.LCFI13:
 2081              		.cfi_def_cfa_offset 24
 2082              		.cfi_offset 3, -24
 2083              		.cfi_offset 4, -20
 2084              		.cfi_offset 5, -16
 2085              		.cfi_offset 6, -12
 2086              		.cfi_offset 7, -8
 2087              		.cfi_offset 14, -4
1364:Libraries/FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 2088              		.loc 1 1364 0
 2089 0002 0446     		mov	r4, r0
1359:Libraries/FreeRTOS/Source/queue.c **** BaseType_t xReturn;
 2090              		.loc 1 1359 0
 2091 0004 0E46     		mov	r6, r1
 2092 0006 1546     		mov	r5, r2
1364:Libraries/FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 2093              		.loc 1 1364 0
 2094 0008 68B1     		cbz	r0, .L400
1365:Libraries/FreeRTOS/Source/queue.c **** 
 2095              		.loc 1 1365 0
 2096 000a 11B3     		cbz	r1, .L401
 2097              	.L379:
1381:Libraries/FreeRTOS/Source/queue.c **** 
 2098              		.loc 1 1381 0
 2099 000c FFF7FEFF 		bl	vPortValidateInterruptPriority
 2100              	.LVL261:
1383:Libraries/FreeRTOS/Source/queue.c **** 	{
 2101              		.loc 1 1383 0
 2102 0010 FFF7FEFF 		bl	ulPortSetInterruptMask
 2103              	.LVL262:
1386:Libraries/FreeRTOS/Source/queue.c **** 		{
 2104              		.loc 1 1386 0
 2105 0014 A36B     		ldr	r3, [r4, #56]
1383:Libraries/FreeRTOS/Source/queue.c **** 	{
 2106              		.loc 1 1383 0
 2107 0016 0746     		mov	r7, r0
 2108              	.LVL263:
1386:Libraries/FreeRTOS/Source/queue.c **** 		{
 2109              		.loc 1 1386 0
 2110 0018 43B9     		cbnz	r3, .L387
1435:Libraries/FreeRTOS/Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
 2111              		.loc 1 1435 0
 2112 001a 1C46     		mov	r4, r3
 2113              	.LVL264:
1439:Libraries/FreeRTOS/Source/queue.c **** 
 2114              		.loc 1 1439 0
 2115 001c 3846     		mov	r0, r7
 2116 001e FFF7FEFF 		bl	vPortClearInterruptMask
 2117              	.LVL265:
1442:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 2118              		.loc 1 1442 0
 2119 0022 2046     		mov	r0, r4
 2120 0024 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 2121              	.LVL266:
 2122              	.L400:
1364:Libraries/FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 2123              		.loc 1 1364 0 discriminator 1
 2124 0026 FFF7FEFF 		bl	ulPortSetInterruptMask
 2125              	.LVL267:
 2126              	.L378:
 2127 002a FEE7     		b	.L378
 2128              	.LVL268:
 2129              	.L387:
1390:Libraries/FreeRTOS/Source/queue.c **** 			--( pxQueue->uxMessagesWaiting );
 2130              		.loc 1 1390 0
 2131 002c 3146     		mov	r1, r6
 2132 002e 2046     		mov	r0, r4
 2133              	.LVL269:
 2134 0030 FFF7FEFF 		bl	prvCopyDataFromQueue
 2135              	.LVL270:
1391:Libraries/FreeRTOS/Source/queue.c **** 
 2136              		.loc 1 1391 0
 2137 0034 A36B     		ldr	r3, [r4, #56]
 2138 0036 013B     		subs	r3, r3, #1
 2139 0038 A363     		str	r3, [r4, #56]
1397:Libraries/FreeRTOS/Source/queue.c **** 			{
 2140              		.loc 1 1397 0
 2141 003a 636C     		ldr	r3, [r4, #68]
 2142 003c 0133     		adds	r3, r3, #1
 2143 003e 0ED0     		beq	.L402
1428:Libraries/FreeRTOS/Source/queue.c **** 			}
 2144              		.loc 1 1428 0
 2145 0040 636C     		ldr	r3, [r4, #68]
 2146 0042 0133     		adds	r3, r3, #1
 2147 0044 6364     		str	r3, [r4, #68]
 2148              	.L399:
1439:Libraries/FreeRTOS/Source/queue.c **** 
 2149              		.loc 1 1439 0
 2150 0046 3846     		mov	r0, r7
1431:Libraries/FreeRTOS/Source/queue.c **** 		}
 2151              		.loc 1 1431 0
 2152 0048 0124     		movs	r4, #1
 2153              	.LVL271:
1439:Libraries/FreeRTOS/Source/queue.c **** 
 2154              		.loc 1 1439 0
 2155 004a FFF7FEFF 		bl	vPortClearInterruptMask
 2156              	.LVL272:
1442:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 2157              		.loc 1 1442 0
 2158 004e 2046     		mov	r0, r4
 2159 0050 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 2160              	.LVL273:
 2161              	.L401:
1365:Libraries/FreeRTOS/Source/queue.c **** 
 2162              		.loc 1 1365 0 discriminator 2
 2163 0052 036C     		ldr	r3, [r0, #64]
 2164 0054 002B     		cmp	r3, #0
 2165 0056 D9D0     		beq	.L379
1365:Libraries/FreeRTOS/Source/queue.c **** 
 2166              		.loc 1 1365 0 is_stmt 0
 2167 0058 FFF7FEFF 		bl	ulPortSetInterruptMask
 2168              	.LVL274:
 2169              	.L386:
 2170 005c FEE7     		b	.L386
 2171              	.LVL275:
 2172              	.L402:
1399:Libraries/FreeRTOS/Source/queue.c **** 				{
 2173              		.loc 1 1399 0 is_stmt 1
 2174 005e 2369     		ldr	r3, [r4, #16]
 2175 0060 002B     		cmp	r3, #0
 2176 0062 F0D0     		beq	.L399
1401:Libraries/FreeRTOS/Source/queue.c **** 					{
 2177              		.loc 1 1401 0
 2178 0064 04F11000 		add	r0, r4, #16
 2179 0068 FFF7FEFF 		bl	xTaskRemoveFromEventList
 2180              	.LVL276:
 2181 006c 0028     		cmp	r0, #0
 2182 006e EAD0     		beq	.L399
1405:Libraries/FreeRTOS/Source/queue.c **** 						{
 2183              		.loc 1 1405 0
 2184 0070 002D     		cmp	r5, #0
 2185 0072 E8D0     		beq	.L399
1407:Libraries/FreeRTOS/Source/queue.c **** 						}
 2186              		.loc 1 1407 0
 2187 0074 0124     		movs	r4, #1
 2188              	.LVL277:
1439:Libraries/FreeRTOS/Source/queue.c **** 
 2189              		.loc 1 1439 0
 2190 0076 3846     		mov	r0, r7
1407:Libraries/FreeRTOS/Source/queue.c **** 						}
 2191              		.loc 1 1407 0
 2192 0078 2C60     		str	r4, [r5]
 2193              	.LVL278:
1439:Libraries/FreeRTOS/Source/queue.c **** 
 2194              		.loc 1 1439 0
 2195 007a FFF7FEFF 		bl	vPortClearInterruptMask
 2196              	.LVL279:
1442:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 2197              		.loc 1 1442 0
 2198 007e 2046     		mov	r0, r4
 2199 0080 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 2200              		.cfi_endproc
 2201              	.LFE132:
 2203 0082 00BF     		.section	.text.xQueuePeekFromISR,"ax",%progbits
 2204              		.align	2
 2205              		.global	xQueuePeekFromISR
 2206              		.thumb
 2207              		.thumb_func
 2209              	xQueuePeekFromISR:
 2210              	.LFB133:
1446:Libraries/FreeRTOS/Source/queue.c **** BaseType_t xReturn;
 2211              		.loc 1 1446 0
 2212              		.cfi_startproc
 2213              		@ args = 0, pretend = 0, frame = 0
 2214              		@ frame_needed = 0, uses_anonymous_args = 0
 2215              	.LVL280:
 2216 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 2217              	.LCFI14:
 2218              		.cfi_def_cfa_offset 24
 2219              		.cfi_offset 4, -24
 2220              		.cfi_offset 5, -20
 2221              		.cfi_offset 6, -16
 2222              		.cfi_offset 7, -12
 2223              		.cfi_offset 8, -8
 2224              		.cfi_offset 14, -4
1452:Libraries/FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 2225              		.loc 1 1452 0
 2226 0004 0446     		mov	r4, r0
1446:Libraries/FreeRTOS/Source/queue.c **** BaseType_t xReturn;
 2227              		.loc 1 1446 0
 2228 0006 0E46     		mov	r6, r1
1452:Libraries/FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 2229              		.loc 1 1452 0
 2230 0008 68B1     		cbz	r0, .L417
1453:Libraries/FreeRTOS/Source/queue.c **** 
 2231              		.loc 1 1453 0
 2232 000a E1B1     		cbz	r1, .L418
 2233              	.L406:
1469:Libraries/FreeRTOS/Source/queue.c **** 
 2234              		.loc 1 1469 0
 2235 000c FFF7FEFF 		bl	vPortValidateInterruptPriority
 2236              	.LVL281:
1471:Libraries/FreeRTOS/Source/queue.c **** 	{
 2237              		.loc 1 1471 0
 2238 0010 FFF7FEFF 		bl	ulPortSetInterruptMask
 2239              	.LVL282:
1474:Libraries/FreeRTOS/Source/queue.c **** 		{
 2240              		.loc 1 1474 0
 2241 0014 A56B     		ldr	r5, [r4, #56]
1471:Libraries/FreeRTOS/Source/queue.c **** 	{
 2242              		.loc 1 1471 0
 2243 0016 8046     		mov	r8, r0
 2244              	.LVL283:
1474:Libraries/FreeRTOS/Source/queue.c **** 		{
 2245              		.loc 1 1474 0
 2246 0018 45B9     		cbnz	r5, .L410
 2247              	.LVL284:
1492:Libraries/FreeRTOS/Source/queue.c **** 
 2248              		.loc 1 1492 0
 2249 001a 4046     		mov	r0, r8
 2250 001c FFF7FEFF 		bl	vPortClearInterruptMask
 2251              	.LVL285:
1495:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 2252              		.loc 1 1495 0
 2253 0020 2846     		mov	r0, r5
 2254 0022 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 2255              	.LVL286:
 2256              	.L417:
1452:Libraries/FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 2257              		.loc 1 1452 0 discriminator 1
 2258 0026 FFF7FEFF 		bl	ulPortSetInterruptMask
 2259              	.LVL287:
 2260              	.L405:
 2261 002a FEE7     		b	.L405
 2262              	.LVL288:
 2263              	.L410:
1480:Libraries/FreeRTOS/Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
 2264              		.loc 1 1480 0
 2265 002c E768     		ldr	r7, [r4, #12]
 2266              	.LVL289:
1481:Libraries/FreeRTOS/Source/queue.c **** 			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 2267              		.loc 1 1481 0
 2268 002e 3146     		mov	r1, r6
 2269 0030 2046     		mov	r0, r4
 2270              	.LVL290:
 2271 0032 FFF7FEFF 		bl	prvCopyDataFromQueue
 2272              	.LVL291:
1484:Libraries/FreeRTOS/Source/queue.c **** 		}
 2273              		.loc 1 1484 0
 2274 0036 0125     		movs	r5, #1
1492:Libraries/FreeRTOS/Source/queue.c **** 
 2275              		.loc 1 1492 0
 2276 0038 4046     		mov	r0, r8
1482:Libraries/FreeRTOS/Source/queue.c **** 
 2277              		.loc 1 1482 0
 2278 003a E760     		str	r7, [r4, #12]
 2279              	.LVL292:
1492:Libraries/FreeRTOS/Source/queue.c **** 
 2280              		.loc 1 1492 0
 2281 003c FFF7FEFF 		bl	vPortClearInterruptMask
 2282              	.LVL293:
1495:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 2283              		.loc 1 1495 0
 2284 0040 2846     		mov	r0, r5
 2285 0042 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 2286              	.LVL294:
 2287              	.L418:
1453:Libraries/FreeRTOS/Source/queue.c **** 
 2288              		.loc 1 1453 0 discriminator 2
 2289 0046 036C     		ldr	r3, [r0, #64]
 2290 0048 002B     		cmp	r3, #0
 2291 004a DFD0     		beq	.L406
1453:Libraries/FreeRTOS/Source/queue.c **** 
 2292              		.loc 1 1453 0 is_stmt 0
 2293 004c FFF7FEFF 		bl	ulPortSetInterruptMask
 2294              	.LVL295:
 2295              	.L409:
 2296 0050 FEE7     		b	.L409
 2297              		.cfi_endproc
 2298              	.LFE133:
 2300 0052 00BF     		.section	.text.uxQueueMessagesWaiting,"ax",%progbits
 2301              		.align	2
 2302              		.global	uxQueueMessagesWaiting
 2303              		.thumb
 2304              		.thumb_func
 2306              	uxQueueMessagesWaiting:
 2307              	.LFB134:
1499:Libraries/FreeRTOS/Source/queue.c **** UBaseType_t uxReturn;
 2308              		.loc 1 1499 0 is_stmt 1
 2309              		.cfi_startproc
 2310              		@ args = 0, pretend = 0, frame = 0
 2311              		@ frame_needed = 0, uses_anonymous_args = 0
 2312              	.LVL296:
 2313 0000 10B5     		push	{r4, lr}
 2314              	.LCFI15:
 2315              		.cfi_def_cfa_offset 8
 2316              		.cfi_offset 4, -8
 2317              		.cfi_offset 14, -4
1502:Libraries/FreeRTOS/Source/queue.c **** 
 2318              		.loc 1 1502 0
 2319 0002 0446     		mov	r4, r0
 2320 0004 30B1     		cbz	r0, .L422
1504:Libraries/FreeRTOS/Source/queue.c **** 	{
 2321              		.loc 1 1504 0
 2322 0006 FFF7FEFF 		bl	vPortEnterCritical
 2323              	.LVL297:
1506:Libraries/FreeRTOS/Source/queue.c **** 	}
 2324              		.loc 1 1506 0
 2325 000a A46B     		ldr	r4, [r4, #56]
 2326              	.LVL298:
1508:Libraries/FreeRTOS/Source/queue.c **** 
 2327              		.loc 1 1508 0
 2328 000c FFF7FEFF 		bl	vPortExitCritical
 2329              	.LVL299:
1511:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 2330              		.loc 1 1511 0
 2331 0010 2046     		mov	r0, r4
 2332 0012 10BD     		pop	{r4, pc}
 2333              	.LVL300:
 2334              	.L422:
1502:Libraries/FreeRTOS/Source/queue.c **** 
 2335              		.loc 1 1502 0 discriminator 1
 2336 0014 FFF7FEFF 		bl	ulPortSetInterruptMask
 2337              	.LVL301:
 2338              	.L421:
 2339 0018 FEE7     		b	.L421
 2340              		.cfi_endproc
 2341              	.LFE134:
 2343 001a 00BF     		.section	.text.uxQueueSpacesAvailable,"ax",%progbits
 2344              		.align	2
 2345              		.global	uxQueueSpacesAvailable
 2346              		.thumb
 2347              		.thumb_func
 2349              	uxQueueSpacesAvailable:
 2350              	.LFB135:
1515:Libraries/FreeRTOS/Source/queue.c **** UBaseType_t uxReturn;
 2351              		.loc 1 1515 0
 2352              		.cfi_startproc
 2353              		@ args = 0, pretend = 0, frame = 0
 2354              		@ frame_needed = 0, uses_anonymous_args = 0
 2355              	.LVL302:
 2356 0000 10B5     		push	{r4, lr}
 2357              	.LCFI16:
 2358              		.cfi_def_cfa_offset 8
 2359              		.cfi_offset 4, -8
 2360              		.cfi_offset 14, -4
1520:Libraries/FreeRTOS/Source/queue.c **** 
 2361              		.loc 1 1520 0
 2362 0002 0446     		mov	r4, r0
 2363 0004 40B1     		cbz	r0, .L426
1522:Libraries/FreeRTOS/Source/queue.c **** 	{
 2364              		.loc 1 1522 0
 2365 0006 FFF7FEFF 		bl	vPortEnterCritical
 2366              	.LVL303:
1524:Libraries/FreeRTOS/Source/queue.c **** 	}
 2367              		.loc 1 1524 0
 2368 000a A36B     		ldr	r3, [r4, #56]
 2369 000c E46B     		ldr	r4, [r4, #60]
 2370              	.LVL304:
 2371 000e E41A     		subs	r4, r4, r3
 2372              	.LVL305:
1526:Libraries/FreeRTOS/Source/queue.c **** 
 2373              		.loc 1 1526 0
 2374 0010 FFF7FEFF 		bl	vPortExitCritical
 2375              	.LVL306:
1529:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 2376              		.loc 1 1529 0
 2377 0014 2046     		mov	r0, r4
 2378 0016 10BD     		pop	{r4, pc}
 2379              	.LVL307:
 2380              	.L426:
1520:Libraries/FreeRTOS/Source/queue.c **** 
 2381              		.loc 1 1520 0 discriminator 1
 2382 0018 FFF7FEFF 		bl	ulPortSetInterruptMask
 2383              	.LVL308:
 2384              	.L425:
 2385 001c FEE7     		b	.L425
 2386              		.cfi_endproc
 2387              	.LFE135:
 2389 001e 00BF     		.section	.text.uxQueueMessagesWaitingFromISR,"ax",%progbits
 2390              		.align	2
 2391              		.global	uxQueueMessagesWaitingFromISR
 2392              		.thumb
 2393              		.thumb_func
 2395              	uxQueueMessagesWaitingFromISR:
 2396              	.LFB136:
1533:Libraries/FreeRTOS/Source/queue.c **** UBaseType_t uxReturn;
 2397              		.loc 1 1533 0
 2398              		.cfi_startproc
 2399              		@ args = 0, pretend = 0, frame = 0
 2400              		@ frame_needed = 0, uses_anonymous_args = 0
 2401              	.LVL309:
 2402 0000 08B5     		push	{r3, lr}
 2403              	.LCFI17:
 2404              		.cfi_def_cfa_offset 8
 2405              		.cfi_offset 3, -8
 2406              		.cfi_offset 14, -4
1536:Libraries/FreeRTOS/Source/queue.c **** 
 2407              		.loc 1 1536 0
 2408 0002 08B1     		cbz	r0, .L430
1538:Libraries/FreeRTOS/Source/queue.c **** 
 2409              		.loc 1 1538 0
 2410 0004 806B     		ldr	r0, [r0, #56]
 2411              	.LVL310:
1541:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 2412              		.loc 1 1541 0
 2413 0006 08BD     		pop	{r3, pc}
 2414              	.LVL311:
 2415              	.L430:
1536:Libraries/FreeRTOS/Source/queue.c **** 
 2416              		.loc 1 1536 0 discriminator 1
 2417 0008 FFF7FEFF 		bl	ulPortSetInterruptMask
 2418              	.LVL312:
 2419              	.L429:
 2420 000c FEE7     		b	.L429
 2421              		.cfi_endproc
 2422              	.LFE136:
 2424 000e 00BF     		.section	.text.vQueueDelete,"ax",%progbits
 2425              		.align	2
 2426              		.global	vQueueDelete
 2427              		.thumb
 2428              		.thumb_func
 2430              	vQueueDelete:
 2431              	.LFB137:
1545:Libraries/FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 2432              		.loc 1 1545 0
 2433              		.cfi_startproc
 2434              		@ args = 0, pretend = 0, frame = 0
 2435              		@ frame_needed = 0, uses_anonymous_args = 0
 2436              	.LVL313:
 2437 0000 10B5     		push	{r4, lr}
 2438              	.LCFI18:
 2439              		.cfi_def_cfa_offset 8
 2440              		.cfi_offset 4, -8
 2441              		.cfi_offset 14, -4
1548:Libraries/FreeRTOS/Source/queue.c **** 
 2442              		.loc 1 1548 0
 2443 0002 0446     		mov	r4, r0
 2444 0004 80B3     		cbz	r0, .L447
 2445              	.LVL314:
 2446              	.LBB76:
 2447              	.LBB77:
1856:Libraries/FreeRTOS/Source/queue.c **** 
1857:Libraries/FreeRTOS/Source/queue.c **** 	return xReturn;
1858:Libraries/FreeRTOS/Source/queue.c **** }
1859:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1860:Libraries/FreeRTOS/Source/queue.c **** 
1861:Libraries/FreeRTOS/Source/queue.c **** BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
1862:Libraries/FreeRTOS/Source/queue.c **** {
1863:Libraries/FreeRTOS/Source/queue.c **** BaseType_t xReturn;
1864:Libraries/FreeRTOS/Source/queue.c **** 
1865:Libraries/FreeRTOS/Source/queue.c **** 	configASSERT( xQueue );
1866:Libraries/FreeRTOS/Source/queue.c **** 	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
1867:Libraries/FreeRTOS/Source/queue.c **** 	{
1868:Libraries/FreeRTOS/Source/queue.c **** 		xReturn = pdTRUE;
1869:Libraries/FreeRTOS/Source/queue.c **** 	}
1870:Libraries/FreeRTOS/Source/queue.c **** 	else
1871:Libraries/FreeRTOS/Source/queue.c **** 	{
1872:Libraries/FreeRTOS/Source/queue.c **** 		xReturn = pdFALSE;
1873:Libraries/FreeRTOS/Source/queue.c **** 	}
1874:Libraries/FreeRTOS/Source/queue.c **** 
1875:Libraries/FreeRTOS/Source/queue.c **** 	return xReturn;
1876:Libraries/FreeRTOS/Source/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
1877:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1878:Libraries/FreeRTOS/Source/queue.c **** 
1879:Libraries/FreeRTOS/Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
1880:Libraries/FreeRTOS/Source/queue.c **** 
1881:Libraries/FreeRTOS/Source/queue.c **** 	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait 
1882:Libraries/FreeRTOS/Source/queue.c **** 	{
1883:Libraries/FreeRTOS/Source/queue.c **** 	BaseType_t xReturn;
1884:Libraries/FreeRTOS/Source/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
1885:Libraries/FreeRTOS/Source/queue.c **** 
1886:Libraries/FreeRTOS/Source/queue.c **** 		/* If the queue is already full we may have to block.  A critical section
1887:Libraries/FreeRTOS/Source/queue.c **** 		is required to prevent an interrupt removing something from the queue
1888:Libraries/FreeRTOS/Source/queue.c **** 		between the check to see if the queue is full and blocking on the queue. */
1889:Libraries/FreeRTOS/Source/queue.c **** 		portDISABLE_INTERRUPTS();
1890:Libraries/FreeRTOS/Source/queue.c **** 		{
1891:Libraries/FreeRTOS/Source/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
1892:Libraries/FreeRTOS/Source/queue.c **** 			{
1893:Libraries/FreeRTOS/Source/queue.c **** 				/* The queue is full - do we want to block or just leave without
1894:Libraries/FreeRTOS/Source/queue.c **** 				posting? */
1895:Libraries/FreeRTOS/Source/queue.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
1896:Libraries/FreeRTOS/Source/queue.c **** 				{
1897:Libraries/FreeRTOS/Source/queue.c **** 					/* As this is called from a coroutine we cannot block directly, but
1898:Libraries/FreeRTOS/Source/queue.c **** 					return indicating that we need to block. */
1899:Libraries/FreeRTOS/Source/queue.c **** 					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
1900:Libraries/FreeRTOS/Source/queue.c **** 					portENABLE_INTERRUPTS();
1901:Libraries/FreeRTOS/Source/queue.c **** 					return errQUEUE_BLOCKED;
1902:Libraries/FreeRTOS/Source/queue.c **** 				}
1903:Libraries/FreeRTOS/Source/queue.c **** 				else
1904:Libraries/FreeRTOS/Source/queue.c **** 				{
1905:Libraries/FreeRTOS/Source/queue.c **** 					portENABLE_INTERRUPTS();
1906:Libraries/FreeRTOS/Source/queue.c **** 					return errQUEUE_FULL;
1907:Libraries/FreeRTOS/Source/queue.c **** 				}
1908:Libraries/FreeRTOS/Source/queue.c **** 			}
1909:Libraries/FreeRTOS/Source/queue.c **** 		}
1910:Libraries/FreeRTOS/Source/queue.c **** 		portENABLE_INTERRUPTS();
1911:Libraries/FreeRTOS/Source/queue.c **** 
1912:Libraries/FreeRTOS/Source/queue.c **** 		portDISABLE_INTERRUPTS();
1913:Libraries/FreeRTOS/Source/queue.c **** 		{
1914:Libraries/FreeRTOS/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
1915:Libraries/FreeRTOS/Source/queue.c **** 			{
1916:Libraries/FreeRTOS/Source/queue.c **** 				/* There is room in the queue, copy the data into the queue. */
1917:Libraries/FreeRTOS/Source/queue.c **** 				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
1918:Libraries/FreeRTOS/Source/queue.c **** 				xReturn = pdPASS;
1919:Libraries/FreeRTOS/Source/queue.c **** 
1920:Libraries/FreeRTOS/Source/queue.c **** 				/* Were any co-routines waiting for data to become available? */
1921:Libraries/FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1922:Libraries/FreeRTOS/Source/queue.c **** 				{
1923:Libraries/FreeRTOS/Source/queue.c **** 					/* In this instance the co-routine could be placed directly
1924:Libraries/FreeRTOS/Source/queue.c **** 					into the ready list as we are within a critical section.
1925:Libraries/FreeRTOS/Source/queue.c **** 					Instead the same pending ready list mechanism is used as if
1926:Libraries/FreeRTOS/Source/queue.c **** 					the event were caused from within an interrupt. */
1927:Libraries/FreeRTOS/Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1928:Libraries/FreeRTOS/Source/queue.c **** 					{
1929:Libraries/FreeRTOS/Source/queue.c **** 						/* The co-routine waiting has a higher priority so record
1930:Libraries/FreeRTOS/Source/queue.c **** 						that a yield might be appropriate. */
1931:Libraries/FreeRTOS/Source/queue.c **** 						xReturn = errQUEUE_YIELD;
1932:Libraries/FreeRTOS/Source/queue.c **** 					}
1933:Libraries/FreeRTOS/Source/queue.c **** 					else
1934:Libraries/FreeRTOS/Source/queue.c **** 					{
1935:Libraries/FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1936:Libraries/FreeRTOS/Source/queue.c **** 					}
1937:Libraries/FreeRTOS/Source/queue.c **** 				}
1938:Libraries/FreeRTOS/Source/queue.c **** 				else
1939:Libraries/FreeRTOS/Source/queue.c **** 				{
1940:Libraries/FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1941:Libraries/FreeRTOS/Source/queue.c **** 				}
1942:Libraries/FreeRTOS/Source/queue.c **** 			}
1943:Libraries/FreeRTOS/Source/queue.c **** 			else
1944:Libraries/FreeRTOS/Source/queue.c **** 			{
1945:Libraries/FreeRTOS/Source/queue.c **** 				xReturn = errQUEUE_FULL;
1946:Libraries/FreeRTOS/Source/queue.c **** 			}
1947:Libraries/FreeRTOS/Source/queue.c **** 		}
1948:Libraries/FreeRTOS/Source/queue.c **** 		portENABLE_INTERRUPTS();
1949:Libraries/FreeRTOS/Source/queue.c **** 
1950:Libraries/FreeRTOS/Source/queue.c **** 		return xReturn;
1951:Libraries/FreeRTOS/Source/queue.c **** 	}
1952:Libraries/FreeRTOS/Source/queue.c **** 
1953:Libraries/FreeRTOS/Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
1954:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1955:Libraries/FreeRTOS/Source/queue.c **** 
1956:Libraries/FreeRTOS/Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
1957:Libraries/FreeRTOS/Source/queue.c **** 
1958:Libraries/FreeRTOS/Source/queue.c **** 	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
1959:Libraries/FreeRTOS/Source/queue.c **** 	{
1960:Libraries/FreeRTOS/Source/queue.c **** 	BaseType_t xReturn;
1961:Libraries/FreeRTOS/Source/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
1962:Libraries/FreeRTOS/Source/queue.c **** 
1963:Libraries/FreeRTOS/Source/queue.c **** 		/* If the queue is already empty we may have to block.  A critical section
1964:Libraries/FreeRTOS/Source/queue.c **** 		is required to prevent an interrupt adding something to the queue
1965:Libraries/FreeRTOS/Source/queue.c **** 		between the check to see if the queue is empty and blocking on the queue. */
1966:Libraries/FreeRTOS/Source/queue.c **** 		portDISABLE_INTERRUPTS();
1967:Libraries/FreeRTOS/Source/queue.c **** 		{
1968:Libraries/FreeRTOS/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
1969:Libraries/FreeRTOS/Source/queue.c **** 			{
1970:Libraries/FreeRTOS/Source/queue.c **** 				/* There are no messages in the queue, do we want to block or just
1971:Libraries/FreeRTOS/Source/queue.c **** 				leave with nothing? */
1972:Libraries/FreeRTOS/Source/queue.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
1973:Libraries/FreeRTOS/Source/queue.c **** 				{
1974:Libraries/FreeRTOS/Source/queue.c **** 					/* As this is a co-routine we cannot block directly, but return
1975:Libraries/FreeRTOS/Source/queue.c **** 					indicating that we need to block. */
1976:Libraries/FreeRTOS/Source/queue.c **** 					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
1977:Libraries/FreeRTOS/Source/queue.c **** 					portENABLE_INTERRUPTS();
1978:Libraries/FreeRTOS/Source/queue.c **** 					return errQUEUE_BLOCKED;
1979:Libraries/FreeRTOS/Source/queue.c **** 				}
1980:Libraries/FreeRTOS/Source/queue.c **** 				else
1981:Libraries/FreeRTOS/Source/queue.c **** 				{
1982:Libraries/FreeRTOS/Source/queue.c **** 					portENABLE_INTERRUPTS();
1983:Libraries/FreeRTOS/Source/queue.c **** 					return errQUEUE_FULL;
1984:Libraries/FreeRTOS/Source/queue.c **** 				}
1985:Libraries/FreeRTOS/Source/queue.c **** 			}
1986:Libraries/FreeRTOS/Source/queue.c **** 			else
1987:Libraries/FreeRTOS/Source/queue.c **** 			{
1988:Libraries/FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1989:Libraries/FreeRTOS/Source/queue.c **** 			}
1990:Libraries/FreeRTOS/Source/queue.c **** 		}
1991:Libraries/FreeRTOS/Source/queue.c **** 		portENABLE_INTERRUPTS();
1992:Libraries/FreeRTOS/Source/queue.c **** 
1993:Libraries/FreeRTOS/Source/queue.c **** 		portDISABLE_INTERRUPTS();
1994:Libraries/FreeRTOS/Source/queue.c **** 		{
1995:Libraries/FreeRTOS/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
1996:Libraries/FreeRTOS/Source/queue.c **** 			{
1997:Libraries/FreeRTOS/Source/queue.c **** 				/* Data is available from the queue. */
1998:Libraries/FreeRTOS/Source/queue.c **** 				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
1999:Libraries/FreeRTOS/Source/queue.c **** 				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
2000:Libraries/FreeRTOS/Source/queue.c **** 				{
2001:Libraries/FreeRTOS/Source/queue.c **** 					pxQueue->u.pcReadFrom = pxQueue->pcHead;
2002:Libraries/FreeRTOS/Source/queue.c **** 				}
2003:Libraries/FreeRTOS/Source/queue.c **** 				else
2004:Libraries/FreeRTOS/Source/queue.c **** 				{
2005:Libraries/FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2006:Libraries/FreeRTOS/Source/queue.c **** 				}
2007:Libraries/FreeRTOS/Source/queue.c **** 				--( pxQueue->uxMessagesWaiting );
2008:Libraries/FreeRTOS/Source/queue.c **** 				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->u
2009:Libraries/FreeRTOS/Source/queue.c **** 
2010:Libraries/FreeRTOS/Source/queue.c **** 				xReturn = pdPASS;
2011:Libraries/FreeRTOS/Source/queue.c **** 
2012:Libraries/FreeRTOS/Source/queue.c **** 				/* Were any co-routines waiting for space to become available? */
2013:Libraries/FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2014:Libraries/FreeRTOS/Source/queue.c **** 				{
2015:Libraries/FreeRTOS/Source/queue.c **** 					/* In this instance the co-routine could be placed directly
2016:Libraries/FreeRTOS/Source/queue.c **** 					into the ready list as we are within a critical section.
2017:Libraries/FreeRTOS/Source/queue.c **** 					Instead the same pending ready list mechanism is used as if
2018:Libraries/FreeRTOS/Source/queue.c **** 					the event were caused from within an interrupt. */
2019:Libraries/FreeRTOS/Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
2020:Libraries/FreeRTOS/Source/queue.c **** 					{
2021:Libraries/FreeRTOS/Source/queue.c **** 						xReturn = errQUEUE_YIELD;
2022:Libraries/FreeRTOS/Source/queue.c **** 					}
2023:Libraries/FreeRTOS/Source/queue.c **** 					else
2024:Libraries/FreeRTOS/Source/queue.c **** 					{
2025:Libraries/FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2026:Libraries/FreeRTOS/Source/queue.c **** 					}
2027:Libraries/FreeRTOS/Source/queue.c **** 				}
2028:Libraries/FreeRTOS/Source/queue.c **** 				else
2029:Libraries/FreeRTOS/Source/queue.c **** 				{
2030:Libraries/FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2031:Libraries/FreeRTOS/Source/queue.c **** 				}
2032:Libraries/FreeRTOS/Source/queue.c **** 			}
2033:Libraries/FreeRTOS/Source/queue.c **** 			else
2034:Libraries/FreeRTOS/Source/queue.c **** 			{
2035:Libraries/FreeRTOS/Source/queue.c **** 				xReturn = pdFAIL;
2036:Libraries/FreeRTOS/Source/queue.c **** 			}
2037:Libraries/FreeRTOS/Source/queue.c **** 		}
2038:Libraries/FreeRTOS/Source/queue.c **** 		portENABLE_INTERRUPTS();
2039:Libraries/FreeRTOS/Source/queue.c **** 
2040:Libraries/FreeRTOS/Source/queue.c **** 		return xReturn;
2041:Libraries/FreeRTOS/Source/queue.c **** 	}
2042:Libraries/FreeRTOS/Source/queue.c **** 
2043:Libraries/FreeRTOS/Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2044:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2045:Libraries/FreeRTOS/Source/queue.c **** 
2046:Libraries/FreeRTOS/Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2047:Libraries/FreeRTOS/Source/queue.c **** 
2048:Libraries/FreeRTOS/Source/queue.c **** 	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRou
2049:Libraries/FreeRTOS/Source/queue.c **** 	{
2050:Libraries/FreeRTOS/Source/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2051:Libraries/FreeRTOS/Source/queue.c **** 
2052:Libraries/FreeRTOS/Source/queue.c **** 		/* Cannot block within an ISR so if there is no space on the queue then
2053:Libraries/FreeRTOS/Source/queue.c **** 		exit without doing anything. */
2054:Libraries/FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
2055:Libraries/FreeRTOS/Source/queue.c **** 		{
2056:Libraries/FreeRTOS/Source/queue.c **** 			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
2057:Libraries/FreeRTOS/Source/queue.c **** 
2058:Libraries/FreeRTOS/Source/queue.c **** 			/* We only want to wake one co-routine per ISR, so check that a
2059:Libraries/FreeRTOS/Source/queue.c **** 			co-routine has not already been woken. */
2060:Libraries/FreeRTOS/Source/queue.c **** 			if( xCoRoutinePreviouslyWoken == pdFALSE )
2061:Libraries/FreeRTOS/Source/queue.c **** 			{
2062:Libraries/FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2063:Libraries/FreeRTOS/Source/queue.c **** 				{
2064:Libraries/FreeRTOS/Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
2065:Libraries/FreeRTOS/Source/queue.c **** 					{
2066:Libraries/FreeRTOS/Source/queue.c **** 						return pdTRUE;
2067:Libraries/FreeRTOS/Source/queue.c **** 					}
2068:Libraries/FreeRTOS/Source/queue.c **** 					else
2069:Libraries/FreeRTOS/Source/queue.c **** 					{
2070:Libraries/FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2071:Libraries/FreeRTOS/Source/queue.c **** 					}
2072:Libraries/FreeRTOS/Source/queue.c **** 				}
2073:Libraries/FreeRTOS/Source/queue.c **** 				else
2074:Libraries/FreeRTOS/Source/queue.c **** 				{
2075:Libraries/FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2076:Libraries/FreeRTOS/Source/queue.c **** 				}
2077:Libraries/FreeRTOS/Source/queue.c **** 			}
2078:Libraries/FreeRTOS/Source/queue.c **** 			else
2079:Libraries/FreeRTOS/Source/queue.c **** 			{
2080:Libraries/FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2081:Libraries/FreeRTOS/Source/queue.c **** 			}
2082:Libraries/FreeRTOS/Source/queue.c **** 		}
2083:Libraries/FreeRTOS/Source/queue.c **** 		else
2084:Libraries/FreeRTOS/Source/queue.c **** 		{
2085:Libraries/FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2086:Libraries/FreeRTOS/Source/queue.c **** 		}
2087:Libraries/FreeRTOS/Source/queue.c **** 
2088:Libraries/FreeRTOS/Source/queue.c **** 		return xCoRoutinePreviouslyWoken;
2089:Libraries/FreeRTOS/Source/queue.c **** 	}
2090:Libraries/FreeRTOS/Source/queue.c **** 
2091:Libraries/FreeRTOS/Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2092:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2093:Libraries/FreeRTOS/Source/queue.c **** 
2094:Libraries/FreeRTOS/Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2095:Libraries/FreeRTOS/Source/queue.c **** 
2096:Libraries/FreeRTOS/Source/queue.c **** 	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWo
2097:Libraries/FreeRTOS/Source/queue.c **** 	{
2098:Libraries/FreeRTOS/Source/queue.c **** 	BaseType_t xReturn;
2099:Libraries/FreeRTOS/Source/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2100:Libraries/FreeRTOS/Source/queue.c **** 
2101:Libraries/FreeRTOS/Source/queue.c **** 		/* We cannot block from an ISR, so check there is data available. If
2102:Libraries/FreeRTOS/Source/queue.c **** 		not then just leave without doing anything. */
2103:Libraries/FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
2104:Libraries/FreeRTOS/Source/queue.c **** 		{
2105:Libraries/FreeRTOS/Source/queue.c **** 			/* Copy the data from the queue. */
2106:Libraries/FreeRTOS/Source/queue.c **** 			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
2107:Libraries/FreeRTOS/Source/queue.c **** 			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
2108:Libraries/FreeRTOS/Source/queue.c **** 			{
2109:Libraries/FreeRTOS/Source/queue.c **** 				pxQueue->u.pcReadFrom = pxQueue->pcHead;
2110:Libraries/FreeRTOS/Source/queue.c **** 			}
2111:Libraries/FreeRTOS/Source/queue.c **** 			else
2112:Libraries/FreeRTOS/Source/queue.c **** 			{
2113:Libraries/FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2114:Libraries/FreeRTOS/Source/queue.c **** 			}
2115:Libraries/FreeRTOS/Source/queue.c **** 			--( pxQueue->uxMessagesWaiting );
2116:Libraries/FreeRTOS/Source/queue.c **** 			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->ux
2117:Libraries/FreeRTOS/Source/queue.c **** 
2118:Libraries/FreeRTOS/Source/queue.c **** 			if( ( *pxCoRoutineWoken ) == pdFALSE )
2119:Libraries/FreeRTOS/Source/queue.c **** 			{
2120:Libraries/FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2121:Libraries/FreeRTOS/Source/queue.c **** 				{
2122:Libraries/FreeRTOS/Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
2123:Libraries/FreeRTOS/Source/queue.c **** 					{
2124:Libraries/FreeRTOS/Source/queue.c **** 						*pxCoRoutineWoken = pdTRUE;
2125:Libraries/FreeRTOS/Source/queue.c **** 					}
2126:Libraries/FreeRTOS/Source/queue.c **** 					else
2127:Libraries/FreeRTOS/Source/queue.c **** 					{
2128:Libraries/FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2129:Libraries/FreeRTOS/Source/queue.c **** 					}
2130:Libraries/FreeRTOS/Source/queue.c **** 				}
2131:Libraries/FreeRTOS/Source/queue.c **** 				else
2132:Libraries/FreeRTOS/Source/queue.c **** 				{
2133:Libraries/FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2134:Libraries/FreeRTOS/Source/queue.c **** 				}
2135:Libraries/FreeRTOS/Source/queue.c **** 			}
2136:Libraries/FreeRTOS/Source/queue.c **** 			else
2137:Libraries/FreeRTOS/Source/queue.c **** 			{
2138:Libraries/FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2139:Libraries/FreeRTOS/Source/queue.c **** 			}
2140:Libraries/FreeRTOS/Source/queue.c **** 
2141:Libraries/FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
2142:Libraries/FreeRTOS/Source/queue.c **** 		}
2143:Libraries/FreeRTOS/Source/queue.c **** 		else
2144:Libraries/FreeRTOS/Source/queue.c **** 		{
2145:Libraries/FreeRTOS/Source/queue.c **** 			xReturn = pdFAIL;
2146:Libraries/FreeRTOS/Source/queue.c **** 		}
2147:Libraries/FreeRTOS/Source/queue.c **** 
2148:Libraries/FreeRTOS/Source/queue.c **** 		return xReturn;
2149:Libraries/FreeRTOS/Source/queue.c **** 	}
2150:Libraries/FreeRTOS/Source/queue.c **** 
2151:Libraries/FreeRTOS/Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2152:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2153:Libraries/FreeRTOS/Source/queue.c **** 
2154:Libraries/FreeRTOS/Source/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
2155:Libraries/FreeRTOS/Source/queue.c **** 
2156:Libraries/FreeRTOS/Source/queue.c **** 	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified
2157:Libraries/FreeRTOS/Source/queue.c **** 	{
2158:Libraries/FreeRTOS/Source/queue.c **** 	UBaseType_t ux;
2159:Libraries/FreeRTOS/Source/queue.c **** 
2160:Libraries/FreeRTOS/Source/queue.c **** 		/* See if there is an empty space in the registry.  A NULL name denotes
2161:Libraries/FreeRTOS/Source/queue.c **** 		a free slot. */
2162:Libraries/FreeRTOS/Source/queue.c **** 		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
2163:Libraries/FreeRTOS/Source/queue.c **** 		{
2164:Libraries/FreeRTOS/Source/queue.c **** 			if( xQueueRegistry[ ux ].pcQueueName == NULL )
2165:Libraries/FreeRTOS/Source/queue.c **** 			{
2166:Libraries/FreeRTOS/Source/queue.c **** 				/* Store the information on this queue. */
2167:Libraries/FreeRTOS/Source/queue.c **** 				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
2168:Libraries/FreeRTOS/Source/queue.c **** 				xQueueRegistry[ ux ].xHandle = xQueue;
2169:Libraries/FreeRTOS/Source/queue.c **** 
2170:Libraries/FreeRTOS/Source/queue.c **** 				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
2171:Libraries/FreeRTOS/Source/queue.c **** 				break;
2172:Libraries/FreeRTOS/Source/queue.c **** 			}
2173:Libraries/FreeRTOS/Source/queue.c **** 			else
2174:Libraries/FreeRTOS/Source/queue.c **** 			{
2175:Libraries/FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2176:Libraries/FreeRTOS/Source/queue.c **** 			}
2177:Libraries/FreeRTOS/Source/queue.c **** 		}
2178:Libraries/FreeRTOS/Source/queue.c **** 	}
2179:Libraries/FreeRTOS/Source/queue.c **** 
2180:Libraries/FreeRTOS/Source/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
2181:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2182:Libraries/FreeRTOS/Source/queue.c **** 
2183:Libraries/FreeRTOS/Source/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
2184:Libraries/FreeRTOS/Source/queue.c **** 
2185:Libraries/FreeRTOS/Source/queue.c **** 	void vQueueUnregisterQueue( QueueHandle_t xQueue )
2186:Libraries/FreeRTOS/Source/queue.c **** 	{
2187:Libraries/FreeRTOS/Source/queue.c **** 	UBaseType_t ux;
2188:Libraries/FreeRTOS/Source/queue.c **** 
2189:Libraries/FreeRTOS/Source/queue.c **** 		/* See if the handle of the queue being unregistered in actually in the
2190:Libraries/FreeRTOS/Source/queue.c **** 		registry. */
2191:Libraries/FreeRTOS/Source/queue.c **** 		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
2192:Libraries/FreeRTOS/Source/queue.c **** 		{
2193:Libraries/FreeRTOS/Source/queue.c **** 			if( xQueueRegistry[ ux ].xHandle == xQueue )
 2448              		.loc 1 2193 0
 2449 0006 40F20003 		movw	r3, #:lower16:xQueueRegistry
 2450 000a C0F20003 		movt	r3, #:upper16:xQueueRegistry
 2451 000e 5A68     		ldr	r2, [r3, #4]
 2452 0010 9042     		cmp	r0, r2
 2453 0012 2CD0     		beq	.L437
 2454              	.LVL315:
 2455 0014 DA68     		ldr	r2, [r3, #12]
 2456 0016 9042     		cmp	r0, r2
 2457 0018 2ED0     		beq	.L438
 2458              	.LVL316:
 2459 001a 5A69     		ldr	r2, [r3, #20]
 2460 001c 9042     		cmp	r0, r2
 2461 001e 30D0     		beq	.L439
 2462              	.LVL317:
 2463 0020 DA69     		ldr	r2, [r3, #28]
 2464 0022 9042     		cmp	r0, r2
 2465 0024 1BD0     		beq	.L440
 2466              	.LVL318:
 2467 0026 5A6A     		ldr	r2, [r3, #36]
 2468 0028 9042     		cmp	r0, r2
 2469 002a 31D0     		beq	.L441
 2470              	.LVL319:
 2471 002c DA6A     		ldr	r2, [r3, #44]
 2472 002e 9042     		cmp	r0, r2
 2473 0030 2CD0     		beq	.L442
 2474              	.LVL320:
 2475 0032 5A6B     		ldr	r2, [r3, #52]
 2476 0034 9042     		cmp	r0, r2
 2477 0036 0DD0     		beq	.L443
 2478              	.LVL321:
 2479 0038 DA6B     		ldr	r2, [r3, #60]
 2480 003a 9042     		cmp	r0, r2
2191:Libraries/FreeRTOS/Source/queue.c **** 		{
 2481              		.loc 1 2191 0
 2482 003c 08BF     		it	eq
 2483 003e 0722     		moveq	r2, #7
 2484              		.loc 1 2193 0
 2485 0040 09D0     		beq	.L434
 2486              	.LVL322:
 2487              	.L435:
 2488              	.LBE77:
 2489              	.LBE76:
1556:Libraries/FreeRTOS/Source/queue.c **** 	{
 2490              		.loc 1 1556 0
 2491 0042 2068     		ldr	r0, [r4]
 2492              	.LVL323:
 2493 0044 08B1     		cbz	r0, .L436
1558:Libraries/FreeRTOS/Source/queue.c **** 	}
 2494              		.loc 1 1558 0
 2495 0046 FFF7FEFF 		bl	vPortFree
 2496              	.LVL324:
 2497              	.L436:
1560:Libraries/FreeRTOS/Source/queue.c **** }
 2498              		.loc 1 1560 0
 2499 004a 2046     		mov	r0, r4
1561:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 2500              		.loc 1 1561 0
 2501 004c BDE81040 		pop	{r4, lr}
 2502              	.LVL325:
1560:Libraries/FreeRTOS/Source/queue.c **** }
 2503              		.loc 1 1560 0
 2504 0050 FFF7FEBF 		b	vPortFree
 2505              	.LVL326:
 2506              	.L443:
 2507              	.LBB80:
 2508              	.LBB78:
2191:Libraries/FreeRTOS/Source/queue.c **** 		{
 2509              		.loc 1 2191 0
 2510 0054 0622     		movs	r2, #6
 2511              	.LVL327:
 2512              	.L434:
2194:Libraries/FreeRTOS/Source/queue.c **** 			{
2195:Libraries/FreeRTOS/Source/queue.c **** 				/* Set the name to NULL to show that this slot if free again. */
2196:Libraries/FreeRTOS/Source/queue.c **** 				xQueueRegistry[ ux ].pcQueueName = NULL;
 2513              		.loc 1 2196 0
 2514 0056 0021     		movs	r1, #0
 2515 0058 43F83210 		str	r1, [r3, r2, lsl #3]
 2516 005c F1E7     		b	.L435
 2517              	.LVL328:
 2518              	.L440:
2191:Libraries/FreeRTOS/Source/queue.c **** 		{
 2519              		.loc 1 2191 0
 2520 005e 0322     		movs	r2, #3
 2521              		.loc 1 2196 0
 2522 0060 0021     		movs	r1, #0
 2523 0062 43F83210 		str	r1, [r3, r2, lsl #3]
 2524 0066 ECE7     		b	.L435
 2525              	.LVL329:
 2526              	.L447:
 2527              	.LBE78:
 2528              	.LBE80:
1548:Libraries/FreeRTOS/Source/queue.c **** 
 2529              		.loc 1 1548 0 discriminator 1
 2530 0068 FFF7FEFF 		bl	ulPortSetInterruptMask
 2531              	.LVL330:
 2532              	.L433:
 2533 006c FEE7     		b	.L433
 2534              	.LVL331:
 2535              	.L437:
 2536              	.LBB81:
 2537              	.LBB79:
2193:Libraries/FreeRTOS/Source/queue.c **** 			{
 2538              		.loc 1 2193 0
 2539 006e 0022     		movs	r2, #0
 2540              		.loc 1 2196 0
 2541 0070 0021     		movs	r1, #0
 2542 0072 43F83210 		str	r1, [r3, r2, lsl #3]
 2543 0076 E4E7     		b	.L435
 2544              	.LVL332:
 2545              	.L438:
2191:Libraries/FreeRTOS/Source/queue.c **** 		{
 2546              		.loc 1 2191 0
 2547 0078 0122     		movs	r2, #1
 2548              		.loc 1 2196 0
 2549 007a 0021     		movs	r1, #0
 2550 007c 43F83210 		str	r1, [r3, r2, lsl #3]
 2551 0080 DFE7     		b	.L435
 2552              	.LVL333:
 2553              	.L439:
2191:Libraries/FreeRTOS/Source/queue.c **** 		{
 2554              		.loc 1 2191 0
 2555 0082 0222     		movs	r2, #2
 2556              		.loc 1 2196 0
 2557 0084 0021     		movs	r1, #0
 2558 0086 43F83210 		str	r1, [r3, r2, lsl #3]
 2559 008a DAE7     		b	.L435
 2560              	.LVL334:
 2561              	.L442:
2191:Libraries/FreeRTOS/Source/queue.c **** 		{
 2562              		.loc 1 2191 0
 2563 008c 0522     		movs	r2, #5
 2564 008e E2E7     		b	.L434
 2565              	.LVL335:
 2566              	.L441:
 2567 0090 0422     		movs	r2, #4
 2568 0092 E0E7     		b	.L434
 2569              	.LBE79:
 2570              	.LBE81:
 2571              		.cfi_endproc
 2572              	.LFE137:
 2574              		.section	.text.xQueueIsQueueEmptyFromISR,"ax",%progbits
 2575              		.align	2
 2576              		.global	xQueueIsQueueEmptyFromISR
 2577              		.thumb
 2578              		.thumb_func
 2580              	xQueueIsQueueEmptyFromISR:
 2581              	.LFB142:
1823:Libraries/FreeRTOS/Source/queue.c **** BaseType_t xReturn;
 2582              		.loc 1 1823 0
 2583              		.cfi_startproc
 2584              		@ args = 0, pretend = 0, frame = 0
 2585              		@ frame_needed = 0, uses_anonymous_args = 0
 2586              	.LVL336:
 2587 0000 08B5     		push	{r3, lr}
 2588              	.LCFI19:
 2589              		.cfi_def_cfa_offset 8
 2590              		.cfi_offset 3, -8
 2591              		.cfi_offset 14, -4
1826:Libraries/FreeRTOS/Source/queue.c **** 	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
 2592              		.loc 1 1826 0
 2593 0002 28B1     		cbz	r0, .L451
1827:Libraries/FreeRTOS/Source/queue.c **** 	{
 2594              		.loc 1 1827 0
 2595 0004 806B     		ldr	r0, [r0, #56]
 2596              	.LVL337:
1837:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 2597              		.loc 1 1837 0
 2598 0006 D0F10100 		rsbs	r0, r0, #1
 2599              	.LVL338:
 2600 000a 38BF     		it	cc
 2601 000c 0020     		movcc	r0, #0
 2602 000e 08BD     		pop	{r3, pc}
 2603              	.LVL339:
 2604              	.L451:
1826:Libraries/FreeRTOS/Source/queue.c **** 	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
 2605              		.loc 1 1826 0 discriminator 1
 2606 0010 FFF7FEFF 		bl	ulPortSetInterruptMask
 2607              	.LVL340:
 2608              	.L450:
 2609 0014 FEE7     		b	.L450
 2610              		.cfi_endproc
 2611              	.LFE142:
 2613 0016 00BF     		.section	.text.xQueueIsQueueFullFromISR,"ax",%progbits
 2614              		.align	2
 2615              		.global	xQueueIsQueueFullFromISR
 2616              		.thumb
 2617              		.thumb_func
 2619              	xQueueIsQueueFullFromISR:
 2620              	.LFB144:
1862:Libraries/FreeRTOS/Source/queue.c **** BaseType_t xReturn;
 2621              		.loc 1 1862 0
 2622              		.cfi_startproc
 2623              		@ args = 0, pretend = 0, frame = 0
 2624              		@ frame_needed = 0, uses_anonymous_args = 0
 2625              	.LVL341:
 2626 0000 08B5     		push	{r3, lr}
 2627              	.LCFI20:
 2628              		.cfi_def_cfa_offset 8
 2629              		.cfi_offset 3, -8
 2630              		.cfi_offset 14, -4
1865:Libraries/FreeRTOS/Source/queue.c **** 	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
 2631              		.loc 1 1865 0
 2632 0002 28B1     		cbz	r0, .L455
1866:Libraries/FreeRTOS/Source/queue.c **** 	{
 2633              		.loc 1 1866 0
 2634 0004 826B     		ldr	r2, [r0, #56]
 2635              	.LVL342:
 2636 0006 C06B     		ldr	r0, [r0, #60]
 2637              	.LVL343:
1876:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 2638              		.loc 1 1876 0
 2639 0008 131A     		subs	r3, r2, r0
 2640 000a 5842     		rsbs	r0, r3, #0
 2641              	.LVL344:
 2642 000c 5841     		adcs	r0, r0, r3
 2643 000e 08BD     		pop	{r3, pc}
 2644              	.LVL345:
 2645              	.L455:
1865:Libraries/FreeRTOS/Source/queue.c **** 	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
 2646              		.loc 1 1865 0 discriminator 1
 2647 0010 FFF7FEFF 		bl	ulPortSetInterruptMask
 2648              	.LVL346:
 2649              	.L454:
 2650 0014 FEE7     		b	.L454
 2651              		.cfi_endproc
 2652              	.LFE144:
 2654 0016 00BF     		.section	.text.vQueueAddToRegistry,"ax",%progbits
 2655              		.align	2
 2656              		.global	vQueueAddToRegistry
 2657              		.thumb
 2658              		.thumb_func
 2660              	vQueueAddToRegistry:
 2661              	.LFB145:
2157:Libraries/FreeRTOS/Source/queue.c **** 	UBaseType_t ux;
 2662              		.loc 1 2157 0
 2663              		.cfi_startproc
 2664              		@ args = 0, pretend = 0, frame = 0
 2665              		@ frame_needed = 0, uses_anonymous_args = 0
 2666              		@ link register save eliminated.
 2667              	.LVL347:
2164:Libraries/FreeRTOS/Source/queue.c **** 			{
 2668              		.loc 1 2164 0
 2669 0000 40F20003 		movw	r3, #:lower16:xQueueRegistry
 2670 0004 C0F20003 		movt	r3, #:upper16:xQueueRegistry
2157:Libraries/FreeRTOS/Source/queue.c **** 	UBaseType_t ux;
 2671              		.loc 1 2157 0
 2672 0008 10B4     		push	{r4}
 2673              	.LCFI21:
 2674              		.cfi_def_cfa_offset 4
 2675              		.cfi_offset 4, -4
2164:Libraries/FreeRTOS/Source/queue.c **** 			{
 2676              		.loc 1 2164 0
 2677 000a 1A68     		ldr	r2, [r3]
 2678 000c 8AB1     		cbz	r2, .L457
 2679              	.LVL348:
 2680 000e 9A68     		ldr	r2, [r3, #8]
 2681 0010 BAB1     		cbz	r2, .L460
 2682              	.LVL349:
 2683 0012 1A69     		ldr	r2, [r3, #16]
 2684 0014 BAB1     		cbz	r2, .L461
 2685              	.LVL350:
 2686 0016 9A69     		ldr	r2, [r3, #24]
 2687 0018 BAB1     		cbz	r2, .L462
 2688              	.LVL351:
 2689 001a 1A6A     		ldr	r2, [r3, #32]
 2690 001c BAB1     		cbz	r2, .L463
 2691              	.LVL352:
 2692 001e 9A6A     		ldr	r2, [r3, #40]
 2693 0020 BAB1     		cbz	r2, .L464
 2694              	.LVL353:
 2695 0022 1A6B     		ldr	r2, [r3, #48]
 2696 0024 22B1     		cbz	r2, .L465
 2697              	.LVL354:
 2698 0026 9A6B     		ldr	r2, [r3, #56]
 2699 0028 AAB1     		cbz	r2, .L466
2178:Libraries/FreeRTOS/Source/queue.c **** 
 2700              		.loc 1 2178 0
 2701 002a 5DF8044B 		ldr	r4, [sp], #4
 2702 002e 7047     		bx	lr
 2703              	.LVL355:
 2704              	.L465:
2162:Libraries/FreeRTOS/Source/queue.c **** 		{
 2705              		.loc 1 2162 0
 2706 0030 0622     		movs	r2, #6
 2707              	.LVL356:
 2708              	.L457:
2168:Libraries/FreeRTOS/Source/queue.c **** 
 2709              		.loc 1 2168 0
 2710 0032 03EBC204 		add	r4, r3, r2, lsl #3
2167:Libraries/FreeRTOS/Source/queue.c **** 				xQueueRegistry[ ux ].xHandle = xQueue;
 2711              		.loc 1 2167 0
 2712 0036 43F83210 		str	r1, [r3, r2, lsl #3]
2168:Libraries/FreeRTOS/Source/queue.c **** 
 2713              		.loc 1 2168 0
 2714 003a 6060     		str	r0, [r4, #4]
2178:Libraries/FreeRTOS/Source/queue.c **** 
 2715              		.loc 1 2178 0
 2716 003c 5DF8044B 		ldr	r4, [sp], #4
 2717 0040 7047     		bx	lr
 2718              	.LVL357:
 2719              	.L460:
2162:Libraries/FreeRTOS/Source/queue.c **** 		{
 2720              		.loc 1 2162 0
 2721 0042 0122     		movs	r2, #1
 2722 0044 F5E7     		b	.L457
 2723              	.LVL358:
 2724              	.L461:
 2725 0046 0222     		movs	r2, #2
 2726 0048 F3E7     		b	.L457
 2727              	.LVL359:
 2728              	.L462:
 2729 004a 0322     		movs	r2, #3
 2730 004c F1E7     		b	.L457
 2731              	.LVL360:
 2732              	.L463:
 2733 004e 0422     		movs	r2, #4
 2734 0050 EFE7     		b	.L457
 2735              	.LVL361:
 2736              	.L464:
 2737 0052 0522     		movs	r2, #5
 2738 0054 EDE7     		b	.L457
 2739              	.LVL362:
 2740              	.L466:
 2741 0056 0722     		movs	r2, #7
 2742 0058 EBE7     		b	.L457
 2743              		.cfi_endproc
 2744              	.LFE145:
 2746 005a 00BF     		.section	.text.vQueueUnregisterQueue,"ax",%progbits
 2747              		.align	2
 2748              		.global	vQueueUnregisterQueue
 2749              		.thumb
 2750              		.thumb_func
 2752              	vQueueUnregisterQueue:
 2753              	.LFB146:
2186:Libraries/FreeRTOS/Source/queue.c **** 	UBaseType_t ux;
 2754              		.loc 1 2186 0
 2755              		.cfi_startproc
 2756              		@ args = 0, pretend = 0, frame = 0
 2757              		@ frame_needed = 0, uses_anonymous_args = 0
 2758              		@ link register save eliminated.
 2759              	.LVL363:
2193:Libraries/FreeRTOS/Source/queue.c **** 			{
 2760              		.loc 1 2193 0
 2761 0000 40F20003 		movw	r3, #:lower16:xQueueRegistry
 2762 0004 C0F20003 		movt	r3, #:upper16:xQueueRegistry
 2763 0008 5A68     		ldr	r2, [r3, #4]
 2764 000a 8242     		cmp	r2, r0
 2765 000c 1CD0     		beq	.L470
 2766              	.LVL364:
 2767 000e DA68     		ldr	r2, [r3, #12]
 2768 0010 8242     		cmp	r2, r0
 2769 0012 1BD0     		beq	.L471
 2770              	.LVL365:
 2771 0014 5A69     		ldr	r2, [r3, #20]
 2772 0016 8242     		cmp	r2, r0
 2773 0018 1AD0     		beq	.L472
 2774              	.LVL366:
 2775 001a DA69     		ldr	r2, [r3, #28]
 2776 001c 8242     		cmp	r2, r0
 2777 001e 19D0     		beq	.L473
 2778              	.LVL367:
 2779 0020 5A6A     		ldr	r2, [r3, #36]
 2780 0022 8242     		cmp	r2, r0
 2781 0024 18D0     		beq	.L474
 2782              	.LVL368:
 2783 0026 DA6A     		ldr	r2, [r3, #44]
 2784 0028 8242     		cmp	r2, r0
 2785 002a 17D0     		beq	.L475
 2786              	.LVL369:
 2787 002c 5A6B     		ldr	r2, [r3, #52]
 2788 002e 8242     		cmp	r2, r0
 2789 0030 05D0     		beq	.L476
 2790              	.LVL370:
 2791 0032 DA6B     		ldr	r2, [r3, #60]
 2792 0034 8242     		cmp	r2, r0
2191:Libraries/FreeRTOS/Source/queue.c **** 		{
 2793              		.loc 1 2191 0
 2794 0036 08BF     		it	eq
 2795 0038 0722     		moveq	r2, #7
2193:Libraries/FreeRTOS/Source/queue.c **** 			{
 2796              		.loc 1 2193 0
 2797 003a 01D0     		beq	.L468
 2798 003c 7047     		bx	lr
 2799              	.LVL371:
 2800              	.L476:
2191:Libraries/FreeRTOS/Source/queue.c **** 		{
 2801              		.loc 1 2191 0
 2802 003e 0622     		movs	r2, #6
 2803              	.LVL372:
 2804              	.L468:
 2805              		.loc 1 2196 0
 2806 0040 0021     		movs	r1, #0
 2807 0042 43F83210 		str	r1, [r3, r2, lsl #3]
 2808 0046 7047     		bx	lr
 2809              	.LVL373:
 2810              	.L470:
2191:Libraries/FreeRTOS/Source/queue.c **** 		{
 2811              		.loc 1 2191 0
 2812 0048 0022     		movs	r2, #0
 2813 004a F9E7     		b	.L468
 2814              	.LVL374:
 2815              	.L471:
 2816 004c 0122     		movs	r2, #1
 2817 004e F7E7     		b	.L468
 2818              	.LVL375:
 2819              	.L472:
 2820 0050 0222     		movs	r2, #2
 2821 0052 F5E7     		b	.L468
 2822              	.LVL376:
 2823              	.L473:
 2824 0054 0322     		movs	r2, #3
 2825 0056 F3E7     		b	.L468
 2826              	.LVL377:
 2827              	.L474:
 2828 0058 0422     		movs	r2, #4
 2829 005a F1E7     		b	.L468
 2830              	.LVL378:
 2831              	.L475:
 2832 005c 0522     		movs	r2, #5
 2833 005e EFE7     		b	.L468
 2834              		.cfi_endproc
 2835              	.LFE146:
 2837              		.section	.text.vQueueWaitForMessageRestricted,"ax",%progbits
 2838              		.align	2
 2839              		.global	vQueueWaitForMessageRestricted
 2840              		.thumb
 2841              		.thumb_func
 2843              	vQueueWaitForMessageRestricted:
 2844              	.LFB147:
2197:Libraries/FreeRTOS/Source/queue.c **** 				break;
2198:Libraries/FreeRTOS/Source/queue.c **** 			}
2199:Libraries/FreeRTOS/Source/queue.c **** 			else
2200:Libraries/FreeRTOS/Source/queue.c **** 			{
2201:Libraries/FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2202:Libraries/FreeRTOS/Source/queue.c **** 			}
2203:Libraries/FreeRTOS/Source/queue.c **** 		}
2204:Libraries/FreeRTOS/Source/queue.c **** 
2205:Libraries/FreeRTOS/Source/queue.c **** 	} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
2206:Libraries/FreeRTOS/Source/queue.c **** 
2207:Libraries/FreeRTOS/Source/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
2208:Libraries/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2209:Libraries/FreeRTOS/Source/queue.c **** 
2210:Libraries/FreeRTOS/Source/queue.c **** #if ( configUSE_TIMERS == 1 )
2211:Libraries/FreeRTOS/Source/queue.c **** 
2212:Libraries/FreeRTOS/Source/queue.c **** 	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait )
2213:Libraries/FreeRTOS/Source/queue.c **** 	{
 2845              		.loc 1 2213 0
 2846              		.cfi_startproc
 2847              		@ args = 0, pretend = 0, frame = 0
 2848              		@ frame_needed = 0, uses_anonymous_args = 0
 2849              	.LVL379:
 2850 0000 38B5     		push	{r3, r4, r5, lr}
 2851              	.LCFI22:
 2852              		.cfi_def_cfa_offset 16
 2853              		.cfi_offset 3, -16
 2854              		.cfi_offset 4, -12
 2855              		.cfi_offset 5, -8
 2856              		.cfi_offset 14, -4
 2857              		.loc 1 2213 0
 2858 0002 0446     		mov	r4, r0
 2859              	.LVL380:
 2860 0004 0D46     		mov	r5, r1
2214:Libraries/FreeRTOS/Source/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2215:Libraries/FreeRTOS/Source/queue.c **** 
2216:Libraries/FreeRTOS/Source/queue.c **** 		/* This function should not be called by application code hence the
2217:Libraries/FreeRTOS/Source/queue.c **** 		'Restricted' in its name.  It is not part of the public API.  It is
2218:Libraries/FreeRTOS/Source/queue.c **** 		designed for use by kernel code, and has special calling requirements.
2219:Libraries/FreeRTOS/Source/queue.c **** 		It can result in vListInsert() being called on a list that can only
2220:Libraries/FreeRTOS/Source/queue.c **** 		possibly ever have one item in it, so the list will be fast, but even
2221:Libraries/FreeRTOS/Source/queue.c **** 		so it should be called with the scheduler locked and not from a critical
2222:Libraries/FreeRTOS/Source/queue.c **** 		section. */
2223:Libraries/FreeRTOS/Source/queue.c **** 
2224:Libraries/FreeRTOS/Source/queue.c **** 		/* Only do anything if there are no messages in the queue.  This function
2225:Libraries/FreeRTOS/Source/queue.c **** 		will not actually cause the task to block, just place it on a blocked
2226:Libraries/FreeRTOS/Source/queue.c **** 		list.  It will not block until the scheduler is unlocked - at which
2227:Libraries/FreeRTOS/Source/queue.c **** 		time a yield will be performed.  If an item is added to the queue while
2228:Libraries/FreeRTOS/Source/queue.c **** 		the queue is locked, and the calling task blocks on the queue, then the
2229:Libraries/FreeRTOS/Source/queue.c **** 		calling task will be immediately unblocked when the queue is unlocked. */
2230:Libraries/FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 2861              		.loc 1 2230 0
 2862 0006 FFF7FEFF 		bl	vPortEnterCritical
 2863              	.LVL381:
 2864 000a 636C     		ldr	r3, [r4, #68]
 2865 000c 0133     		adds	r3, r3, #1
 2866 000e 04BF     		itt	eq
 2867 0010 0023     		moveq	r3, #0
 2868 0012 6364     		streq	r3, [r4, #68]
 2869 0014 A36C     		ldr	r3, [r4, #72]
 2870 0016 0133     		adds	r3, r3, #1
 2871 0018 04BF     		itt	eq
 2872 001a 0023     		moveq	r3, #0
 2873 001c A364     		streq	r3, [r4, #72]
 2874 001e FFF7FEFF 		bl	vPortExitCritical
 2875              	.LVL382:
2231:Libraries/FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
 2876              		.loc 1 2231 0
 2877 0022 A36B     		ldr	r3, [r4, #56]
 2878 0024 23B9     		cbnz	r3, .L480
2232:Libraries/FreeRTOS/Source/queue.c **** 		{
2233:Libraries/FreeRTOS/Source/queue.c **** 			/* There is nothing in the queue, block for the specified period. */
2234:Libraries/FreeRTOS/Source/queue.c **** 			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 2879              		.loc 1 2234 0
 2880 0026 2946     		mov	r1, r5
 2881 0028 04F12400 		add	r0, r4, #36
 2882 002c FFF7FEFF 		bl	vTaskPlaceOnEventListRestricted
 2883              	.LVL383:
 2884              	.L480:
 2885              	.LBB84:
 2886              	.LBB85:
1694:Libraries/FreeRTOS/Source/queue.c **** 	{
 2887              		.loc 1 1694 0
 2888 0030 FFF7FEFF 		bl	vPortEnterCritical
 2889              	.LVL384:
1697:Libraries/FreeRTOS/Source/queue.c **** 		{
 2890              		.loc 1 1697 0
 2891 0034 A36C     		ldr	r3, [r4, #72]
 2892 0036 002B     		cmp	r3, #0
 2893 0038 14DD     		ble	.L484
1744:Libraries/FreeRTOS/Source/queue.c **** 				{
 2894              		.loc 1 1744 0
 2895 003a 636A     		ldr	r3, [r4, #36]
 2896 003c 93B1     		cbz	r3, .L484
 2897 003e 04F12405 		add	r5, r4, #36
 2898              	.LVL385:
 2899 0042 07E0     		b	.L485
 2900              	.L486:
1764:Libraries/FreeRTOS/Source/queue.c **** 		}
 2901              		.loc 1 1764 0
 2902 0044 A36C     		ldr	r3, [r4, #72]
 2903 0046 013B     		subs	r3, r3, #1
 2904 0048 A364     		str	r3, [r4, #72]
1697:Libraries/FreeRTOS/Source/queue.c **** 		{
 2905              		.loc 1 1697 0
 2906 004a A36C     		ldr	r3, [r4, #72]
 2907 004c 002B     		cmp	r3, #0
 2908 004e 09DD     		ble	.L484
1744:Libraries/FreeRTOS/Source/queue.c **** 				{
 2909              		.loc 1 1744 0
 2910 0050 636A     		ldr	r3, [r4, #36]
 2911 0052 3BB1     		cbz	r3, .L484
 2912              	.L485:
1746:Libraries/FreeRTOS/Source/queue.c **** 					{
 2913              		.loc 1 1746 0
 2914 0054 2846     		mov	r0, r5
 2915 0056 FFF7FEFF 		bl	xTaskRemoveFromEventList
 2916              	.LVL386:
 2917 005a 0028     		cmp	r0, #0
 2918 005c F2D0     		beq	.L486
1750:Libraries/FreeRTOS/Source/queue.c **** 					}
 2919              		.loc 1 1750 0
 2920 005e FFF7FEFF 		bl	vTaskMissedYield
 2921              	.LVL387:
 2922 0062 EFE7     		b	.L486
 2923              	.L484:
1767:Libraries/FreeRTOS/Source/queue.c **** 	}
 2924              		.loc 1 1767 0
 2925 0064 4FF0FF33 		mov	r3, #-1
 2926 0068 A364     		str	r3, [r4, #72]
1769:Libraries/FreeRTOS/Source/queue.c **** 
 2927              		.loc 1 1769 0
 2928 006a FFF7FEFF 		bl	vPortExitCritical
 2929              	.LVL388:
1772:Libraries/FreeRTOS/Source/queue.c **** 	{
 2930              		.loc 1 1772 0
 2931 006e FFF7FEFF 		bl	vPortEnterCritical
 2932              	.LVL389:
1774:Libraries/FreeRTOS/Source/queue.c **** 		{
 2933              		.loc 1 1774 0
 2934 0072 636C     		ldr	r3, [r4, #68]
 2935 0074 002B     		cmp	r3, #0
 2936 0076 14DD     		ble	.L483
1776:Libraries/FreeRTOS/Source/queue.c **** 			{
 2937              		.loc 1 1776 0
 2938 0078 2369     		ldr	r3, [r4, #16]
 2939 007a 93B1     		cbz	r3, .L483
 2940 007c 04F11005 		add	r5, r4, #16
 2941 0080 07E0     		b	.L488
 2942              	.L489:
1787:Libraries/FreeRTOS/Source/queue.c **** 			}
 2943              		.loc 1 1787 0
 2944 0082 636C     		ldr	r3, [r4, #68]
 2945 0084 013B     		subs	r3, r3, #1
 2946 0086 6364     		str	r3, [r4, #68]
1774:Libraries/FreeRTOS/Source/queue.c **** 		{
 2947              		.loc 1 1774 0
 2948 0088 636C     		ldr	r3, [r4, #68]
 2949 008a 002B     		cmp	r3, #0
 2950 008c 09DD     		ble	.L483
1776:Libraries/FreeRTOS/Source/queue.c **** 			{
 2951              		.loc 1 1776 0
 2952 008e 2369     		ldr	r3, [r4, #16]
 2953 0090 3BB1     		cbz	r3, .L483
 2954              	.L488:
1778:Libraries/FreeRTOS/Source/queue.c **** 				{
 2955              		.loc 1 1778 0
 2956 0092 2846     		mov	r0, r5
 2957 0094 FFF7FEFF 		bl	xTaskRemoveFromEventList
 2958              	.LVL390:
 2959 0098 0028     		cmp	r0, #0
 2960 009a F2D0     		beq	.L489
1780:Libraries/FreeRTOS/Source/queue.c **** 				}
 2961              		.loc 1 1780 0
 2962 009c FFF7FEFF 		bl	vTaskMissedYield
 2963              	.LVL391:
 2964 00a0 EFE7     		b	.L489
 2965              	.L483:
1795:Libraries/FreeRTOS/Source/queue.c **** 	}
 2966              		.loc 1 1795 0
 2967 00a2 4FF0FF33 		mov	r3, #-1
 2968 00a6 6364     		str	r3, [r4, #68]
 2969              	.LBE85:
 2970              	.LBE84:
2235:Libraries/FreeRTOS/Source/queue.c **** 		}
2236:Libraries/FreeRTOS/Source/queue.c **** 		else
2237:Libraries/FreeRTOS/Source/queue.c **** 		{
2238:Libraries/FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2239:Libraries/FreeRTOS/Source/queue.c **** 		}
2240:Libraries/FreeRTOS/Source/queue.c **** 		prvUnlockQueue( pxQueue );
2241:Libraries/FreeRTOS/Source/queue.c **** 	}
 2971              		.loc 1 2241 0
 2972 00a8 BDE83840 		pop	{r3, r4, r5, lr}
 2973              	.LVL392:
 2974              	.LBB87:
 2975              	.LBB86:
1797:Libraries/FreeRTOS/Source/queue.c **** }
 2976              		.loc 1 1797 0
 2977 00ac FFF7FEBF 		b	vPortExitCritical
 2978              	.LVL393:
 2979              	.LBE86:
 2980              	.LBE87:
 2981              		.cfi_endproc
 2982              	.LFE147:
 2984              		.comm	xQueueRegistry,64,4
 2985              		.text
 2986              	.Letext0:
 2987              		.file 2 "/opt/toolchains/eabi/arm-2014.05/lib/gcc/arm-none-eabi/4.8.3/include/stddef.h"
 2988              		.file 3 "/opt/toolchains/eabi/arm-2014.05/arm-none-eabi/include/stdint.h"
 2989              		.file 4 "Libraries/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h"
 2990              		.file 5 "Libraries/FreeRTOS/Source/include/list.h"
 2991              		.file 6 "Libraries/FreeRTOS/Source/include/task.h"
 2992              		.file 7 "Libraries/FreeRTOS/Source/include/queue.h"
 2993              		.file 8 "Libraries/CMSIS/Include/core_cm4.h"
 2994              		.file 9 "Libraries/FreeRTOS/Source/include/portable.h"
DEFINED SYMBOLS
                            *ABS*:00000000 queue.c
     /tmp/cc5XcAo4.s:21     .text.unlikely.prvCopyDataFromQueue:00000000 $t
     /tmp/cc5XcAo4.s:25     .text.unlikely.prvCopyDataFromQueue:00000000 prvCopyDataFromQueue
     /tmp/cc5XcAo4.s:77     .text.prvUnlockQueue:00000000 $t
     /tmp/cc5XcAo4.s:81     .text.prvUnlockQueue:00000000 prvUnlockQueue
     /tmp/cc5XcAo4.s:188    .text.xQueueGenericReset:00000000 $t
     /tmp/cc5XcAo4.s:193    .text.xQueueGenericReset:00000000 xQueueGenericReset
     /tmp/cc5XcAo4.s:298    .text.xQueueGenericCreate:00000000 $t
     /tmp/cc5XcAo4.s:303    .text.xQueueGenericCreate:00000000 xQueueGenericCreate
     /tmp/cc5XcAo4.s:413    .text.xQueueCreateCountingSemaphore:00000000 $t
     /tmp/cc5XcAo4.s:418    .text.xQueueCreateCountingSemaphore:00000000 xQueueCreateCountingSemaphore
     /tmp/cc5XcAo4.s:553    .text.xQueueGenericSend:00000000 $t
     /tmp/cc5XcAo4.s:558    .text.xQueueGenericSend:00000000 xQueueGenericSend
     /tmp/cc5XcAo4.s:1096   .text.xQueueCreateMutex:00000000 $t
     /tmp/cc5XcAo4.s:1101   .text.xQueueCreateMutex:00000000 xQueueCreateMutex
     /tmp/cc5XcAo4.s:1177   .text.xQueueGiveMutexRecursive:00000000 $t
     /tmp/cc5XcAo4.s:1182   .text.xQueueGiveMutexRecursive:00000000 xQueueGiveMutexRecursive
     /tmp/cc5XcAo4.s:1242   .text.xQueueGenericSendFromISR:00000000 $t
     /tmp/cc5XcAo4.s:1247   .text.xQueueGenericSendFromISR:00000000 xQueueGenericSendFromISR
     /tmp/cc5XcAo4.s:1529   .text.xQueueGenericReceive:00000000 $t
     /tmp/cc5XcAo4.s:1534   .text.xQueueGenericReceive:00000000 xQueueGenericReceive
     /tmp/cc5XcAo4.s:2000   .text.xQueueTakeMutexRecursive:00000000 $t
     /tmp/cc5XcAo4.s:2005   .text.xQueueTakeMutexRecursive:00000000 xQueueTakeMutexRecursive
     /tmp/cc5XcAo4.s:2067   .text.xQueueReceiveFromISR:00000000 $t
     /tmp/cc5XcAo4.s:2072   .text.xQueueReceiveFromISR:00000000 xQueueReceiveFromISR
     /tmp/cc5XcAo4.s:2204   .text.xQueuePeekFromISR:00000000 $t
     /tmp/cc5XcAo4.s:2209   .text.xQueuePeekFromISR:00000000 xQueuePeekFromISR
     /tmp/cc5XcAo4.s:2301   .text.uxQueueMessagesWaiting:00000000 $t
     /tmp/cc5XcAo4.s:2306   .text.uxQueueMessagesWaiting:00000000 uxQueueMessagesWaiting
     /tmp/cc5XcAo4.s:2344   .text.uxQueueSpacesAvailable:00000000 $t
     /tmp/cc5XcAo4.s:2349   .text.uxQueueSpacesAvailable:00000000 uxQueueSpacesAvailable
     /tmp/cc5XcAo4.s:2390   .text.uxQueueMessagesWaitingFromISR:00000000 $t
     /tmp/cc5XcAo4.s:2395   .text.uxQueueMessagesWaitingFromISR:00000000 uxQueueMessagesWaitingFromISR
     /tmp/cc5XcAo4.s:2425   .text.vQueueDelete:00000000 $t
     /tmp/cc5XcAo4.s:2430   .text.vQueueDelete:00000000 vQueueDelete
                            *COM*:00000040 xQueueRegistry
     /tmp/cc5XcAo4.s:2575   .text.xQueueIsQueueEmptyFromISR:00000000 $t
     /tmp/cc5XcAo4.s:2580   .text.xQueueIsQueueEmptyFromISR:00000000 xQueueIsQueueEmptyFromISR
     /tmp/cc5XcAo4.s:2614   .text.xQueueIsQueueFullFromISR:00000000 $t
     /tmp/cc5XcAo4.s:2619   .text.xQueueIsQueueFullFromISR:00000000 xQueueIsQueueFullFromISR
     /tmp/cc5XcAo4.s:2655   .text.vQueueAddToRegistry:00000000 $t
     /tmp/cc5XcAo4.s:2660   .text.vQueueAddToRegistry:00000000 vQueueAddToRegistry
     /tmp/cc5XcAo4.s:2747   .text.vQueueUnregisterQueue:00000000 $t
     /tmp/cc5XcAo4.s:2752   .text.vQueueUnregisterQueue:00000000 vQueueUnregisterQueue
     /tmp/cc5XcAo4.s:2838   .text.vQueueWaitForMessageRestricted:00000000 $t
     /tmp/cc5XcAo4.s:2843   .text.vQueueWaitForMessageRestricted:00000000 vQueueWaitForMessageRestricted
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
memcpy
vPortEnterCritical
xTaskRemoveFromEventList
vTaskMissedYield
vPortExitCritical
vPortYield
vListInitialise
ulPortSetInterruptMask
pvPortMalloc
vPortFree
xTaskGetSchedulerState
vTaskSuspendAll
xTaskCheckForTimeOut
xTaskResumeAll
vTaskPlaceOnEventList
vTaskSetTimeOutState
vTaskPriorityDisinherit
xTaskGetCurrentTaskHandle
vPortValidateInterruptPriority
vPortClearInterruptMask
vTaskPriorityInherit
vTaskPlaceOnEventListRestricted
