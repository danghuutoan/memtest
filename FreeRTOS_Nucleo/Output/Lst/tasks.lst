   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.eabi_attribute 28, 1
   5              		.fpu fpv4-sp-d16
   6              		.eabi_attribute 20, 1
   7              		.eabi_attribute 21, 1
   8              		.eabi_attribute 23, 3
   9              		.eabi_attribute 24, 1
  10              		.eabi_attribute 25, 1
  11              		.eabi_attribute 26, 1
  12              		.eabi_attribute 30, 2
  13              		.eabi_attribute 34, 1
  14              		.eabi_attribute 18, 4
  15              		.thumb
  16              		.file	"tasks.c"
  17              		.text
  18              	.Ltext0:
  19              		.cfi_sections	.debug_frame
  20              		.section	.text.unlikely.prvInitialiseTaskLists,"ax",%progbits
  21              		.align	2
  22              		.thumb
  23              		.thumb_func
  25              	prvInitialiseTaskLists:
  26              	.LFB152:
  27              		.file 1 "Libraries/FreeRTOS/Source/tasks.c"
   1:Libraries/FreeRTOS/Source/tasks.c **** /*
   2:Libraries/FreeRTOS/Source/tasks.c ****     FreeRTOS V8.0.1 - Copyright (C) 2014 Real Time Engineers Ltd.
   3:Libraries/FreeRTOS/Source/tasks.c ****     All rights reserved
   4:Libraries/FreeRTOS/Source/tasks.c **** 
   5:Libraries/FreeRTOS/Source/tasks.c ****     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:Libraries/FreeRTOS/Source/tasks.c **** 
   7:Libraries/FreeRTOS/Source/tasks.c ****     ***************************************************************************
   8:Libraries/FreeRTOS/Source/tasks.c ****      *                                                                       *
   9:Libraries/FreeRTOS/Source/tasks.c ****      *    FreeRTOS provides completely free yet professionally developed,    *
  10:Libraries/FreeRTOS/Source/tasks.c ****      *    robust, strictly quality controlled, supported, and cross          *
  11:Libraries/FreeRTOS/Source/tasks.c ****      *    platform software that has become a de facto standard.             *
  12:Libraries/FreeRTOS/Source/tasks.c ****      *                                                                       *
  13:Libraries/FreeRTOS/Source/tasks.c ****      *    Help yourself get started quickly and support the FreeRTOS         *
  14:Libraries/FreeRTOS/Source/tasks.c ****      *    project by purchasing a FreeRTOS tutorial book, reference          *
  15:Libraries/FreeRTOS/Source/tasks.c ****      *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
  16:Libraries/FreeRTOS/Source/tasks.c ****      *                                                                       *
  17:Libraries/FreeRTOS/Source/tasks.c ****      *    Thank you!                                                         *
  18:Libraries/FreeRTOS/Source/tasks.c ****      *                                                                       *
  19:Libraries/FreeRTOS/Source/tasks.c ****     ***************************************************************************
  20:Libraries/FreeRTOS/Source/tasks.c **** 
  21:Libraries/FreeRTOS/Source/tasks.c ****     This file is part of the FreeRTOS distribution.
  22:Libraries/FreeRTOS/Source/tasks.c **** 
  23:Libraries/FreeRTOS/Source/tasks.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  24:Libraries/FreeRTOS/Source/tasks.c ****     the terms of the GNU General Public License (version 2) as published by the
  25:Libraries/FreeRTOS/Source/tasks.c ****     Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
  26:Libraries/FreeRTOS/Source/tasks.c **** 
  27:Libraries/FreeRTOS/Source/tasks.c ****     >>!   NOTE: The modification to the GPL is included to allow you to     !<<
  28:Libraries/FreeRTOS/Source/tasks.c ****     >>!   distribute a combined work that includes FreeRTOS without being   !<<
  29:Libraries/FreeRTOS/Source/tasks.c ****     >>!   obliged to provide the source code for proprietary components     !<<
  30:Libraries/FreeRTOS/Source/tasks.c ****     >>!   outside of the FreeRTOS kernel.                                   !<<
  31:Libraries/FreeRTOS/Source/tasks.c **** 
  32:Libraries/FreeRTOS/Source/tasks.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  33:Libraries/FreeRTOS/Source/tasks.c ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  34:Libraries/FreeRTOS/Source/tasks.c ****     FOR A PARTICULAR PURPOSE.  Full license text is available from the following
  35:Libraries/FreeRTOS/Source/tasks.c ****     link: http://www.freertos.org/a00114.html
  36:Libraries/FreeRTOS/Source/tasks.c **** 
  37:Libraries/FreeRTOS/Source/tasks.c ****     1 tab == 4 spaces!
  38:Libraries/FreeRTOS/Source/tasks.c **** 
  39:Libraries/FreeRTOS/Source/tasks.c ****     ***************************************************************************
  40:Libraries/FreeRTOS/Source/tasks.c ****      *                                                                       *
  41:Libraries/FreeRTOS/Source/tasks.c ****      *    Having a problem?  Start by reading the FAQ "My application does   *
  42:Libraries/FreeRTOS/Source/tasks.c ****      *    not run, what could be wrong?"                                     *
  43:Libraries/FreeRTOS/Source/tasks.c ****      *                                                                       *
  44:Libraries/FreeRTOS/Source/tasks.c ****      *    http://www.FreeRTOS.org/FAQHelp.html                               *
  45:Libraries/FreeRTOS/Source/tasks.c ****      *                                                                       *
  46:Libraries/FreeRTOS/Source/tasks.c ****     ***************************************************************************
  47:Libraries/FreeRTOS/Source/tasks.c **** 
  48:Libraries/FreeRTOS/Source/tasks.c ****     http://www.FreeRTOS.org - Documentation, books, training, latest versions,
  49:Libraries/FreeRTOS/Source/tasks.c ****     license and Real Time Engineers Ltd. contact details.
  50:Libraries/FreeRTOS/Source/tasks.c **** 
  51:Libraries/FreeRTOS/Source/tasks.c ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  52:Libraries/FreeRTOS/Source/tasks.c ****     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
  53:Libraries/FreeRTOS/Source/tasks.c ****     compatible FAT file system, and our tiny thread aware UDP/IP stack.
  54:Libraries/FreeRTOS/Source/tasks.c **** 
  55:Libraries/FreeRTOS/Source/tasks.c ****     http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
  56:Libraries/FreeRTOS/Source/tasks.c ****     Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
  57:Libraries/FreeRTOS/Source/tasks.c ****     licenses offer ticketed support, indemnification and middleware.
  58:Libraries/FreeRTOS/Source/tasks.c **** 
  59:Libraries/FreeRTOS/Source/tasks.c ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
  60:Libraries/FreeRTOS/Source/tasks.c ****     engineered and independently SIL3 certified version for use in safety and
  61:Libraries/FreeRTOS/Source/tasks.c ****     mission critical applications that require provable dependability.
  62:Libraries/FreeRTOS/Source/tasks.c **** 
  63:Libraries/FreeRTOS/Source/tasks.c ****     1 tab == 4 spaces!
  64:Libraries/FreeRTOS/Source/tasks.c **** */
  65:Libraries/FreeRTOS/Source/tasks.c **** 
  66:Libraries/FreeRTOS/Source/tasks.c **** /* Standard includes. */
  67:Libraries/FreeRTOS/Source/tasks.c **** #include <stdlib.h>
  68:Libraries/FreeRTOS/Source/tasks.c **** #include <string.h>
  69:Libraries/FreeRTOS/Source/tasks.c **** 
  70:Libraries/FreeRTOS/Source/tasks.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  71:Libraries/FreeRTOS/Source/tasks.c **** all the API functions to use the MPU wrappers.  That should only be done when
  72:Libraries/FreeRTOS/Source/tasks.c **** task.h is included from an application file. */
  73:Libraries/FreeRTOS/Source/tasks.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  74:Libraries/FreeRTOS/Source/tasks.c **** 
  75:Libraries/FreeRTOS/Source/tasks.c **** /* FreeRTOS includes. */
  76:Libraries/FreeRTOS/Source/tasks.c **** #include "FreeRTOSConfig.h"
  77:Libraries/FreeRTOS/Source/tasks.c **** #include "FreeRTOS.h"
  78:Libraries/FreeRTOS/Source/tasks.c **** #include "task.h"
  79:Libraries/FreeRTOS/Source/tasks.c **** #include "timers.h"
  80:Libraries/FreeRTOS/Source/tasks.c **** #include "StackMacros.h"
  81:Libraries/FreeRTOS/Source/tasks.c **** 
  82:Libraries/FreeRTOS/Source/tasks.c **** /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
  83:Libraries/FreeRTOS/Source/tasks.c **** MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
  84:Libraries/FreeRTOS/Source/tasks.c **** header files above, but not in this file, in order to generate the correct
  85:Libraries/FreeRTOS/Source/tasks.c **** privileged Vs unprivileged linkage and placement. */
  86:Libraries/FreeRTOS/Source/tasks.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
  87:Libraries/FreeRTOS/Source/tasks.c **** 
  88:Libraries/FreeRTOS/Source/tasks.c **** #if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
  89:Libraries/FreeRTOS/Source/tasks.c **** 	/* At the bottom of this file are two optional functions that can be used
  90:Libraries/FreeRTOS/Source/tasks.c **** 	to generate human readable text from the raw data generated by the
  91:Libraries/FreeRTOS/Source/tasks.c **** 	uxTaskGetSystemState() function.  Note the formatting functions are provided
  92:Libraries/FreeRTOS/Source/tasks.c **** 	for convenience only, and are NOT considered part of the kernel. */
  93:Libraries/FreeRTOS/Source/tasks.c **** 	#include <stdio.h>
  94:Libraries/FreeRTOS/Source/tasks.c **** #endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */
  95:Libraries/FreeRTOS/Source/tasks.c **** 
  96:Libraries/FreeRTOS/Source/tasks.c **** /* Sanity check the configuration. */
  97:Libraries/FreeRTOS/Source/tasks.c **** #if configUSE_TICKLESS_IDLE != 0
  98:Libraries/FreeRTOS/Source/tasks.c **** 	#if INCLUDE_vTaskSuspend != 1
  99:Libraries/FreeRTOS/Source/tasks.c **** 		#error INCLUDE_vTaskSuspend must be set to 1 if configUSE_TICKLESS_IDLE is not set to 0
 100:Libraries/FreeRTOS/Source/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
 101:Libraries/FreeRTOS/Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
 102:Libraries/FreeRTOS/Source/tasks.c **** 
 103:Libraries/FreeRTOS/Source/tasks.c **** /*
 104:Libraries/FreeRTOS/Source/tasks.c ****  * Defines the size, in words, of the stack allocated to the idle task.
 105:Libraries/FreeRTOS/Source/tasks.c ****  */
 106:Libraries/FreeRTOS/Source/tasks.c **** #define tskIDLE_STACK_SIZE	configMINIMAL_STACK_SIZE
 107:Libraries/FreeRTOS/Source/tasks.c **** 
 108:Libraries/FreeRTOS/Source/tasks.c **** #if( configUSE_PREEMPTION == 0 )
 109:Libraries/FreeRTOS/Source/tasks.c **** 	/* If the cooperative scheduler is being used then a yield should not be
 110:Libraries/FreeRTOS/Source/tasks.c **** 	performed just because a higher priority task has been woken. */
 111:Libraries/FreeRTOS/Source/tasks.c **** 	#define taskYIELD_IF_USING_PREEMPTION()
 112:Libraries/FreeRTOS/Source/tasks.c **** #else
 113:Libraries/FreeRTOS/Source/tasks.c **** 	#define taskYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
 114:Libraries/FreeRTOS/Source/tasks.c **** #endif
 115:Libraries/FreeRTOS/Source/tasks.c **** 
 116:Libraries/FreeRTOS/Source/tasks.c **** /*
 117:Libraries/FreeRTOS/Source/tasks.c ****  * Task control block.  A task control block (TCB) is allocated for each task,
 118:Libraries/FreeRTOS/Source/tasks.c ****  * and stores task state information, including a pointer to the task's context
 119:Libraries/FreeRTOS/Source/tasks.c ****  * (the task's run time environment, including register values)
 120:Libraries/FreeRTOS/Source/tasks.c ****  */
 121:Libraries/FreeRTOS/Source/tasks.c **** typedef struct tskTaskControlBlock
 122:Libraries/FreeRTOS/Source/tasks.c **** {
 123:Libraries/FreeRTOS/Source/tasks.c **** 	volatile StackType_t	*pxTopOfStack;	/*< Points to the location of the last item placed on the task
 124:Libraries/FreeRTOS/Source/tasks.c **** 
 125:Libraries/FreeRTOS/Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
 126:Libraries/FreeRTOS/Source/tasks.c **** 		xMPU_SETTINGS	xMPUSettings;		/*< The MPU settings are defined as part of the port layer.  THIS MU
 127:Libraries/FreeRTOS/Source/tasks.c **** 	#endif
 128:Libraries/FreeRTOS/Source/tasks.c **** 
 129:Libraries/FreeRTOS/Source/tasks.c **** 	ListItem_t			xGenericListItem;	/*< The list that the state list item of a task is reference from d
 130:Libraries/FreeRTOS/Source/tasks.c **** 	ListItem_t			xEventListItem;		/*< Used to reference a task from an event list. */
 131:Libraries/FreeRTOS/Source/tasks.c **** 	UBaseType_t			uxPriority;			/*< The priority of the task.  0 is the lowest priority. */
 132:Libraries/FreeRTOS/Source/tasks.c **** 	StackType_t			*pxStack;			/*< Points to the start of the stack. */
 133:Libraries/FreeRTOS/Source/tasks.c **** 	char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when created.
 134:Libraries/FreeRTOS/Source/tasks.c **** 
 135:Libraries/FreeRTOS/Source/tasks.c **** 	#if ( portSTACK_GROWTH > 0 )
 136:Libraries/FreeRTOS/Source/tasks.c **** 		StackType_t		*pxEndOfStack;		/*< Points to the end of the stack on architectures where the stack 
 137:Libraries/FreeRTOS/Source/tasks.c **** 	#endif
 138:Libraries/FreeRTOS/Source/tasks.c **** 
 139:Libraries/FreeRTOS/Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
 140:Libraries/FreeRTOS/Source/tasks.c **** 		UBaseType_t 	uxCriticalNesting; 	/*< Holds the critical section nesting depth for ports that do n
 141:Libraries/FreeRTOS/Source/tasks.c **** 	#endif
 142:Libraries/FreeRTOS/Source/tasks.c **** 
 143:Libraries/FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 144:Libraries/FreeRTOS/Source/tasks.c **** 		UBaseType_t		uxTCBNumber;		/*< Stores a number that increments each time a TCB is created.  It al
 145:Libraries/FreeRTOS/Source/tasks.c **** 		UBaseType_t  	uxTaskNumber;		/*< Stores a number specifically for use by third party trace code. 
 146:Libraries/FreeRTOS/Source/tasks.c **** 	#endif
 147:Libraries/FreeRTOS/Source/tasks.c **** 
 148:Libraries/FreeRTOS/Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 149:Libraries/FreeRTOS/Source/tasks.c **** 		UBaseType_t 	uxBasePriority;		/*< The priority last assigned to the task - used by the priority i
 150:Libraries/FreeRTOS/Source/tasks.c **** 	#endif
 151:Libraries/FreeRTOS/Source/tasks.c **** 
 152:Libraries/FreeRTOS/Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 153:Libraries/FreeRTOS/Source/tasks.c **** 		TaskHookFunction_t pxTaskTag;
 154:Libraries/FreeRTOS/Source/tasks.c **** 	#endif
 155:Libraries/FreeRTOS/Source/tasks.c **** 
 156:Libraries/FreeRTOS/Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
 157:Libraries/FreeRTOS/Source/tasks.c **** 		uint32_t		ulRunTimeCounter;	/*< Stores the amount of time the task has spent in the Running state
 158:Libraries/FreeRTOS/Source/tasks.c **** 	#endif
 159:Libraries/FreeRTOS/Source/tasks.c **** 
 160:Libraries/FreeRTOS/Source/tasks.c **** 	#if ( configUSE_NEWLIB_REENTRANT == 1 )
 161:Libraries/FreeRTOS/Source/tasks.c **** 		/* Allocate a Newlib reent structure that is specific to this task.
 162:Libraries/FreeRTOS/Source/tasks.c **** 		Note Newlib support has been included by popular demand, but is not
 163:Libraries/FreeRTOS/Source/tasks.c **** 		used by the FreeRTOS maintainers themselves.  FreeRTOS is not
 164:Libraries/FreeRTOS/Source/tasks.c **** 		responsible for resulting newlib operation.  User must be familiar with
 165:Libraries/FreeRTOS/Source/tasks.c **** 		newlib and must provide system-wide implementations of the necessary
 166:Libraries/FreeRTOS/Source/tasks.c **** 		stubs. Be warned that (at the time of writing) the current newlib design
 167:Libraries/FreeRTOS/Source/tasks.c **** 		implements a system-wide malloc() that must be provided with locks. */
 168:Libraries/FreeRTOS/Source/tasks.c **** 		struct 	_reent xNewLib_reent;
 169:Libraries/FreeRTOS/Source/tasks.c **** 	#endif
 170:Libraries/FreeRTOS/Source/tasks.c **** 
 171:Libraries/FreeRTOS/Source/tasks.c **** } tskTCB;
 172:Libraries/FreeRTOS/Source/tasks.c **** 
 173:Libraries/FreeRTOS/Source/tasks.c **** /* The old tskTCB name is maintained above then typedefed to the new TCB_t name
 174:Libraries/FreeRTOS/Source/tasks.c **** below to enable the use of older kernel aware debuggers. */
 175:Libraries/FreeRTOS/Source/tasks.c **** typedef tskTCB TCB_t;
 176:Libraries/FreeRTOS/Source/tasks.c **** 
 177:Libraries/FreeRTOS/Source/tasks.c **** /*
 178:Libraries/FreeRTOS/Source/tasks.c ****  * Some kernel aware debuggers require the data the debugger needs access to to
 179:Libraries/FreeRTOS/Source/tasks.c ****  * be global, rather than file scope.
 180:Libraries/FreeRTOS/Source/tasks.c ****  */
 181:Libraries/FreeRTOS/Source/tasks.c **** #ifdef portREMOVE_STATIC_QUALIFIER
 182:Libraries/FreeRTOS/Source/tasks.c **** 	#define static
 183:Libraries/FreeRTOS/Source/tasks.c **** #endif
 184:Libraries/FreeRTOS/Source/tasks.c **** 
 185:Libraries/FreeRTOS/Source/tasks.c **** /*lint -e956 A manual analysis and inspection has been used to determine which
 186:Libraries/FreeRTOS/Source/tasks.c **** static variables must be declared volatile. */
 187:Libraries/FreeRTOS/Source/tasks.c **** 
 188:Libraries/FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;
 189:Libraries/FreeRTOS/Source/tasks.c **** 
 190:Libraries/FreeRTOS/Source/tasks.c **** /* Lists for ready and blocked tasks. --------------------*/
 191:Libraries/FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ];/*< Prioritised ready tasks
 192:Libraries/FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t xDelayedTaskList1;						/*< Delayed tasks. */
 193:Libraries/FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t xDelayedTaskList2;						/*< Delayed tasks (two lists are used - one f
 194:Libraries/FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;				/*< Points to the delayed task list 
 195:Libraries/FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task
 196:Libraries/FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t xPendingReadyList;						/*< Tasks that have been readied while the sc
 197:Libraries/FreeRTOS/Source/tasks.c **** 
 198:Libraries/FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 199:Libraries/FreeRTOS/Source/tasks.c **** 
 200:Libraries/FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static List_t xTasksWaitingTermination;				/*< Tasks that have been deleted - but 
 201:Libraries/FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static volatile UBaseType_t uxTasksDeleted = ( UBaseType_t ) 0U;
 202:Libraries/FreeRTOS/Source/tasks.c **** 
 203:Libraries/FreeRTOS/Source/tasks.c **** #endif
 204:Libraries/FreeRTOS/Source/tasks.c **** 
 205:Libraries/FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 206:Libraries/FreeRTOS/Source/tasks.c **** 
 207:Libraries/FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static List_t xSuspendedTaskList;					/*< Tasks that are currently suspended. */
 208:Libraries/FreeRTOS/Source/tasks.c **** 
 209:Libraries/FreeRTOS/Source/tasks.c **** #endif
 210:Libraries/FreeRTOS/Source/tasks.c **** 
 211:Libraries/FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
 212:Libraries/FreeRTOS/Source/tasks.c **** 
 213:Libraries/FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle = NULL;			/*< Holds the handle of the idle tas
 214:Libraries/FreeRTOS/Source/tasks.c **** 
 215:Libraries/FreeRTOS/Source/tasks.c **** #endif
 216:Libraries/FreeRTOS/Source/tasks.c **** 
 217:Libraries/FreeRTOS/Source/tasks.c **** /* Other file private variables. --------------------------------*/
 218:Libraries/FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks 	= ( UBaseType_t ) 0U;
 219:Libraries/FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xTickCount 				= ( TickType_t ) 0U;
 220:Libraries/FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority 		= tskIDLE_PRIORITY;
 221:Libraries/FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning 		= pdFALSE;
 222:Libraries/FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxPendedTicks 			= ( UBaseType_t ) 0U;
 223:Libraries/FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xYieldPending 			= pdFALSE;
 224:Libraries/FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows 			= ( BaseType_t ) 0;
 225:Libraries/FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static UBaseType_t uxTaskNumber 					= ( UBaseType_t ) 0U;
 226:Libraries/FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime		= portMAX_DELAY;
 227:Libraries/FreeRTOS/Source/tasks.c **** 
 228:Libraries/FreeRTOS/Source/tasks.c **** /* Context switches are held pending while the scheduler is suspended.  Also,
 229:Libraries/FreeRTOS/Source/tasks.c **** interrupts must not manipulate the xStateListItem of a TCB, or any of the
 230:Libraries/FreeRTOS/Source/tasks.c **** lists the xStateListItem can be referenced from, if the scheduler is suspended.
 231:Libraries/FreeRTOS/Source/tasks.c **** If an interrupt needs to unblock a task while the scheduler is suspended then it
 232:Libraries/FreeRTOS/Source/tasks.c **** moves the task's event list item into the xPendingReadyList, ready for the
 233:Libraries/FreeRTOS/Source/tasks.c **** kernel to move the task from the pending ready list into the real ready list
 234:Libraries/FreeRTOS/Source/tasks.c **** when the scheduler is unsuspended.  The pending ready list itself can only be
 235:Libraries/FreeRTOS/Source/tasks.c **** accessed from a critical section. */
 236:Libraries/FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended	= ( UBaseType_t ) pdFALSE;
 237:Libraries/FreeRTOS/Source/tasks.c **** 
 238:Libraries/FreeRTOS/Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
 239:Libraries/FreeRTOS/Source/tasks.c **** 
 240:Libraries/FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static uint32_t ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/counter
 241:Libraries/FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static uint32_t ulTotalRunTime = 0UL;		/*< Holds the total amount of execution tim
 242:Libraries/FreeRTOS/Source/tasks.c **** 
 243:Libraries/FreeRTOS/Source/tasks.c **** #endif
 244:Libraries/FreeRTOS/Source/tasks.c **** 
 245:Libraries/FreeRTOS/Source/tasks.c **** /*lint +e956 */
 246:Libraries/FreeRTOS/Source/tasks.c **** 
 247:Libraries/FreeRTOS/Source/tasks.c **** /* Debugging and trace facilities private variables and macros. ------------*/
 248:Libraries/FreeRTOS/Source/tasks.c **** 
 249:Libraries/FreeRTOS/Source/tasks.c **** /*
 250:Libraries/FreeRTOS/Source/tasks.c ****  * The value used to fill the stack of a task when the task is created.  This
 251:Libraries/FreeRTOS/Source/tasks.c ****  * is used purely for checking the high water mark for tasks.
 252:Libraries/FreeRTOS/Source/tasks.c ****  */
 253:Libraries/FreeRTOS/Source/tasks.c **** #define tskSTACK_FILL_BYTE	( 0xa5U )
 254:Libraries/FreeRTOS/Source/tasks.c **** 
 255:Libraries/FreeRTOS/Source/tasks.c **** /*
 256:Libraries/FreeRTOS/Source/tasks.c ****  * Macros used by vListTask to indicate which state a task is in.
 257:Libraries/FreeRTOS/Source/tasks.c ****  */
 258:Libraries/FreeRTOS/Source/tasks.c **** #define tskBLOCKED_CHAR		( 'B' )
 259:Libraries/FreeRTOS/Source/tasks.c **** #define tskREADY_CHAR		( 'R' )
 260:Libraries/FreeRTOS/Source/tasks.c **** #define tskDELETED_CHAR		( 'D' )
 261:Libraries/FreeRTOS/Source/tasks.c **** #define tskSUSPENDED_CHAR	( 'S' )
 262:Libraries/FreeRTOS/Source/tasks.c **** 
 263:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 264:Libraries/FreeRTOS/Source/tasks.c **** 
 265:Libraries/FreeRTOS/Source/tasks.c **** #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
 266:Libraries/FreeRTOS/Source/tasks.c **** 
 267:Libraries/FreeRTOS/Source/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
 268:Libraries/FreeRTOS/Source/tasks.c **** 	performed in a generic way that is not optimised to any particular
 269:Libraries/FreeRTOS/Source/tasks.c **** 	microcontroller architecture. */
 270:Libraries/FreeRTOS/Source/tasks.c **** 
 271:Libraries/FreeRTOS/Source/tasks.c **** 	/* uxTopReadyPriority holds the priority of the highest priority ready
 272:Libraries/FreeRTOS/Source/tasks.c **** 	state task. */
 273:Libraries/FreeRTOS/Source/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )														\
 274:Libraries/FreeRTOS/Source/tasks.c **** 	{																									\
 275:Libraries/FreeRTOS/Source/tasks.c **** 		if( ( uxPriority ) > uxTopReadyPriority )														\
 276:Libraries/FreeRTOS/Source/tasks.c **** 		{																								\
 277:Libraries/FreeRTOS/Source/tasks.c **** 			uxTopReadyPriority = ( uxPriority );														\
 278:Libraries/FreeRTOS/Source/tasks.c **** 		}																								\
 279:Libraries/FreeRTOS/Source/tasks.c **** 	} /* taskRECORD_READY_PRIORITY */
 280:Libraries/FreeRTOS/Source/tasks.c **** 
 281:Libraries/FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
 282:Libraries/FreeRTOS/Source/tasks.c **** 
 283:Libraries/FreeRTOS/Source/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()															\
 284:Libraries/FreeRTOS/Source/tasks.c **** 	{																									\
 285:Libraries/FreeRTOS/Source/tasks.c **** 		/* Find the highest priority queue that contains ready tasks. */								\
 286:Libraries/FreeRTOS/Source/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )						\
 287:Libraries/FreeRTOS/Source/tasks.c **** 		{																								\
 288:Libraries/FreeRTOS/Source/tasks.c **** 			configASSERT( uxTopReadyPriority );															\
 289:Libraries/FreeRTOS/Source/tasks.c **** 			--uxTopReadyPriority;																		\
 290:Libraries/FreeRTOS/Source/tasks.c **** 		}																								\
 291:Libraries/FreeRTOS/Source/tasks.c **** 																										\
 292:Libraries/FreeRTOS/Source/tasks.c **** 		/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of						\
 293:Libraries/FreeRTOS/Source/tasks.c **** 		the	same priority get an equal share of the processor time. */									\
 294:Libraries/FreeRTOS/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );		\
 295:Libraries/FreeRTOS/Source/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK */
 296:Libraries/FreeRTOS/Source/tasks.c **** 
 297:Libraries/FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
 298:Libraries/FreeRTOS/Source/tasks.c **** 
 299:Libraries/FreeRTOS/Source/tasks.c **** 	/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
 300:Libraries/FreeRTOS/Source/tasks.c **** 	they are only required when a port optimised method of task selection is
 301:Libraries/FreeRTOS/Source/tasks.c **** 	being used. */
 302:Libraries/FreeRTOS/Source/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )
 303:Libraries/FreeRTOS/Source/tasks.c **** 	#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
 304:Libraries/FreeRTOS/Source/tasks.c **** 
 305:Libraries/FreeRTOS/Source/tasks.c **** #else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 306:Libraries/FreeRTOS/Source/tasks.c **** 
 307:Libraries/FreeRTOS/Source/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
 308:Libraries/FreeRTOS/Source/tasks.c **** 	performed in a way that is tailored to the particular microcontroller
 309:Libraries/FreeRTOS/Source/tasks.c **** 	architecture being used. */
 310:Libraries/FreeRTOS/Source/tasks.c **** 
 311:Libraries/FreeRTOS/Source/tasks.c **** 	/* A port optimised version is provided.  Call the port defined macros. */
 312:Libraries/FreeRTOS/Source/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )	portRECORD_READY_PRIORITY( uxPriority, uxTopReadyP
 313:Libraries/FreeRTOS/Source/tasks.c **** 
 314:Libraries/FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
 315:Libraries/FreeRTOS/Source/tasks.c **** 
 316:Libraries/FreeRTOS/Source/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()														\
 317:Libraries/FreeRTOS/Source/tasks.c **** 	{																								\
 318:Libraries/FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTopPriority;																		\
 319:Libraries/FreeRTOS/Source/tasks.c **** 																									\
 320:Libraries/FreeRTOS/Source/tasks.c **** 		/* Find the highest priority queue that contains ready tasks. */							\
 321:Libraries/FreeRTOS/Source/tasks.c **** 		portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );								\
 322:Libraries/FreeRTOS/Source/tasks.c **** 		configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 );		\
 323:Libraries/FreeRTOS/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );		\
 324:Libraries/FreeRTOS/Source/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK() */
 325:Libraries/FreeRTOS/Source/tasks.c **** 
 326:Libraries/FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
 327:Libraries/FreeRTOS/Source/tasks.c **** 
 328:Libraries/FreeRTOS/Source/tasks.c **** 	/* A port optimised version is provided, call it only if the TCB being reset
 329:Libraries/FreeRTOS/Source/tasks.c **** 	is being referenced from a ready list.  If it is referenced from a delayed
 330:Libraries/FreeRTOS/Source/tasks.c **** 	or suspended list then it won't be in a ready list. */
 331:Libraries/FreeRTOS/Source/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )													\
 332:Libraries/FreeRTOS/Source/tasks.c **** 	{																								\
 333:Libraries/FreeRTOS/Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == 0 )				\
 334:Libraries/FreeRTOS/Source/tasks.c **** 		{																							\
 335:Libraries/FreeRTOS/Source/tasks.c **** 			portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );						\
 336:Libraries/FreeRTOS/Source/tasks.c **** 		}																							\
 337:Libraries/FreeRTOS/Source/tasks.c **** 	}
 338:Libraries/FreeRTOS/Source/tasks.c **** 
 339:Libraries/FreeRTOS/Source/tasks.c **** #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 340:Libraries/FreeRTOS/Source/tasks.c **** 
 341:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 342:Libraries/FreeRTOS/Source/tasks.c **** 
 343:Libraries/FreeRTOS/Source/tasks.c **** /* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
 344:Libraries/FreeRTOS/Source/tasks.c **** count overflows. */
 345:Libraries/FreeRTOS/Source/tasks.c **** #define taskSWITCH_DELAYED_LISTS()																	\
 346:Libraries/FreeRTOS/Source/tasks.c **** {																									\
 347:Libraries/FreeRTOS/Source/tasks.c **** 	List_t *pxTemp;																					\
 348:Libraries/FreeRTOS/Source/tasks.c **** 																									\
 349:Libraries/FreeRTOS/Source/tasks.c **** 	/* The delayed tasks list should be empty when the lists are switched. */						\
 350:Libraries/FreeRTOS/Source/tasks.c **** 	configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );										\
 351:Libraries/FreeRTOS/Source/tasks.c **** 																									\
 352:Libraries/FreeRTOS/Source/tasks.c **** 	pxTemp = pxDelayedTaskList;																		\
 353:Libraries/FreeRTOS/Source/tasks.c **** 	pxDelayedTaskList = pxOverflowDelayedTaskList;													\
 354:Libraries/FreeRTOS/Source/tasks.c **** 	pxOverflowDelayedTaskList = pxTemp;																\
 355:Libraries/FreeRTOS/Source/tasks.c **** 	xNumOfOverflows++;																				\
 356:Libraries/FreeRTOS/Source/tasks.c **** 	prvResetNextTaskUnblockTime();																	\
 357:Libraries/FreeRTOS/Source/tasks.c **** }
 358:Libraries/FreeRTOS/Source/tasks.c **** 
 359:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 360:Libraries/FreeRTOS/Source/tasks.c **** 
 361:Libraries/FreeRTOS/Source/tasks.c **** /*
 362:Libraries/FreeRTOS/Source/tasks.c ****  * Place the task represented by pxTCB into the appropriate ready list for
 363:Libraries/FreeRTOS/Source/tasks.c ****  * the task.  It is inserted at the end of the list.
 364:Libraries/FreeRTOS/Source/tasks.c ****  */
 365:Libraries/FreeRTOS/Source/tasks.c **** #define prvAddTaskToReadyList( pxTCB )																\
 366:Libraries/FreeRTOS/Source/tasks.c **** 	traceMOVED_TASK_TO_READY_STATE( pxTCB )															\
 367:Libraries/FreeRTOS/Source/tasks.c **** 	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );												\
 368:Libraries/FreeRTOS/Source/tasks.c **** 	vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xGenericListItem ) 
 369:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 370:Libraries/FreeRTOS/Source/tasks.c **** 
 371:Libraries/FreeRTOS/Source/tasks.c **** /*
 372:Libraries/FreeRTOS/Source/tasks.c ****  * Several functions take an TaskHandle_t parameter that can optionally be NULL,
 373:Libraries/FreeRTOS/Source/tasks.c ****  * where NULL is used to indicate that the handle of the currently executing
 374:Libraries/FreeRTOS/Source/tasks.c ****  * task should be used in place of the parameter.  This macro simply checks to
 375:Libraries/FreeRTOS/Source/tasks.c ****  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 376:Libraries/FreeRTOS/Source/tasks.c ****  */
 377:Libraries/FreeRTOS/Source/tasks.c **** #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( TCB_t * ) pxCurrentTCB : ( T
 378:Libraries/FreeRTOS/Source/tasks.c **** 
 379:Libraries/FreeRTOS/Source/tasks.c **** /* The item value of the event list item is normally used to hold the priority
 380:Libraries/FreeRTOS/Source/tasks.c **** of the task to which it belongs (coded to allow it to be held in reverse
 381:Libraries/FreeRTOS/Source/tasks.c **** priority order).  However, it is occasionally borrowed for other purposes.  It
 382:Libraries/FreeRTOS/Source/tasks.c **** is important its value is not updated due to a task priority change while it is
 383:Libraries/FreeRTOS/Source/tasks.c **** being used for another purpose.  The following bit definition is used to inform
 384:Libraries/FreeRTOS/Source/tasks.c **** the scheduler that the value should not be changed - in which case it is the
 385:Libraries/FreeRTOS/Source/tasks.c **** responsibility of whichever module is using the value to ensure it gets set back
 386:Libraries/FreeRTOS/Source/tasks.c **** to its original value when it is released. */
 387:Libraries/FreeRTOS/Source/tasks.c **** #if configUSE_16_BIT_TICKS == 1
 388:Libraries/FreeRTOS/Source/tasks.c **** 	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x8000U
 389:Libraries/FreeRTOS/Source/tasks.c **** #else
 390:Libraries/FreeRTOS/Source/tasks.c **** 	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x80000000UL
 391:Libraries/FreeRTOS/Source/tasks.c **** #endif
 392:Libraries/FreeRTOS/Source/tasks.c **** 
 393:Libraries/FreeRTOS/Source/tasks.c **** /* Callback function prototypes. --------------------------*/
 394:Libraries/FreeRTOS/Source/tasks.c **** #if configCHECK_FOR_STACK_OVERFLOW > 0
 395:Libraries/FreeRTOS/Source/tasks.c **** 	extern void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName );
 396:Libraries/FreeRTOS/Source/tasks.c **** #endif
 397:Libraries/FreeRTOS/Source/tasks.c **** 
 398:Libraries/FreeRTOS/Source/tasks.c **** #if configUSE_TICK_HOOK > 0
 399:Libraries/FreeRTOS/Source/tasks.c **** 	extern void vApplicationTickHook( void );
 400:Libraries/FreeRTOS/Source/tasks.c **** #endif
 401:Libraries/FreeRTOS/Source/tasks.c **** 
 402:Libraries/FreeRTOS/Source/tasks.c **** /* File private functions. --------------------------------*/
 403:Libraries/FreeRTOS/Source/tasks.c **** 
 404:Libraries/FreeRTOS/Source/tasks.c **** /*
 405:Libraries/FreeRTOS/Source/tasks.c ****  * Utility to ready a TCB for a given task.  Mainly just copies the parameters
 406:Libraries/FreeRTOS/Source/tasks.c ****  * into the TCB structure.
 407:Libraries/FreeRTOS/Source/tasks.c ****  */
 408:Libraries/FreeRTOS/Source/tasks.c **** static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t 
 409:Libraries/FreeRTOS/Source/tasks.c **** 
 410:Libraries/FreeRTOS/Source/tasks.c **** /**
 411:Libraries/FreeRTOS/Source/tasks.c ****  * Utility task that simply returns pdTRUE if the task referenced by xTask is
 412:Libraries/FreeRTOS/Source/tasks.c ****  * currently in the Suspended state, or pdFALSE if the task referenced by xTask
 413:Libraries/FreeRTOS/Source/tasks.c ****  * is in any other state.
 414:Libraries/FreeRTOS/Source/tasks.c ****  */
 415:Libraries/FreeRTOS/Source/tasks.c **** static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
 416:Libraries/FreeRTOS/Source/tasks.c **** 
 417:Libraries/FreeRTOS/Source/tasks.c **** /*
 418:Libraries/FreeRTOS/Source/tasks.c ****  * Utility to ready all the lists used by the scheduler.  This is called
 419:Libraries/FreeRTOS/Source/tasks.c ****  * automatically upon the creation of the first task.
 420:Libraries/FreeRTOS/Source/tasks.c ****  */
 421:Libraries/FreeRTOS/Source/tasks.c **** static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
 422:Libraries/FreeRTOS/Source/tasks.c **** 
 423:Libraries/FreeRTOS/Source/tasks.c **** /*
 424:Libraries/FreeRTOS/Source/tasks.c ****  * The idle task, which as all tasks is implemented as a never ending loop.
 425:Libraries/FreeRTOS/Source/tasks.c ****  * The idle task is automatically created and added to the ready lists upon
 426:Libraries/FreeRTOS/Source/tasks.c ****  * creation of the first user task.
 427:Libraries/FreeRTOS/Source/tasks.c ****  *
 428:Libraries/FreeRTOS/Source/tasks.c ****  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 429:Libraries/FreeRTOS/Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
 430:Libraries/FreeRTOS/Source/tasks.c ****  *
 431:Libraries/FreeRTOS/Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
 432:Libraries/FreeRTOS/Source/tasks.c ****  *
 433:Libraries/FreeRTOS/Source/tasks.c ****  */
 434:Libraries/FreeRTOS/Source/tasks.c **** static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
 435:Libraries/FreeRTOS/Source/tasks.c **** 
 436:Libraries/FreeRTOS/Source/tasks.c **** /*
 437:Libraries/FreeRTOS/Source/tasks.c ****  * Utility to free all memory allocated by the scheduler to hold a TCB,
 438:Libraries/FreeRTOS/Source/tasks.c ****  * including the stack pointed to by the TCB.
 439:Libraries/FreeRTOS/Source/tasks.c ****  *
 440:Libraries/FreeRTOS/Source/tasks.c ****  * This does not free memory allocated by the task itself (i.e. memory
 441:Libraries/FreeRTOS/Source/tasks.c ****  * allocated by calls to pvPortMalloc from within the tasks application code).
 442:Libraries/FreeRTOS/Source/tasks.c ****  */
 443:Libraries/FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 444:Libraries/FreeRTOS/Source/tasks.c **** 
 445:Libraries/FreeRTOS/Source/tasks.c **** 	static void prvDeleteTCB( TCB_t *pxTCB ) PRIVILEGED_FUNCTION;
 446:Libraries/FreeRTOS/Source/tasks.c **** 
 447:Libraries/FreeRTOS/Source/tasks.c **** #endif
 448:Libraries/FreeRTOS/Source/tasks.c **** 
 449:Libraries/FreeRTOS/Source/tasks.c **** /*
 450:Libraries/FreeRTOS/Source/tasks.c ****  * Used only by the idle task.  This checks to see if anything has been placed
 451:Libraries/FreeRTOS/Source/tasks.c ****  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 452:Libraries/FreeRTOS/Source/tasks.c ****  * and its TCB deleted.
 453:Libraries/FreeRTOS/Source/tasks.c ****  */
 454:Libraries/FreeRTOS/Source/tasks.c **** static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
 455:Libraries/FreeRTOS/Source/tasks.c **** 
 456:Libraries/FreeRTOS/Source/tasks.c **** /*
 457:Libraries/FreeRTOS/Source/tasks.c ****  * The currently executing task is entering the Blocked state.  Add the task to
 458:Libraries/FreeRTOS/Source/tasks.c ****  * either the current or the overflow delayed task list.
 459:Libraries/FreeRTOS/Source/tasks.c ****  */
 460:Libraries/FreeRTOS/Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake ) PRIVILEGED_FUNCTION;
 461:Libraries/FreeRTOS/Source/tasks.c **** 
 462:Libraries/FreeRTOS/Source/tasks.c **** /*
 463:Libraries/FreeRTOS/Source/tasks.c ****  * Allocates memory from the heap for a TCB and associated stack.  Checks the
 464:Libraries/FreeRTOS/Source/tasks.c ****  * allocation was successful.
 465:Libraries/FreeRTOS/Source/tasks.c ****  */
 466:Libraries/FreeRTOS/Source/tasks.c **** static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuff
 467:Libraries/FreeRTOS/Source/tasks.c **** 
 468:Libraries/FreeRTOS/Source/tasks.c **** /*
 469:Libraries/FreeRTOS/Source/tasks.c ****  * Fills an TaskStatus_t structure with information on each task that is
 470:Libraries/FreeRTOS/Source/tasks.c ****  * referenced from the pxList list (which may be a ready list, a delayed list,
 471:Libraries/FreeRTOS/Source/tasks.c ****  * a suspended list, etc.).
 472:Libraries/FreeRTOS/Source/tasks.c ****  *
 473:Libraries/FreeRTOS/Source/tasks.c ****  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 474:Libraries/FreeRTOS/Source/tasks.c ****  * NORMAL APPLICATION CODE.
 475:Libraries/FreeRTOS/Source/tasks.c ****  */
 476:Libraries/FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 477:Libraries/FreeRTOS/Source/tasks.c **** 
 478:Libraries/FreeRTOS/Source/tasks.c **** 	static UBaseType_t prvListTaskWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, e
 479:Libraries/FreeRTOS/Source/tasks.c **** 
 480:Libraries/FreeRTOS/Source/tasks.c **** #endif
 481:Libraries/FreeRTOS/Source/tasks.c **** 
 482:Libraries/FreeRTOS/Source/tasks.c **** /*
 483:Libraries/FreeRTOS/Source/tasks.c ****  * When a task is created, the stack of the task is filled with a known value.
 484:Libraries/FreeRTOS/Source/tasks.c ****  * This function determines the 'high water mark' of the task stack by
 485:Libraries/FreeRTOS/Source/tasks.c ****  * determining how much of the stack remains at the original preset value.
 486:Libraries/FreeRTOS/Source/tasks.c ****  */
 487:Libraries/FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
 488:Libraries/FreeRTOS/Source/tasks.c **** 
 489:Libraries/FreeRTOS/Source/tasks.c **** 	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte ) PRIVILEGED_FUNCTION;
 490:Libraries/FreeRTOS/Source/tasks.c **** 
 491:Libraries/FreeRTOS/Source/tasks.c **** #endif
 492:Libraries/FreeRTOS/Source/tasks.c **** 
 493:Libraries/FreeRTOS/Source/tasks.c **** /*
 494:Libraries/FreeRTOS/Source/tasks.c ****  * Return the amount of time, in ticks, that will pass before the kernel will
 495:Libraries/FreeRTOS/Source/tasks.c ****  * next move a task from the Blocked state to the Running state.
 496:Libraries/FreeRTOS/Source/tasks.c ****  *
 497:Libraries/FreeRTOS/Source/tasks.c ****  * This conditional compilation should use inequality to 0, not equality to 1.
 498:Libraries/FreeRTOS/Source/tasks.c ****  * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
 499:Libraries/FreeRTOS/Source/tasks.c ****  * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
 500:Libraries/FreeRTOS/Source/tasks.c ****  * set to a value other than 1.
 501:Libraries/FreeRTOS/Source/tasks.c ****  */
 502:Libraries/FreeRTOS/Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
 503:Libraries/FreeRTOS/Source/tasks.c **** 
 504:Libraries/FreeRTOS/Source/tasks.c **** 	static TickType_t prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
 505:Libraries/FreeRTOS/Source/tasks.c **** 
 506:Libraries/FreeRTOS/Source/tasks.c **** #endif
 507:Libraries/FreeRTOS/Source/tasks.c **** 
 508:Libraries/FreeRTOS/Source/tasks.c **** /*
 509:Libraries/FreeRTOS/Source/tasks.c ****  * Set xNextTaskUnblockTime to the time at which the next Blocked state task
 510:Libraries/FreeRTOS/Source/tasks.c ****  * will exit the Blocked state.
 511:Libraries/FreeRTOS/Source/tasks.c ****  */
 512:Libraries/FreeRTOS/Source/tasks.c **** static void prvResetNextTaskUnblockTime( void );
 513:Libraries/FreeRTOS/Source/tasks.c **** 
 514:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 515:Libraries/FreeRTOS/Source/tasks.c **** 
 516:Libraries/FreeRTOS/Source/tasks.c **** BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t
 517:Libraries/FreeRTOS/Source/tasks.c **** {
 518:Libraries/FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
 519:Libraries/FreeRTOS/Source/tasks.c **** TCB_t * pxNewTCB;
 520:Libraries/FreeRTOS/Source/tasks.c **** 
 521:Libraries/FreeRTOS/Source/tasks.c **** 	configASSERT( pxTaskCode );
 522:Libraries/FreeRTOS/Source/tasks.c **** 	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );
 523:Libraries/FreeRTOS/Source/tasks.c **** 
 524:Libraries/FreeRTOS/Source/tasks.c **** 	/* Allocate the memory required by the TCB and stack for the new task,
 525:Libraries/FreeRTOS/Source/tasks.c **** 	checking that the allocation was successful. */
 526:Libraries/FreeRTOS/Source/tasks.c **** 	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
 527:Libraries/FreeRTOS/Source/tasks.c **** 
 528:Libraries/FreeRTOS/Source/tasks.c **** 	if( pxNewTCB != NULL )
 529:Libraries/FreeRTOS/Source/tasks.c **** 	{
 530:Libraries/FreeRTOS/Source/tasks.c **** 		StackType_t *pxTopOfStack;
 531:Libraries/FreeRTOS/Source/tasks.c **** 
 532:Libraries/FreeRTOS/Source/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 533:Libraries/FreeRTOS/Source/tasks.c **** 			/* Should the task be created in privileged mode? */
 534:Libraries/FreeRTOS/Source/tasks.c **** 			BaseType_t xRunPrivileged;
 535:Libraries/FreeRTOS/Source/tasks.c **** 			if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
 536:Libraries/FreeRTOS/Source/tasks.c **** 			{
 537:Libraries/FreeRTOS/Source/tasks.c **** 				xRunPrivileged = pdTRUE;
 538:Libraries/FreeRTOS/Source/tasks.c **** 			}
 539:Libraries/FreeRTOS/Source/tasks.c **** 			else
 540:Libraries/FreeRTOS/Source/tasks.c **** 			{
 541:Libraries/FreeRTOS/Source/tasks.c **** 				xRunPrivileged = pdFALSE;
 542:Libraries/FreeRTOS/Source/tasks.c **** 			}
 543:Libraries/FreeRTOS/Source/tasks.c **** 			uxPriority &= ~portPRIVILEGE_BIT;
 544:Libraries/FreeRTOS/Source/tasks.c **** 		#endif /* portUSING_MPU_WRAPPERS == 1 */
 545:Libraries/FreeRTOS/Source/tasks.c **** 
 546:Libraries/FreeRTOS/Source/tasks.c **** 		/* Calculate the top of stack address.  This depends on whether the
 547:Libraries/FreeRTOS/Source/tasks.c **** 		stack grows from high memory to low (as per the 80x86) or vice versa.
 548:Libraries/FreeRTOS/Source/tasks.c **** 		portSTACK_GROWTH is used to make the result positive or negative as
 549:Libraries/FreeRTOS/Source/tasks.c **** 		required by the port. */
 550:Libraries/FreeRTOS/Source/tasks.c **** 		#if( portSTACK_GROWTH < 0 )
 551:Libraries/FreeRTOS/Source/tasks.c **** 		{
 552:Libraries/FreeRTOS/Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
 553:Libraries/FreeRTOS/Source/tasks.c **** 			pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINTER_
 554:Libraries/FreeRTOS/Source/tasks.c **** 
 555:Libraries/FreeRTOS/Source/tasks.c **** 			/* Check the alignment of the calculated top of stack is correct. */
 556:Libraries/FreeRTOS/Source/tasks.c **** 			configASSERT( ( ( ( uint32_t ) pxTopOfStack & ( uint32_t ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
 557:Libraries/FreeRTOS/Source/tasks.c **** 		}
 558:Libraries/FreeRTOS/Source/tasks.c **** 		#else /* portSTACK_GROWTH */
 559:Libraries/FreeRTOS/Source/tasks.c **** 		{
 560:Libraries/FreeRTOS/Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack;
 561:Libraries/FreeRTOS/Source/tasks.c **** 
 562:Libraries/FreeRTOS/Source/tasks.c **** 			/* Check the alignment of the stack buffer is correct. */
 563:Libraries/FreeRTOS/Source/tasks.c **** 			configASSERT( ( ( ( uint32_t ) pxNewTCB->pxStack & ( uint32_t ) portBYTE_ALIGNMENT_MASK ) == 0UL
 564:Libraries/FreeRTOS/Source/tasks.c **** 
 565:Libraries/FreeRTOS/Source/tasks.c **** 			/* If we want to use stack checking on architectures that use
 566:Libraries/FreeRTOS/Source/tasks.c **** 			a positive stack growth direction then we also need to store the
 567:Libraries/FreeRTOS/Source/tasks.c **** 			other extreme of the stack space. */
 568:Libraries/FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 569:Libraries/FreeRTOS/Source/tasks.c **** 		}
 570:Libraries/FreeRTOS/Source/tasks.c **** 		#endif /* portSTACK_GROWTH */
 571:Libraries/FreeRTOS/Source/tasks.c **** 
 572:Libraries/FreeRTOS/Source/tasks.c **** 		/* Setup the newly allocated TCB with the initial state of the task. */
 573:Libraries/FreeRTOS/Source/tasks.c **** 		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
 574:Libraries/FreeRTOS/Source/tasks.c **** 
 575:Libraries/FreeRTOS/Source/tasks.c **** 		/* Initialize the TCB stack to look as if the task was already running,
 576:Libraries/FreeRTOS/Source/tasks.c **** 		but had been interrupted by the scheduler.  The return address is set
 577:Libraries/FreeRTOS/Source/tasks.c **** 		to the start of the task function. Once the stack has been initialised
 578:Libraries/FreeRTOS/Source/tasks.c **** 		the	top of stack variable is updated. */
 579:Libraries/FreeRTOS/Source/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 580:Libraries/FreeRTOS/Source/tasks.c **** 		{
 581:Libraries/FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPriv
 582:Libraries/FreeRTOS/Source/tasks.c **** 		}
 583:Libraries/FreeRTOS/Source/tasks.c **** 		#else /* portUSING_MPU_WRAPPERS */
 584:Libraries/FreeRTOS/Source/tasks.c **** 		{
 585:Libraries/FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 586:Libraries/FreeRTOS/Source/tasks.c **** 		}
 587:Libraries/FreeRTOS/Source/tasks.c **** 		#endif /* portUSING_MPU_WRAPPERS */
 588:Libraries/FreeRTOS/Source/tasks.c **** 
 589:Libraries/FreeRTOS/Source/tasks.c **** 		if( ( void * ) pxCreatedTask != NULL )
 590:Libraries/FreeRTOS/Source/tasks.c **** 		{
 591:Libraries/FreeRTOS/Source/tasks.c **** 			/* Pass the TCB out - in an anonymous way.  The calling function/
 592:Libraries/FreeRTOS/Source/tasks.c **** 			task can use this as a handle to delete the task later if
 593:Libraries/FreeRTOS/Source/tasks.c **** 			required.*/
 594:Libraries/FreeRTOS/Source/tasks.c **** 			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 595:Libraries/FreeRTOS/Source/tasks.c **** 		}
 596:Libraries/FreeRTOS/Source/tasks.c **** 		else
 597:Libraries/FreeRTOS/Source/tasks.c **** 		{
 598:Libraries/FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
 599:Libraries/FreeRTOS/Source/tasks.c **** 		}
 600:Libraries/FreeRTOS/Source/tasks.c **** 
 601:Libraries/FreeRTOS/Source/tasks.c **** 		/* Ensure interrupts don't access the task lists while they are being
 602:Libraries/FreeRTOS/Source/tasks.c **** 		updated. */
 603:Libraries/FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 604:Libraries/FreeRTOS/Source/tasks.c **** 		{
 605:Libraries/FreeRTOS/Source/tasks.c **** 			uxCurrentNumberOfTasks++;
 606:Libraries/FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB == NULL )
 607:Libraries/FreeRTOS/Source/tasks.c **** 			{
 608:Libraries/FreeRTOS/Source/tasks.c **** 				/* There are no other tasks, or all the other tasks are in
 609:Libraries/FreeRTOS/Source/tasks.c **** 				the suspended state - make this the current task. */
 610:Libraries/FreeRTOS/Source/tasks.c **** 				pxCurrentTCB =  pxNewTCB;
 611:Libraries/FreeRTOS/Source/tasks.c **** 
 612:Libraries/FreeRTOS/Source/tasks.c **** 				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 613:Libraries/FreeRTOS/Source/tasks.c **** 				{
 614:Libraries/FreeRTOS/Source/tasks.c **** 					/* This is the first task to be created so do the preliminary
 615:Libraries/FreeRTOS/Source/tasks.c **** 					initialisation required.  We will not recover if this call
 616:Libraries/FreeRTOS/Source/tasks.c **** 					fails, but we will report the failure. */
 617:Libraries/FreeRTOS/Source/tasks.c **** 					prvInitialiseTaskLists();
 618:Libraries/FreeRTOS/Source/tasks.c **** 				}
 619:Libraries/FreeRTOS/Source/tasks.c **** 				else
 620:Libraries/FreeRTOS/Source/tasks.c **** 				{
 621:Libraries/FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
 622:Libraries/FreeRTOS/Source/tasks.c **** 				}
 623:Libraries/FreeRTOS/Source/tasks.c **** 			}
 624:Libraries/FreeRTOS/Source/tasks.c **** 			else
 625:Libraries/FreeRTOS/Source/tasks.c **** 			{
 626:Libraries/FreeRTOS/Source/tasks.c **** 				/* If the scheduler is not already running, make this task the
 627:Libraries/FreeRTOS/Source/tasks.c **** 				current task if it is the highest priority task to be created
 628:Libraries/FreeRTOS/Source/tasks.c **** 				so far. */
 629:Libraries/FreeRTOS/Source/tasks.c **** 				if( xSchedulerRunning == pdFALSE )
 630:Libraries/FreeRTOS/Source/tasks.c **** 				{
 631:Libraries/FreeRTOS/Source/tasks.c **** 					if( pxCurrentTCB->uxPriority <= uxPriority )
 632:Libraries/FreeRTOS/Source/tasks.c **** 					{
 633:Libraries/FreeRTOS/Source/tasks.c **** 						pxCurrentTCB = pxNewTCB;
 634:Libraries/FreeRTOS/Source/tasks.c **** 					}
 635:Libraries/FreeRTOS/Source/tasks.c **** 					else
 636:Libraries/FreeRTOS/Source/tasks.c **** 					{
 637:Libraries/FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
 638:Libraries/FreeRTOS/Source/tasks.c **** 					}
 639:Libraries/FreeRTOS/Source/tasks.c **** 				}
 640:Libraries/FreeRTOS/Source/tasks.c **** 				else
 641:Libraries/FreeRTOS/Source/tasks.c **** 				{
 642:Libraries/FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
 643:Libraries/FreeRTOS/Source/tasks.c **** 				}
 644:Libraries/FreeRTOS/Source/tasks.c **** 			}
 645:Libraries/FreeRTOS/Source/tasks.c **** 
 646:Libraries/FreeRTOS/Source/tasks.c **** 			uxTaskNumber++;
 647:Libraries/FreeRTOS/Source/tasks.c **** 
 648:Libraries/FreeRTOS/Source/tasks.c **** 			#if ( configUSE_TRACE_FACILITY == 1 )
 649:Libraries/FreeRTOS/Source/tasks.c **** 			{
 650:Libraries/FreeRTOS/Source/tasks.c **** 				/* Add a counter into the TCB for tracing only. */
 651:Libraries/FreeRTOS/Source/tasks.c **** 				pxNewTCB->uxTCBNumber = uxTaskNumber;
 652:Libraries/FreeRTOS/Source/tasks.c **** 			}
 653:Libraries/FreeRTOS/Source/tasks.c **** 			#endif /* configUSE_TRACE_FACILITY */
 654:Libraries/FreeRTOS/Source/tasks.c **** 			traceTASK_CREATE( pxNewTCB );
 655:Libraries/FreeRTOS/Source/tasks.c **** 
 656:Libraries/FreeRTOS/Source/tasks.c **** 			prvAddTaskToReadyList( pxNewTCB );
 657:Libraries/FreeRTOS/Source/tasks.c **** 
 658:Libraries/FreeRTOS/Source/tasks.c **** 			xReturn = pdPASS;
 659:Libraries/FreeRTOS/Source/tasks.c **** 			portSETUP_TCB( pxNewTCB );
 660:Libraries/FreeRTOS/Source/tasks.c **** 		}
 661:Libraries/FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 662:Libraries/FreeRTOS/Source/tasks.c **** 	}
 663:Libraries/FreeRTOS/Source/tasks.c **** 	else
 664:Libraries/FreeRTOS/Source/tasks.c **** 	{
 665:Libraries/FreeRTOS/Source/tasks.c **** 		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 666:Libraries/FreeRTOS/Source/tasks.c **** 		traceTASK_CREATE_FAILED();
 667:Libraries/FreeRTOS/Source/tasks.c **** 	}
 668:Libraries/FreeRTOS/Source/tasks.c **** 
 669:Libraries/FreeRTOS/Source/tasks.c **** 	if( xReturn == pdPASS )
 670:Libraries/FreeRTOS/Source/tasks.c **** 	{
 671:Libraries/FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 672:Libraries/FreeRTOS/Source/tasks.c **** 		{
 673:Libraries/FreeRTOS/Source/tasks.c **** 			/* If the created task is of a higher priority than the current task
 674:Libraries/FreeRTOS/Source/tasks.c **** 			then it should run now. */
 675:Libraries/FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->uxPriority < uxPriority )
 676:Libraries/FreeRTOS/Source/tasks.c **** 			{
 677:Libraries/FreeRTOS/Source/tasks.c **** 				taskYIELD_IF_USING_PREEMPTION();
 678:Libraries/FreeRTOS/Source/tasks.c **** 			}
 679:Libraries/FreeRTOS/Source/tasks.c **** 			else
 680:Libraries/FreeRTOS/Source/tasks.c **** 			{
 681:Libraries/FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
 682:Libraries/FreeRTOS/Source/tasks.c **** 			}
 683:Libraries/FreeRTOS/Source/tasks.c **** 		}
 684:Libraries/FreeRTOS/Source/tasks.c **** 		else
 685:Libraries/FreeRTOS/Source/tasks.c **** 		{
 686:Libraries/FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
 687:Libraries/FreeRTOS/Source/tasks.c **** 		}
 688:Libraries/FreeRTOS/Source/tasks.c **** 	}
 689:Libraries/FreeRTOS/Source/tasks.c **** 
 690:Libraries/FreeRTOS/Source/tasks.c **** 	return xReturn;
 691:Libraries/FreeRTOS/Source/tasks.c **** }
 692:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 693:Libraries/FreeRTOS/Source/tasks.c **** 
 694:Libraries/FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 695:Libraries/FreeRTOS/Source/tasks.c **** 
 696:Libraries/FreeRTOS/Source/tasks.c **** 	void vTaskDelete( TaskHandle_t xTaskToDelete )
 697:Libraries/FreeRTOS/Source/tasks.c **** 	{
 698:Libraries/FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
 699:Libraries/FreeRTOS/Source/tasks.c **** 
 700:Libraries/FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 701:Libraries/FreeRTOS/Source/tasks.c **** 		{
 702:Libraries/FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then it is the calling task that is
 703:Libraries/FreeRTOS/Source/tasks.c **** 			being deleted. */
 704:Libraries/FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 705:Libraries/FreeRTOS/Source/tasks.c **** 
 706:Libraries/FreeRTOS/Source/tasks.c **** 			/* Remove task from the ready list and place in the	termination list.
 707:Libraries/FreeRTOS/Source/tasks.c **** 			This will stop the task from be scheduled.  The idle task will check
 708:Libraries/FreeRTOS/Source/tasks.c **** 			the termination list and free up any memory allocated by the
 709:Libraries/FreeRTOS/Source/tasks.c **** 			scheduler for the TCB and stack. */
 710:Libraries/FreeRTOS/Source/tasks.c **** 			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 711:Libraries/FreeRTOS/Source/tasks.c **** 			{
 712:Libraries/FreeRTOS/Source/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 713:Libraries/FreeRTOS/Source/tasks.c **** 			}
 714:Libraries/FreeRTOS/Source/tasks.c **** 			else
 715:Libraries/FreeRTOS/Source/tasks.c **** 			{
 716:Libraries/FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
 717:Libraries/FreeRTOS/Source/tasks.c **** 			}
 718:Libraries/FreeRTOS/Source/tasks.c **** 
 719:Libraries/FreeRTOS/Source/tasks.c **** 			/* Is the task waiting on an event also? */
 720:Libraries/FreeRTOS/Source/tasks.c **** 			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 721:Libraries/FreeRTOS/Source/tasks.c **** 			{
 722:Libraries/FreeRTOS/Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 723:Libraries/FreeRTOS/Source/tasks.c **** 			}
 724:Libraries/FreeRTOS/Source/tasks.c **** 			else
 725:Libraries/FreeRTOS/Source/tasks.c **** 			{
 726:Libraries/FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
 727:Libraries/FreeRTOS/Source/tasks.c **** 			}
 728:Libraries/FreeRTOS/Source/tasks.c **** 
 729:Libraries/FreeRTOS/Source/tasks.c **** 			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
 730:Libraries/FreeRTOS/Source/tasks.c **** 
 731:Libraries/FreeRTOS/Source/tasks.c **** 			/* Increment the ucTasksDeleted variable so the idle task knows
 732:Libraries/FreeRTOS/Source/tasks.c **** 			there is a task that has been deleted and that it should therefore
 733:Libraries/FreeRTOS/Source/tasks.c **** 			check the xTasksWaitingTermination list. */
 734:Libraries/FreeRTOS/Source/tasks.c **** 			++uxTasksDeleted;
 735:Libraries/FreeRTOS/Source/tasks.c **** 
 736:Libraries/FreeRTOS/Source/tasks.c **** 			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
 737:Libraries/FreeRTOS/Source/tasks.c **** 			can detect that the task lists need re-generating. */
 738:Libraries/FreeRTOS/Source/tasks.c **** 			uxTaskNumber++;
 739:Libraries/FreeRTOS/Source/tasks.c **** 
 740:Libraries/FreeRTOS/Source/tasks.c **** 			traceTASK_DELETE( pxTCB );
 741:Libraries/FreeRTOS/Source/tasks.c **** 		}
 742:Libraries/FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 743:Libraries/FreeRTOS/Source/tasks.c **** 
 744:Libraries/FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if it is the currently running task that has just
 745:Libraries/FreeRTOS/Source/tasks.c **** 		been deleted. */
 746:Libraries/FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 747:Libraries/FreeRTOS/Source/tasks.c **** 		{
 748:Libraries/FreeRTOS/Source/tasks.c **** 			if( pxTCB == pxCurrentTCB )
 749:Libraries/FreeRTOS/Source/tasks.c **** 			{
 750:Libraries/FreeRTOS/Source/tasks.c **** 				configASSERT( uxSchedulerSuspended == 0 );
 751:Libraries/FreeRTOS/Source/tasks.c **** 
 752:Libraries/FreeRTOS/Source/tasks.c **** 				/* The pre-delete hook is primarily for the Windows simulator,
 753:Libraries/FreeRTOS/Source/tasks.c **** 				in which Windows specific clean up operations are performed,
 754:Libraries/FreeRTOS/Source/tasks.c **** 				after which it is not possible to yield away from this task -
 755:Libraries/FreeRTOS/Source/tasks.c **** 				hence xYieldPending is used to latch that a context switch is
 756:Libraries/FreeRTOS/Source/tasks.c **** 				required. */
 757:Libraries/FreeRTOS/Source/tasks.c **** 				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
 758:Libraries/FreeRTOS/Source/tasks.c **** 				portYIELD_WITHIN_API();
 759:Libraries/FreeRTOS/Source/tasks.c **** 			}
 760:Libraries/FreeRTOS/Source/tasks.c **** 			else
 761:Libraries/FreeRTOS/Source/tasks.c **** 			{
 762:Libraries/FreeRTOS/Source/tasks.c **** 				/* Reset the next expected unblock time in case it referred to
 763:Libraries/FreeRTOS/Source/tasks.c **** 				the task that has just been deleted. */
 764:Libraries/FreeRTOS/Source/tasks.c **** 				taskENTER_CRITICAL();
 765:Libraries/FreeRTOS/Source/tasks.c **** 				{
 766:Libraries/FreeRTOS/Source/tasks.c **** 					prvResetNextTaskUnblockTime();
 767:Libraries/FreeRTOS/Source/tasks.c **** 				}
 768:Libraries/FreeRTOS/Source/tasks.c **** 				taskEXIT_CRITICAL();
 769:Libraries/FreeRTOS/Source/tasks.c **** 			}
 770:Libraries/FreeRTOS/Source/tasks.c **** 		}
 771:Libraries/FreeRTOS/Source/tasks.c **** 	}
 772:Libraries/FreeRTOS/Source/tasks.c **** 
 773:Libraries/FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskDelete */
 774:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 775:Libraries/FreeRTOS/Source/tasks.c **** 
 776:Libraries/FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelayUntil == 1 )
 777:Libraries/FreeRTOS/Source/tasks.c **** 
 778:Libraries/FreeRTOS/Source/tasks.c **** 	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
 779:Libraries/FreeRTOS/Source/tasks.c **** 	{
 780:Libraries/FreeRTOS/Source/tasks.c **** 	TickType_t xTimeToWake;
 781:Libraries/FreeRTOS/Source/tasks.c **** 	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
 782:Libraries/FreeRTOS/Source/tasks.c **** 
 783:Libraries/FreeRTOS/Source/tasks.c **** 		configASSERT( pxPreviousWakeTime );
 784:Libraries/FreeRTOS/Source/tasks.c **** 		configASSERT( ( xTimeIncrement > 0U ) );
 785:Libraries/FreeRTOS/Source/tasks.c **** 		configASSERT( uxSchedulerSuspended == 0 );
 786:Libraries/FreeRTOS/Source/tasks.c **** 
 787:Libraries/FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
 788:Libraries/FreeRTOS/Source/tasks.c **** 		{
 789:Libraries/FreeRTOS/Source/tasks.c **** 			/* Minor optimisation.  The tick count cannot change in this
 790:Libraries/FreeRTOS/Source/tasks.c **** 			block. */
 791:Libraries/FreeRTOS/Source/tasks.c **** 			const TickType_t xConstTickCount = xTickCount;
 792:Libraries/FreeRTOS/Source/tasks.c **** 
 793:Libraries/FreeRTOS/Source/tasks.c **** 			/* Generate the tick time at which the task wants to wake. */
 794:Libraries/FreeRTOS/Source/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 795:Libraries/FreeRTOS/Source/tasks.c **** 
 796:Libraries/FreeRTOS/Source/tasks.c **** 			if( xConstTickCount < *pxPreviousWakeTime )
 797:Libraries/FreeRTOS/Source/tasks.c **** 			{
 798:Libraries/FreeRTOS/Source/tasks.c **** 				/* The tick count has overflowed since this function was
 799:Libraries/FreeRTOS/Source/tasks.c **** 				lasted called.  In this case the only time we should ever
 800:Libraries/FreeRTOS/Source/tasks.c **** 				actually delay is if the wake time has also	overflowed,
 801:Libraries/FreeRTOS/Source/tasks.c **** 				and the wake time is greater than the tick time.  When this
 802:Libraries/FreeRTOS/Source/tasks.c **** 				is the case it is as if neither time had overflowed. */
 803:Libraries/FreeRTOS/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
 804:Libraries/FreeRTOS/Source/tasks.c **** 				{
 805:Libraries/FreeRTOS/Source/tasks.c **** 					xShouldDelay = pdTRUE;
 806:Libraries/FreeRTOS/Source/tasks.c **** 				}
 807:Libraries/FreeRTOS/Source/tasks.c **** 				else
 808:Libraries/FreeRTOS/Source/tasks.c **** 				{
 809:Libraries/FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
 810:Libraries/FreeRTOS/Source/tasks.c **** 				}
 811:Libraries/FreeRTOS/Source/tasks.c **** 			}
 812:Libraries/FreeRTOS/Source/tasks.c **** 			else
 813:Libraries/FreeRTOS/Source/tasks.c **** 			{
 814:Libraries/FreeRTOS/Source/tasks.c **** 				/* The tick time has not overflowed.  In this case we will
 815:Libraries/FreeRTOS/Source/tasks.c **** 				delay if either the wake time has overflowed, and/or the
 816:Libraries/FreeRTOS/Source/tasks.c **** 				tick time is less than the wake time. */
 817:Libraries/FreeRTOS/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
 818:Libraries/FreeRTOS/Source/tasks.c **** 				{
 819:Libraries/FreeRTOS/Source/tasks.c **** 					xShouldDelay = pdTRUE;
 820:Libraries/FreeRTOS/Source/tasks.c **** 				}
 821:Libraries/FreeRTOS/Source/tasks.c **** 				else
 822:Libraries/FreeRTOS/Source/tasks.c **** 				{
 823:Libraries/FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
 824:Libraries/FreeRTOS/Source/tasks.c **** 				}
 825:Libraries/FreeRTOS/Source/tasks.c **** 			}
 826:Libraries/FreeRTOS/Source/tasks.c **** 
 827:Libraries/FreeRTOS/Source/tasks.c **** 			/* Update the wake time ready for the next call. */
 828:Libraries/FreeRTOS/Source/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
 829:Libraries/FreeRTOS/Source/tasks.c **** 
 830:Libraries/FreeRTOS/Source/tasks.c **** 			if( xShouldDelay != pdFALSE )
 831:Libraries/FreeRTOS/Source/tasks.c **** 			{
 832:Libraries/FreeRTOS/Source/tasks.c **** 				traceTASK_DELAY_UNTIL();
 833:Libraries/FreeRTOS/Source/tasks.c **** 
 834:Libraries/FreeRTOS/Source/tasks.c **** 				/* Remove the task from the ready list before adding it to the
 835:Libraries/FreeRTOS/Source/tasks.c **** 				blocked list as the same list item is used for both lists. */
 836:Libraries/FreeRTOS/Source/tasks.c **** 				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 837:Libraries/FreeRTOS/Source/tasks.c **** 				{
 838:Libraries/FreeRTOS/Source/tasks.c **** 					/* The current task must be in a ready list, so there is
 839:Libraries/FreeRTOS/Source/tasks.c **** 					no need to check, and the port reset macro can be called
 840:Libraries/FreeRTOS/Source/tasks.c **** 					directly. */
 841:Libraries/FreeRTOS/Source/tasks.c **** 					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 842:Libraries/FreeRTOS/Source/tasks.c **** 				}
 843:Libraries/FreeRTOS/Source/tasks.c **** 				else
 844:Libraries/FreeRTOS/Source/tasks.c **** 				{
 845:Libraries/FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
 846:Libraries/FreeRTOS/Source/tasks.c **** 				}
 847:Libraries/FreeRTOS/Source/tasks.c **** 
 848:Libraries/FreeRTOS/Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 849:Libraries/FreeRTOS/Source/tasks.c **** 			}
 850:Libraries/FreeRTOS/Source/tasks.c **** 			else
 851:Libraries/FreeRTOS/Source/tasks.c **** 			{
 852:Libraries/FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
 853:Libraries/FreeRTOS/Source/tasks.c **** 			}
 854:Libraries/FreeRTOS/Source/tasks.c **** 		}
 855:Libraries/FreeRTOS/Source/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
 856:Libraries/FreeRTOS/Source/tasks.c **** 
 857:Libraries/FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 858:Libraries/FreeRTOS/Source/tasks.c **** 		have put ourselves to sleep. */
 859:Libraries/FreeRTOS/Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 860:Libraries/FreeRTOS/Source/tasks.c **** 		{
 861:Libraries/FreeRTOS/Source/tasks.c **** 			portYIELD_WITHIN_API();
 862:Libraries/FreeRTOS/Source/tasks.c **** 		}
 863:Libraries/FreeRTOS/Source/tasks.c **** 		else
 864:Libraries/FreeRTOS/Source/tasks.c **** 		{
 865:Libraries/FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
 866:Libraries/FreeRTOS/Source/tasks.c **** 		}
 867:Libraries/FreeRTOS/Source/tasks.c **** 	}
 868:Libraries/FreeRTOS/Source/tasks.c **** 
 869:Libraries/FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskDelayUntil */
 870:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 871:Libraries/FreeRTOS/Source/tasks.c **** 
 872:Libraries/FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelay == 1 )
 873:Libraries/FreeRTOS/Source/tasks.c **** 
 874:Libraries/FreeRTOS/Source/tasks.c **** 	void vTaskDelay( const TickType_t xTicksToDelay )
 875:Libraries/FreeRTOS/Source/tasks.c **** 	{
 876:Libraries/FreeRTOS/Source/tasks.c **** 	TickType_t xTimeToWake;
 877:Libraries/FreeRTOS/Source/tasks.c **** 	BaseType_t xAlreadyYielded = pdFALSE;
 878:Libraries/FreeRTOS/Source/tasks.c **** 
 879:Libraries/FreeRTOS/Source/tasks.c **** 
 880:Libraries/FreeRTOS/Source/tasks.c **** 		/* A delay time of zero just forces a reschedule. */
 881:Libraries/FreeRTOS/Source/tasks.c **** 		if( xTicksToDelay > ( TickType_t ) 0U )
 882:Libraries/FreeRTOS/Source/tasks.c **** 		{
 883:Libraries/FreeRTOS/Source/tasks.c **** 			configASSERT( uxSchedulerSuspended == 0 );
 884:Libraries/FreeRTOS/Source/tasks.c **** 			vTaskSuspendAll();
 885:Libraries/FreeRTOS/Source/tasks.c **** 			{
 886:Libraries/FreeRTOS/Source/tasks.c **** 				traceTASK_DELAY();
 887:Libraries/FreeRTOS/Source/tasks.c **** 
 888:Libraries/FreeRTOS/Source/tasks.c **** 				/* A task that is removed from the event list while the
 889:Libraries/FreeRTOS/Source/tasks.c **** 				scheduler is suspended will not get placed in the ready
 890:Libraries/FreeRTOS/Source/tasks.c **** 				list or removed from the blocked list until the scheduler
 891:Libraries/FreeRTOS/Source/tasks.c **** 				is resumed.
 892:Libraries/FreeRTOS/Source/tasks.c **** 
 893:Libraries/FreeRTOS/Source/tasks.c **** 				This task cannot be in an event list as it is the currently
 894:Libraries/FreeRTOS/Source/tasks.c **** 				executing task. */
 895:Libraries/FreeRTOS/Source/tasks.c **** 
 896:Libraries/FreeRTOS/Source/tasks.c **** 				/* Calculate the time to wake - this may overflow but this is
 897:Libraries/FreeRTOS/Source/tasks.c **** 				not a problem. */
 898:Libraries/FreeRTOS/Source/tasks.c **** 				xTimeToWake = xTickCount + xTicksToDelay;
 899:Libraries/FreeRTOS/Source/tasks.c **** 
 900:Libraries/FreeRTOS/Source/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 901:Libraries/FreeRTOS/Source/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 902:Libraries/FreeRTOS/Source/tasks.c **** 				both lists. */
 903:Libraries/FreeRTOS/Source/tasks.c **** 				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 904:Libraries/FreeRTOS/Source/tasks.c **** 				{
 905:Libraries/FreeRTOS/Source/tasks.c **** 					/* The current task must be in a ready list, so there is
 906:Libraries/FreeRTOS/Source/tasks.c **** 					no need to check, and the port reset macro can be called
 907:Libraries/FreeRTOS/Source/tasks.c **** 					directly. */
 908:Libraries/FreeRTOS/Source/tasks.c **** 					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 909:Libraries/FreeRTOS/Source/tasks.c **** 				}
 910:Libraries/FreeRTOS/Source/tasks.c **** 				else
 911:Libraries/FreeRTOS/Source/tasks.c **** 				{
 912:Libraries/FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
 913:Libraries/FreeRTOS/Source/tasks.c **** 				}
 914:Libraries/FreeRTOS/Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 915:Libraries/FreeRTOS/Source/tasks.c **** 			}
 916:Libraries/FreeRTOS/Source/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
 917:Libraries/FreeRTOS/Source/tasks.c **** 		}
 918:Libraries/FreeRTOS/Source/tasks.c **** 		else
 919:Libraries/FreeRTOS/Source/tasks.c **** 		{
 920:Libraries/FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
 921:Libraries/FreeRTOS/Source/tasks.c **** 		}
 922:Libraries/FreeRTOS/Source/tasks.c **** 
 923:Libraries/FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 924:Libraries/FreeRTOS/Source/tasks.c **** 		have put ourselves to sleep. */
 925:Libraries/FreeRTOS/Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 926:Libraries/FreeRTOS/Source/tasks.c **** 		{
 927:Libraries/FreeRTOS/Source/tasks.c **** 			portYIELD_WITHIN_API();
 928:Libraries/FreeRTOS/Source/tasks.c **** 		}
 929:Libraries/FreeRTOS/Source/tasks.c **** 		else
 930:Libraries/FreeRTOS/Source/tasks.c **** 		{
 931:Libraries/FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
 932:Libraries/FreeRTOS/Source/tasks.c **** 		}
 933:Libraries/FreeRTOS/Source/tasks.c **** 	}
 934:Libraries/FreeRTOS/Source/tasks.c **** 
 935:Libraries/FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskDelay */
 936:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 937:Libraries/FreeRTOS/Source/tasks.c **** 
 938:Libraries/FreeRTOS/Source/tasks.c **** #if ( INCLUDE_eTaskGetState == 1 )
 939:Libraries/FreeRTOS/Source/tasks.c **** 
 940:Libraries/FreeRTOS/Source/tasks.c **** 	eTaskState eTaskGetState( TaskHandle_t xTask )
 941:Libraries/FreeRTOS/Source/tasks.c **** 	{
 942:Libraries/FreeRTOS/Source/tasks.c **** 	eTaskState eReturn;
 943:Libraries/FreeRTOS/Source/tasks.c **** 	List_t *pxStateList;
 944:Libraries/FreeRTOS/Source/tasks.c **** 	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
 945:Libraries/FreeRTOS/Source/tasks.c **** 
 946:Libraries/FreeRTOS/Source/tasks.c **** 		configASSERT( pxTCB );
 947:Libraries/FreeRTOS/Source/tasks.c **** 
 948:Libraries/FreeRTOS/Source/tasks.c **** 		if( pxTCB == pxCurrentTCB )
 949:Libraries/FreeRTOS/Source/tasks.c **** 		{
 950:Libraries/FreeRTOS/Source/tasks.c **** 			/* The task calling this function is querying its own state. */
 951:Libraries/FreeRTOS/Source/tasks.c **** 			eReturn = eRunning;
 952:Libraries/FreeRTOS/Source/tasks.c **** 		}
 953:Libraries/FreeRTOS/Source/tasks.c **** 		else
 954:Libraries/FreeRTOS/Source/tasks.c **** 		{
 955:Libraries/FreeRTOS/Source/tasks.c **** 			taskENTER_CRITICAL();
 956:Libraries/FreeRTOS/Source/tasks.c **** 			{
 957:Libraries/FreeRTOS/Source/tasks.c **** 				pxStateList = ( List_t * ) listLIST_ITEM_CONTAINER( &( pxTCB->xGenericListItem ) );
 958:Libraries/FreeRTOS/Source/tasks.c **** 			}
 959:Libraries/FreeRTOS/Source/tasks.c **** 			taskEXIT_CRITICAL();
 960:Libraries/FreeRTOS/Source/tasks.c **** 
 961:Libraries/FreeRTOS/Source/tasks.c **** 			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
 962:Libraries/FreeRTOS/Source/tasks.c **** 			{
 963:Libraries/FreeRTOS/Source/tasks.c **** 				/* The task being queried is referenced from one of the Blocked
 964:Libraries/FreeRTOS/Source/tasks.c **** 				lists. */
 965:Libraries/FreeRTOS/Source/tasks.c **** 				eReturn = eBlocked;
 966:Libraries/FreeRTOS/Source/tasks.c **** 			}
 967:Libraries/FreeRTOS/Source/tasks.c **** 
 968:Libraries/FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
 969:Libraries/FreeRTOS/Source/tasks.c **** 				else if( pxStateList == &xSuspendedTaskList )
 970:Libraries/FreeRTOS/Source/tasks.c **** 				{
 971:Libraries/FreeRTOS/Source/tasks.c **** 					/* The task being queried is referenced from the suspended
 972:Libraries/FreeRTOS/Source/tasks.c **** 					list.  Is it genuinely suspended or is it block
 973:Libraries/FreeRTOS/Source/tasks.c **** 					indefinitely? */
 974:Libraries/FreeRTOS/Source/tasks.c **** 					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
 975:Libraries/FreeRTOS/Source/tasks.c **** 					{
 976:Libraries/FreeRTOS/Source/tasks.c **** 						eReturn = eSuspended;
 977:Libraries/FreeRTOS/Source/tasks.c **** 					}
 978:Libraries/FreeRTOS/Source/tasks.c **** 					else
 979:Libraries/FreeRTOS/Source/tasks.c **** 					{
 980:Libraries/FreeRTOS/Source/tasks.c **** 						eReturn = eBlocked;
 981:Libraries/FreeRTOS/Source/tasks.c **** 					}
 982:Libraries/FreeRTOS/Source/tasks.c **** 				}
 983:Libraries/FreeRTOS/Source/tasks.c **** 			#endif
 984:Libraries/FreeRTOS/Source/tasks.c **** 
 985:Libraries/FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskDelete == 1 )
 986:Libraries/FreeRTOS/Source/tasks.c **** 				else if( pxStateList == &xTasksWaitingTermination )
 987:Libraries/FreeRTOS/Source/tasks.c **** 				{
 988:Libraries/FreeRTOS/Source/tasks.c **** 					/* The task being queried is referenced from the deleted
 989:Libraries/FreeRTOS/Source/tasks.c **** 					tasks list. */
 990:Libraries/FreeRTOS/Source/tasks.c **** 					eReturn = eDeleted;
 991:Libraries/FreeRTOS/Source/tasks.c **** 				}
 992:Libraries/FreeRTOS/Source/tasks.c **** 			#endif
 993:Libraries/FreeRTOS/Source/tasks.c **** 
 994:Libraries/FreeRTOS/Source/tasks.c **** 			else
 995:Libraries/FreeRTOS/Source/tasks.c **** 			{
 996:Libraries/FreeRTOS/Source/tasks.c **** 				/* If the task is not in any other state, it must be in the
 997:Libraries/FreeRTOS/Source/tasks.c **** 				Ready (including pending ready) state. */
 998:Libraries/FreeRTOS/Source/tasks.c **** 				eReturn = eReady;
 999:Libraries/FreeRTOS/Source/tasks.c **** 			}
1000:Libraries/FreeRTOS/Source/tasks.c **** 		}
1001:Libraries/FreeRTOS/Source/tasks.c **** 
1002:Libraries/FreeRTOS/Source/tasks.c **** 		return eReturn;
1003:Libraries/FreeRTOS/Source/tasks.c **** 	}
1004:Libraries/FreeRTOS/Source/tasks.c **** 
1005:Libraries/FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_eTaskGetState */
1006:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1007:Libraries/FreeRTOS/Source/tasks.c **** 
1008:Libraries/FreeRTOS/Source/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
1009:Libraries/FreeRTOS/Source/tasks.c **** 
1010:Libraries/FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
1011:Libraries/FreeRTOS/Source/tasks.c **** 	{
1012:Libraries/FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
1013:Libraries/FreeRTOS/Source/tasks.c **** 	UBaseType_t uxReturn;
1014:Libraries/FreeRTOS/Source/tasks.c **** 
1015:Libraries/FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
1016:Libraries/FreeRTOS/Source/tasks.c **** 		{
1017:Libraries/FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then we are changing the
1018:Libraries/FreeRTOS/Source/tasks.c **** 			priority of the calling function. */
1019:Libraries/FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
1020:Libraries/FreeRTOS/Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
1021:Libraries/FreeRTOS/Source/tasks.c **** 		}
1022:Libraries/FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
1023:Libraries/FreeRTOS/Source/tasks.c **** 
1024:Libraries/FreeRTOS/Source/tasks.c **** 		return uxReturn;
1025:Libraries/FreeRTOS/Source/tasks.c **** 	}
1026:Libraries/FreeRTOS/Source/tasks.c **** 
1027:Libraries/FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_uxTaskPriorityGet */
1028:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1029:Libraries/FreeRTOS/Source/tasks.c **** 
1030:Libraries/FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskPrioritySet == 1 )
1031:Libraries/FreeRTOS/Source/tasks.c **** 
1032:Libraries/FreeRTOS/Source/tasks.c **** 	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
1033:Libraries/FreeRTOS/Source/tasks.c **** 	{
1034:Libraries/FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
1035:Libraries/FreeRTOS/Source/tasks.c **** 	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
1036:Libraries/FreeRTOS/Source/tasks.c **** 	BaseType_t xYieldRequired = pdFALSE;
1037:Libraries/FreeRTOS/Source/tasks.c **** 
1038:Libraries/FreeRTOS/Source/tasks.c **** 		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
1039:Libraries/FreeRTOS/Source/tasks.c **** 
1040:Libraries/FreeRTOS/Source/tasks.c **** 		/* Ensure the new priority is valid. */
1041:Libraries/FreeRTOS/Source/tasks.c **** 		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
1042:Libraries/FreeRTOS/Source/tasks.c **** 		{
1043:Libraries/FreeRTOS/Source/tasks.c **** 			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
1044:Libraries/FreeRTOS/Source/tasks.c **** 		}
1045:Libraries/FreeRTOS/Source/tasks.c **** 		else
1046:Libraries/FreeRTOS/Source/tasks.c **** 		{
1047:Libraries/FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1048:Libraries/FreeRTOS/Source/tasks.c **** 		}
1049:Libraries/FreeRTOS/Source/tasks.c **** 
1050:Libraries/FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
1051:Libraries/FreeRTOS/Source/tasks.c **** 		{
1052:Libraries/FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then it is the priority of the calling
1053:Libraries/FreeRTOS/Source/tasks.c **** 			task that is being changed. */
1054:Libraries/FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
1055:Libraries/FreeRTOS/Source/tasks.c **** 
1056:Libraries/FreeRTOS/Source/tasks.c **** 			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
1057:Libraries/FreeRTOS/Source/tasks.c **** 
1058:Libraries/FreeRTOS/Source/tasks.c **** 			#if ( configUSE_MUTEXES == 1 )
1059:Libraries/FreeRTOS/Source/tasks.c **** 			{
1060:Libraries/FreeRTOS/Source/tasks.c **** 				uxCurrentBasePriority = pxTCB->uxBasePriority;
1061:Libraries/FreeRTOS/Source/tasks.c **** 			}
1062:Libraries/FreeRTOS/Source/tasks.c **** 			#else
1063:Libraries/FreeRTOS/Source/tasks.c **** 			{
1064:Libraries/FreeRTOS/Source/tasks.c **** 				uxCurrentBasePriority = pxTCB->uxPriority;
1065:Libraries/FreeRTOS/Source/tasks.c **** 			}
1066:Libraries/FreeRTOS/Source/tasks.c **** 			#endif
1067:Libraries/FreeRTOS/Source/tasks.c **** 
1068:Libraries/FreeRTOS/Source/tasks.c **** 			if( uxCurrentBasePriority != uxNewPriority )
1069:Libraries/FreeRTOS/Source/tasks.c **** 			{
1070:Libraries/FreeRTOS/Source/tasks.c **** 				/* The priority change may have readied a task of higher
1071:Libraries/FreeRTOS/Source/tasks.c **** 				priority than the calling task. */
1072:Libraries/FreeRTOS/Source/tasks.c **** 				if( uxNewPriority > uxCurrentBasePriority )
1073:Libraries/FreeRTOS/Source/tasks.c **** 				{
1074:Libraries/FreeRTOS/Source/tasks.c **** 					if( pxTCB != pxCurrentTCB )
1075:Libraries/FreeRTOS/Source/tasks.c **** 					{
1076:Libraries/FreeRTOS/Source/tasks.c **** 						/* The priority of a task other than the currently
1077:Libraries/FreeRTOS/Source/tasks.c **** 						running task is being raised.  Is the priority being
1078:Libraries/FreeRTOS/Source/tasks.c **** 						raised above that of the running task? */
1079:Libraries/FreeRTOS/Source/tasks.c **** 						if( uxNewPriority >= pxCurrentTCB->uxPriority )
1080:Libraries/FreeRTOS/Source/tasks.c **** 						{
1081:Libraries/FreeRTOS/Source/tasks.c **** 							xYieldRequired = pdTRUE;
1082:Libraries/FreeRTOS/Source/tasks.c **** 						}
1083:Libraries/FreeRTOS/Source/tasks.c **** 						else
1084:Libraries/FreeRTOS/Source/tasks.c **** 						{
1085:Libraries/FreeRTOS/Source/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
1086:Libraries/FreeRTOS/Source/tasks.c **** 						}
1087:Libraries/FreeRTOS/Source/tasks.c **** 					}
1088:Libraries/FreeRTOS/Source/tasks.c **** 					else
1089:Libraries/FreeRTOS/Source/tasks.c **** 					{
1090:Libraries/FreeRTOS/Source/tasks.c **** 						/* The priority of the running task is being raised,
1091:Libraries/FreeRTOS/Source/tasks.c **** 						but the running task must already be the highest
1092:Libraries/FreeRTOS/Source/tasks.c **** 						priority task able to run so no yield is required. */
1093:Libraries/FreeRTOS/Source/tasks.c **** 					}
1094:Libraries/FreeRTOS/Source/tasks.c **** 				}
1095:Libraries/FreeRTOS/Source/tasks.c **** 				else if( pxTCB == pxCurrentTCB )
1096:Libraries/FreeRTOS/Source/tasks.c **** 				{
1097:Libraries/FreeRTOS/Source/tasks.c **** 					/* Setting the priority of the running task down means
1098:Libraries/FreeRTOS/Source/tasks.c **** 					there may now be another task of higher priority that
1099:Libraries/FreeRTOS/Source/tasks.c **** 					is ready to execute. */
1100:Libraries/FreeRTOS/Source/tasks.c **** 					xYieldRequired = pdTRUE;
1101:Libraries/FreeRTOS/Source/tasks.c **** 				}
1102:Libraries/FreeRTOS/Source/tasks.c **** 				else
1103:Libraries/FreeRTOS/Source/tasks.c **** 				{
1104:Libraries/FreeRTOS/Source/tasks.c **** 					/* Setting the priority of any other task down does not
1105:Libraries/FreeRTOS/Source/tasks.c **** 					require a yield as the running task must be above the
1106:Libraries/FreeRTOS/Source/tasks.c **** 					new priority of the task being modified. */
1107:Libraries/FreeRTOS/Source/tasks.c **** 				}
1108:Libraries/FreeRTOS/Source/tasks.c **** 
1109:Libraries/FreeRTOS/Source/tasks.c **** 				/* Remember the ready list the task might be referenced from
1110:Libraries/FreeRTOS/Source/tasks.c **** 				before its uxPriority member is changed so the
1111:Libraries/FreeRTOS/Source/tasks.c **** 				taskRESET_READY_PRIORITY() macro can function correctly. */
1112:Libraries/FreeRTOS/Source/tasks.c **** 				uxPriorityUsedOnEntry = pxTCB->uxPriority;
1113:Libraries/FreeRTOS/Source/tasks.c **** 
1114:Libraries/FreeRTOS/Source/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
1115:Libraries/FreeRTOS/Source/tasks.c **** 				{
1116:Libraries/FreeRTOS/Source/tasks.c **** 					/* Only change the priority being used if the task is not
1117:Libraries/FreeRTOS/Source/tasks.c **** 					currently using an inherited priority. */
1118:Libraries/FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
1119:Libraries/FreeRTOS/Source/tasks.c **** 					{
1120:Libraries/FreeRTOS/Source/tasks.c **** 						pxTCB->uxPriority = uxNewPriority;
1121:Libraries/FreeRTOS/Source/tasks.c **** 					}
1122:Libraries/FreeRTOS/Source/tasks.c **** 					else
1123:Libraries/FreeRTOS/Source/tasks.c **** 					{
1124:Libraries/FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1125:Libraries/FreeRTOS/Source/tasks.c **** 					}
1126:Libraries/FreeRTOS/Source/tasks.c **** 
1127:Libraries/FreeRTOS/Source/tasks.c **** 					/* The base priority gets set whatever. */
1128:Libraries/FreeRTOS/Source/tasks.c **** 					pxTCB->uxBasePriority = uxNewPriority;
1129:Libraries/FreeRTOS/Source/tasks.c **** 				}
1130:Libraries/FreeRTOS/Source/tasks.c **** 				#else
1131:Libraries/FreeRTOS/Source/tasks.c **** 				{
1132:Libraries/FreeRTOS/Source/tasks.c **** 					pxTCB->uxPriority = uxNewPriority;
1133:Libraries/FreeRTOS/Source/tasks.c **** 				}
1134:Libraries/FreeRTOS/Source/tasks.c **** 				#endif
1135:Libraries/FreeRTOS/Source/tasks.c **** 
1136:Libraries/FreeRTOS/Source/tasks.c **** 				/* Only reset the event list item value if the value is not
1137:Libraries/FreeRTOS/Source/tasks.c **** 				being used for anything else. */
1138:Libraries/FreeRTOS/Source/tasks.c **** 				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE 
1139:Libraries/FreeRTOS/Source/tasks.c **** 				{
1140:Libraries/FreeRTOS/Source/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - (
1141:Libraries/FreeRTOS/Source/tasks.c **** 				}
1142:Libraries/FreeRTOS/Source/tasks.c **** 				else
1143:Libraries/FreeRTOS/Source/tasks.c **** 				{
1144:Libraries/FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1145:Libraries/FreeRTOS/Source/tasks.c **** 				}
1146:Libraries/FreeRTOS/Source/tasks.c **** 
1147:Libraries/FreeRTOS/Source/tasks.c **** 				/* If the task is in the blocked or suspended list we need do
1148:Libraries/FreeRTOS/Source/tasks.c **** 				nothing more than change it's priority variable. However, if
1149:Libraries/FreeRTOS/Source/tasks.c **** 				the task is in a ready list it needs to be removed and placed
1150:Libraries/FreeRTOS/Source/tasks.c **** 				in the list appropriate to its new priority. */
1151:Libraries/FreeRTOS/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xGeneri
1152:Libraries/FreeRTOS/Source/tasks.c **** 				{
1153:Libraries/FreeRTOS/Source/tasks.c **** 					/* The task is currently in its ready list - remove before adding
1154:Libraries/FreeRTOS/Source/tasks.c **** 					it to it's new ready list.  As we are in a critical section we
1155:Libraries/FreeRTOS/Source/tasks.c **** 					can do this even if the scheduler is suspended. */
1156:Libraries/FreeRTOS/Source/tasks.c **** 					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
1157:Libraries/FreeRTOS/Source/tasks.c **** 					{
1158:Libraries/FreeRTOS/Source/tasks.c **** 						/* It is known that the task is in its ready list so
1159:Libraries/FreeRTOS/Source/tasks.c **** 						there is no need to check again and the port level
1160:Libraries/FreeRTOS/Source/tasks.c **** 						reset macro can be called directly. */
1161:Libraries/FreeRTOS/Source/tasks.c **** 						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
1162:Libraries/FreeRTOS/Source/tasks.c **** 					}
1163:Libraries/FreeRTOS/Source/tasks.c **** 					else
1164:Libraries/FreeRTOS/Source/tasks.c **** 					{
1165:Libraries/FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1166:Libraries/FreeRTOS/Source/tasks.c **** 					}
1167:Libraries/FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
1168:Libraries/FreeRTOS/Source/tasks.c **** 				}
1169:Libraries/FreeRTOS/Source/tasks.c **** 				else
1170:Libraries/FreeRTOS/Source/tasks.c **** 				{
1171:Libraries/FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1172:Libraries/FreeRTOS/Source/tasks.c **** 				}
1173:Libraries/FreeRTOS/Source/tasks.c **** 
1174:Libraries/FreeRTOS/Source/tasks.c **** 				if( xYieldRequired == pdTRUE )
1175:Libraries/FreeRTOS/Source/tasks.c **** 				{
1176:Libraries/FreeRTOS/Source/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
1177:Libraries/FreeRTOS/Source/tasks.c **** 				}
1178:Libraries/FreeRTOS/Source/tasks.c **** 				else
1179:Libraries/FreeRTOS/Source/tasks.c **** 				{
1180:Libraries/FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1181:Libraries/FreeRTOS/Source/tasks.c **** 				}
1182:Libraries/FreeRTOS/Source/tasks.c **** 
1183:Libraries/FreeRTOS/Source/tasks.c **** 				/* Remove compiler warning about unused variables when the port
1184:Libraries/FreeRTOS/Source/tasks.c **** 				optimised task selection is not being used. */
1185:Libraries/FreeRTOS/Source/tasks.c **** 				( void ) uxPriorityUsedOnEntry;
1186:Libraries/FreeRTOS/Source/tasks.c **** 			}
1187:Libraries/FreeRTOS/Source/tasks.c **** 		}
1188:Libraries/FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
1189:Libraries/FreeRTOS/Source/tasks.c **** 	}
1190:Libraries/FreeRTOS/Source/tasks.c **** 
1191:Libraries/FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskPrioritySet */
1192:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1193:Libraries/FreeRTOS/Source/tasks.c **** 
1194:Libraries/FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1195:Libraries/FreeRTOS/Source/tasks.c **** 
1196:Libraries/FreeRTOS/Source/tasks.c **** 	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
1197:Libraries/FreeRTOS/Source/tasks.c **** 	{
1198:Libraries/FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
1199:Libraries/FreeRTOS/Source/tasks.c **** 
1200:Libraries/FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
1201:Libraries/FreeRTOS/Source/tasks.c **** 		{
1202:Libraries/FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then it is the running task that is
1203:Libraries/FreeRTOS/Source/tasks.c **** 			being suspended. */
1204:Libraries/FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
1205:Libraries/FreeRTOS/Source/tasks.c **** 
1206:Libraries/FreeRTOS/Source/tasks.c **** 			traceTASK_SUSPEND( pxTCB );
1207:Libraries/FreeRTOS/Source/tasks.c **** 
1208:Libraries/FreeRTOS/Source/tasks.c **** 			/* Remove task from the ready/delayed list and place in the
1209:Libraries/FreeRTOS/Source/tasks.c **** 			suspended list. */
1210:Libraries/FreeRTOS/Source/tasks.c **** 			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
1211:Libraries/FreeRTOS/Source/tasks.c **** 			{
1212:Libraries/FreeRTOS/Source/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
1213:Libraries/FreeRTOS/Source/tasks.c **** 			}
1214:Libraries/FreeRTOS/Source/tasks.c **** 			else
1215:Libraries/FreeRTOS/Source/tasks.c **** 			{
1216:Libraries/FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1217:Libraries/FreeRTOS/Source/tasks.c **** 			}
1218:Libraries/FreeRTOS/Source/tasks.c **** 
1219:Libraries/FreeRTOS/Source/tasks.c **** 			/* Is the task waiting on an event also? */
1220:Libraries/FreeRTOS/Source/tasks.c **** 			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
1221:Libraries/FreeRTOS/Source/tasks.c **** 			{
1222:Libraries/FreeRTOS/Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
1223:Libraries/FreeRTOS/Source/tasks.c **** 			}
1224:Libraries/FreeRTOS/Source/tasks.c **** 			else
1225:Libraries/FreeRTOS/Source/tasks.c **** 			{
1226:Libraries/FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1227:Libraries/FreeRTOS/Source/tasks.c **** 			}
1228:Libraries/FreeRTOS/Source/tasks.c **** 
1229:Libraries/FreeRTOS/Source/tasks.c **** 			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
1230:Libraries/FreeRTOS/Source/tasks.c **** 		}
1231:Libraries/FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
1232:Libraries/FreeRTOS/Source/tasks.c **** 
1233:Libraries/FreeRTOS/Source/tasks.c **** 		if( pxTCB == pxCurrentTCB )
1234:Libraries/FreeRTOS/Source/tasks.c **** 		{
1235:Libraries/FreeRTOS/Source/tasks.c **** 			if( xSchedulerRunning != pdFALSE )
1236:Libraries/FreeRTOS/Source/tasks.c **** 			{
1237:Libraries/FreeRTOS/Source/tasks.c **** 				/* The current task has just been suspended. */
1238:Libraries/FreeRTOS/Source/tasks.c **** 				configASSERT( uxSchedulerSuspended == 0 );
1239:Libraries/FreeRTOS/Source/tasks.c **** 				portYIELD_WITHIN_API();
1240:Libraries/FreeRTOS/Source/tasks.c **** 			}
1241:Libraries/FreeRTOS/Source/tasks.c **** 			else
1242:Libraries/FreeRTOS/Source/tasks.c **** 			{
1243:Libraries/FreeRTOS/Source/tasks.c **** 				/* The scheduler is not running, but the task that was pointed
1244:Libraries/FreeRTOS/Source/tasks.c **** 				to by pxCurrentTCB has just been suspended and pxCurrentTCB
1245:Libraries/FreeRTOS/Source/tasks.c **** 				must be adjusted to point to a different task. */
1246:Libraries/FreeRTOS/Source/tasks.c **** 				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
1247:Libraries/FreeRTOS/Source/tasks.c **** 				{
1248:Libraries/FreeRTOS/Source/tasks.c **** 					/* No other tasks are ready, so set pxCurrentTCB back to
1249:Libraries/FreeRTOS/Source/tasks.c **** 					NULL so when the next task is created pxCurrentTCB will
1250:Libraries/FreeRTOS/Source/tasks.c **** 					be set to point to it no matter what its relative priority
1251:Libraries/FreeRTOS/Source/tasks.c **** 					is. */
1252:Libraries/FreeRTOS/Source/tasks.c **** 					pxCurrentTCB = NULL;
1253:Libraries/FreeRTOS/Source/tasks.c **** 				}
1254:Libraries/FreeRTOS/Source/tasks.c **** 				else
1255:Libraries/FreeRTOS/Source/tasks.c **** 				{
1256:Libraries/FreeRTOS/Source/tasks.c **** 					vTaskSwitchContext();
1257:Libraries/FreeRTOS/Source/tasks.c **** 				}
1258:Libraries/FreeRTOS/Source/tasks.c **** 			}
1259:Libraries/FreeRTOS/Source/tasks.c **** 		}
1260:Libraries/FreeRTOS/Source/tasks.c **** 		else
1261:Libraries/FreeRTOS/Source/tasks.c **** 		{
1262:Libraries/FreeRTOS/Source/tasks.c **** 			if( xSchedulerRunning != pdFALSE )
1263:Libraries/FreeRTOS/Source/tasks.c **** 			{
1264:Libraries/FreeRTOS/Source/tasks.c **** 				/* A task other than the currently running task was suspended,
1265:Libraries/FreeRTOS/Source/tasks.c **** 				reset the next expected unblock time in case it referred to the
1266:Libraries/FreeRTOS/Source/tasks.c **** 				task that is now in the Suspended state. */
1267:Libraries/FreeRTOS/Source/tasks.c **** 				taskENTER_CRITICAL();
1268:Libraries/FreeRTOS/Source/tasks.c **** 				{
1269:Libraries/FreeRTOS/Source/tasks.c **** 					prvResetNextTaskUnblockTime();
1270:Libraries/FreeRTOS/Source/tasks.c **** 				}
1271:Libraries/FreeRTOS/Source/tasks.c **** 				taskEXIT_CRITICAL();
1272:Libraries/FreeRTOS/Source/tasks.c **** 			}
1273:Libraries/FreeRTOS/Source/tasks.c **** 			else
1274:Libraries/FreeRTOS/Source/tasks.c **** 			{
1275:Libraries/FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1276:Libraries/FreeRTOS/Source/tasks.c **** 			}
1277:Libraries/FreeRTOS/Source/tasks.c **** 		}
1278:Libraries/FreeRTOS/Source/tasks.c **** 	}
1279:Libraries/FreeRTOS/Source/tasks.c **** 
1280:Libraries/FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1281:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1282:Libraries/FreeRTOS/Source/tasks.c **** 
1283:Libraries/FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1284:Libraries/FreeRTOS/Source/tasks.c **** 
1285:Libraries/FreeRTOS/Source/tasks.c **** 	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
1286:Libraries/FreeRTOS/Source/tasks.c **** 	{
1287:Libraries/FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn = pdFALSE;
1288:Libraries/FreeRTOS/Source/tasks.c **** 	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
1289:Libraries/FreeRTOS/Source/tasks.c **** 
1290:Libraries/FreeRTOS/Source/tasks.c **** 		/* Accesses xPendingReadyList so must be called from a critical
1291:Libraries/FreeRTOS/Source/tasks.c **** 		section. */
1292:Libraries/FreeRTOS/Source/tasks.c **** 
1293:Libraries/FreeRTOS/Source/tasks.c **** 		/* It does not make sense to check if the calling task is suspended. */
1294:Libraries/FreeRTOS/Source/tasks.c **** 		configASSERT( xTask );
1295:Libraries/FreeRTOS/Source/tasks.c **** 
1296:Libraries/FreeRTOS/Source/tasks.c **** 		/* Is the task being resumed actually in the suspended list? */
1297:Libraries/FreeRTOS/Source/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
1298:Libraries/FreeRTOS/Source/tasks.c **** 		{
1299:Libraries/FreeRTOS/Source/tasks.c **** 			/* Has the task already been resumed from within an ISR? */
1300:Libraries/FreeRTOS/Source/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
1301:Libraries/FreeRTOS/Source/tasks.c **** 			{
1302:Libraries/FreeRTOS/Source/tasks.c **** 				/* Is it in the suspended list because it is in the	Suspended
1303:Libraries/FreeRTOS/Source/tasks.c **** 				state, or because is is blocked with no timeout? */
1304:Libraries/FreeRTOS/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
1305:Libraries/FreeRTOS/Source/tasks.c **** 				{
1306:Libraries/FreeRTOS/Source/tasks.c **** 					xReturn = pdTRUE;
1307:Libraries/FreeRTOS/Source/tasks.c **** 				}
1308:Libraries/FreeRTOS/Source/tasks.c **** 				else
1309:Libraries/FreeRTOS/Source/tasks.c **** 				{
1310:Libraries/FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1311:Libraries/FreeRTOS/Source/tasks.c **** 				}
1312:Libraries/FreeRTOS/Source/tasks.c **** 			}
1313:Libraries/FreeRTOS/Source/tasks.c **** 			else
1314:Libraries/FreeRTOS/Source/tasks.c **** 			{
1315:Libraries/FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1316:Libraries/FreeRTOS/Source/tasks.c **** 			}
1317:Libraries/FreeRTOS/Source/tasks.c **** 		}
1318:Libraries/FreeRTOS/Source/tasks.c **** 		else
1319:Libraries/FreeRTOS/Source/tasks.c **** 		{
1320:Libraries/FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1321:Libraries/FreeRTOS/Source/tasks.c **** 		}
1322:Libraries/FreeRTOS/Source/tasks.c **** 
1323:Libraries/FreeRTOS/Source/tasks.c **** 		return xReturn;
1324:Libraries/FreeRTOS/Source/tasks.c **** 	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
1325:Libraries/FreeRTOS/Source/tasks.c **** 
1326:Libraries/FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1327:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1328:Libraries/FreeRTOS/Source/tasks.c **** 
1329:Libraries/FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1330:Libraries/FreeRTOS/Source/tasks.c **** 
1331:Libraries/FreeRTOS/Source/tasks.c **** 	void vTaskResume( TaskHandle_t xTaskToResume )
1332:Libraries/FreeRTOS/Source/tasks.c **** 	{
1333:Libraries/FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
1334:Libraries/FreeRTOS/Source/tasks.c **** 
1335:Libraries/FreeRTOS/Source/tasks.c **** 		/* It does not make sense to resume the calling task. */
1336:Libraries/FreeRTOS/Source/tasks.c **** 		configASSERT( xTaskToResume );
1337:Libraries/FreeRTOS/Source/tasks.c **** 
1338:Libraries/FreeRTOS/Source/tasks.c **** 		/* The parameter cannot be NULL as it is impossible to resume the
1339:Libraries/FreeRTOS/Source/tasks.c **** 		currently executing task. */
1340:Libraries/FreeRTOS/Source/tasks.c **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
1341:Libraries/FreeRTOS/Source/tasks.c **** 		{
1342:Libraries/FreeRTOS/Source/tasks.c **** 			taskENTER_CRITICAL();
1343:Libraries/FreeRTOS/Source/tasks.c **** 			{
1344:Libraries/FreeRTOS/Source/tasks.c **** 				if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
1345:Libraries/FreeRTOS/Source/tasks.c **** 				{
1346:Libraries/FreeRTOS/Source/tasks.c **** 					traceTASK_RESUME( pxTCB );
1347:Libraries/FreeRTOS/Source/tasks.c **** 
1348:Libraries/FreeRTOS/Source/tasks.c **** 					/* As we are in a critical section we can access the ready
1349:Libraries/FreeRTOS/Source/tasks.c **** 					lists even if the scheduler is suspended. */
1350:Libraries/FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
1351:Libraries/FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
1352:Libraries/FreeRTOS/Source/tasks.c **** 
1353:Libraries/FreeRTOS/Source/tasks.c **** 					/* We may have just resumed a higher priority task. */
1354:Libraries/FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1355:Libraries/FreeRTOS/Source/tasks.c **** 					{
1356:Libraries/FreeRTOS/Source/tasks.c **** 						/* This yield may not cause the task just resumed to run,
1357:Libraries/FreeRTOS/Source/tasks.c **** 						but will leave the lists in the correct state for the
1358:Libraries/FreeRTOS/Source/tasks.c **** 						next yield. */
1359:Libraries/FreeRTOS/Source/tasks.c **** 						taskYIELD_IF_USING_PREEMPTION();
1360:Libraries/FreeRTOS/Source/tasks.c **** 					}
1361:Libraries/FreeRTOS/Source/tasks.c **** 					else
1362:Libraries/FreeRTOS/Source/tasks.c **** 					{
1363:Libraries/FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1364:Libraries/FreeRTOS/Source/tasks.c **** 					}
1365:Libraries/FreeRTOS/Source/tasks.c **** 				}
1366:Libraries/FreeRTOS/Source/tasks.c **** 				else
1367:Libraries/FreeRTOS/Source/tasks.c **** 				{
1368:Libraries/FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1369:Libraries/FreeRTOS/Source/tasks.c **** 				}
1370:Libraries/FreeRTOS/Source/tasks.c **** 			}
1371:Libraries/FreeRTOS/Source/tasks.c **** 			taskEXIT_CRITICAL();
1372:Libraries/FreeRTOS/Source/tasks.c **** 		}
1373:Libraries/FreeRTOS/Source/tasks.c **** 		else
1374:Libraries/FreeRTOS/Source/tasks.c **** 		{
1375:Libraries/FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1376:Libraries/FreeRTOS/Source/tasks.c **** 		}
1377:Libraries/FreeRTOS/Source/tasks.c **** 	}
1378:Libraries/FreeRTOS/Source/tasks.c **** 
1379:Libraries/FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1380:Libraries/FreeRTOS/Source/tasks.c **** 
1381:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1382:Libraries/FreeRTOS/Source/tasks.c **** 
1383:Libraries/FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1384:Libraries/FreeRTOS/Source/tasks.c **** 
1385:Libraries/FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
1386:Libraries/FreeRTOS/Source/tasks.c **** 	{
1387:Libraries/FreeRTOS/Source/tasks.c **** 	BaseType_t xYieldRequired = pdFALSE;
1388:Libraries/FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
1389:Libraries/FreeRTOS/Source/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
1390:Libraries/FreeRTOS/Source/tasks.c **** 
1391:Libraries/FreeRTOS/Source/tasks.c **** 		configASSERT( xTaskToResume );
1392:Libraries/FreeRTOS/Source/tasks.c **** 
1393:Libraries/FreeRTOS/Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
1394:Libraries/FreeRTOS/Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
1395:Libraries/FreeRTOS/Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
1396:Libraries/FreeRTOS/Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
1397:Libraries/FreeRTOS/Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1398:Libraries/FreeRTOS/Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
1399:Libraries/FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1400:Libraries/FreeRTOS/Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
1401:Libraries/FreeRTOS/Source/tasks.c **** 		been assigned a priority above the configured maximum system call
1402:Libraries/FreeRTOS/Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
1403:Libraries/FreeRTOS/Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
1404:Libraries/FreeRTOS/Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
1405:Libraries/FreeRTOS/Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
1406:Libraries/FreeRTOS/Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
1407:Libraries/FreeRTOS/Source/tasks.c **** 		provided on the following link:
1408:Libraries/FreeRTOS/Source/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1409:Libraries/FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1410:Libraries/FreeRTOS/Source/tasks.c **** 
1411:Libraries/FreeRTOS/Source/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1412:Libraries/FreeRTOS/Source/tasks.c **** 		{
1413:Libraries/FreeRTOS/Source/tasks.c **** 			if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
1414:Libraries/FreeRTOS/Source/tasks.c **** 			{
1415:Libraries/FreeRTOS/Source/tasks.c **** 				traceTASK_RESUME_FROM_ISR( pxTCB );
1416:Libraries/FreeRTOS/Source/tasks.c **** 
1417:Libraries/FreeRTOS/Source/tasks.c **** 				/* Check the ready lists can be accessed. */
1418:Libraries/FreeRTOS/Source/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
1419:Libraries/FreeRTOS/Source/tasks.c **** 				{
1420:Libraries/FreeRTOS/Source/tasks.c **** 					/* Ready lists can be accessed so move the task from the
1421:Libraries/FreeRTOS/Source/tasks.c **** 					suspended list to the ready list directly. */
1422:Libraries/FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1423:Libraries/FreeRTOS/Source/tasks.c **** 					{
1424:Libraries/FreeRTOS/Source/tasks.c **** 						xYieldRequired = pdTRUE;
1425:Libraries/FreeRTOS/Source/tasks.c **** 					}
1426:Libraries/FreeRTOS/Source/tasks.c **** 					else
1427:Libraries/FreeRTOS/Source/tasks.c **** 					{
1428:Libraries/FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1429:Libraries/FreeRTOS/Source/tasks.c **** 					}
1430:Libraries/FreeRTOS/Source/tasks.c **** 
1431:Libraries/FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
1432:Libraries/FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
1433:Libraries/FreeRTOS/Source/tasks.c **** 				}
1434:Libraries/FreeRTOS/Source/tasks.c **** 				else
1435:Libraries/FreeRTOS/Source/tasks.c **** 				{
1436:Libraries/FreeRTOS/Source/tasks.c **** 					/* The delayed or ready lists cannot be accessed so the task
1437:Libraries/FreeRTOS/Source/tasks.c **** 					is held in the pending ready list until the scheduler is
1438:Libraries/FreeRTOS/Source/tasks.c **** 					unsuspended. */
1439:Libraries/FreeRTOS/Source/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
1440:Libraries/FreeRTOS/Source/tasks.c **** 				}
1441:Libraries/FreeRTOS/Source/tasks.c **** 			}
1442:Libraries/FreeRTOS/Source/tasks.c **** 			else
1443:Libraries/FreeRTOS/Source/tasks.c **** 			{
1444:Libraries/FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1445:Libraries/FreeRTOS/Source/tasks.c **** 			}
1446:Libraries/FreeRTOS/Source/tasks.c **** 		}
1447:Libraries/FreeRTOS/Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1448:Libraries/FreeRTOS/Source/tasks.c **** 
1449:Libraries/FreeRTOS/Source/tasks.c **** 		return xYieldRequired;
1450:Libraries/FreeRTOS/Source/tasks.c **** 	}
1451:Libraries/FreeRTOS/Source/tasks.c **** 
1452:Libraries/FreeRTOS/Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
1453:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1454:Libraries/FreeRTOS/Source/tasks.c **** 
1455:Libraries/FreeRTOS/Source/tasks.c **** void vTaskStartScheduler( void )
1456:Libraries/FreeRTOS/Source/tasks.c **** {
1457:Libraries/FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
1458:Libraries/FreeRTOS/Source/tasks.c **** 
1459:Libraries/FreeRTOS/Source/tasks.c **** 	/* Add the idle task at the lowest priority. */
1460:Libraries/FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1461:Libraries/FreeRTOS/Source/tasks.c **** 	{
1462:Libraries/FreeRTOS/Source/tasks.c **** 		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
1463:Libraries/FreeRTOS/Source/tasks.c **** 		be returned by the xTaskGetIdleTaskHandle() function. */
1464:Libraries/FreeRTOS/Source/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORI
1465:Libraries/FreeRTOS/Source/tasks.c **** 	}
1466:Libraries/FreeRTOS/Source/tasks.c **** 	#else
1467:Libraries/FreeRTOS/Source/tasks.c **** 	{
1468:Libraries/FreeRTOS/Source/tasks.c **** 		/* Create the idle task without storing its handle. */
1469:Libraries/FreeRTOS/Source/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORI
1470:Libraries/FreeRTOS/Source/tasks.c **** 	}
1471:Libraries/FreeRTOS/Source/tasks.c **** 	#endif /* INCLUDE_xTaskGetIdleTaskHandle */
1472:Libraries/FreeRTOS/Source/tasks.c **** 
1473:Libraries/FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TIMERS == 1 )
1474:Libraries/FreeRTOS/Source/tasks.c **** 	{
1475:Libraries/FreeRTOS/Source/tasks.c **** 		if( xReturn == pdPASS )
1476:Libraries/FreeRTOS/Source/tasks.c **** 		{
1477:Libraries/FreeRTOS/Source/tasks.c **** 			xReturn = xTimerCreateTimerTask();
1478:Libraries/FreeRTOS/Source/tasks.c **** 		}
1479:Libraries/FreeRTOS/Source/tasks.c **** 		else
1480:Libraries/FreeRTOS/Source/tasks.c **** 		{
1481:Libraries/FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1482:Libraries/FreeRTOS/Source/tasks.c **** 		}
1483:Libraries/FreeRTOS/Source/tasks.c **** 	}
1484:Libraries/FreeRTOS/Source/tasks.c **** 	#endif /* configUSE_TIMERS */
1485:Libraries/FreeRTOS/Source/tasks.c **** 
1486:Libraries/FreeRTOS/Source/tasks.c **** 	if( xReturn == pdPASS )
1487:Libraries/FreeRTOS/Source/tasks.c **** 	{
1488:Libraries/FreeRTOS/Source/tasks.c **** 		/* Interrupts are turned off here, to ensure a tick does not occur
1489:Libraries/FreeRTOS/Source/tasks.c **** 		before or during the call to xPortStartScheduler().  The stacks of
1490:Libraries/FreeRTOS/Source/tasks.c **** 		the created tasks contain a status word with interrupts switched on
1491:Libraries/FreeRTOS/Source/tasks.c **** 		so interrupts will automatically get re-enabled when the first task
1492:Libraries/FreeRTOS/Source/tasks.c **** 		starts to run. */
1493:Libraries/FreeRTOS/Source/tasks.c **** 		portDISABLE_INTERRUPTS();
1494:Libraries/FreeRTOS/Source/tasks.c **** 
1495:Libraries/FreeRTOS/Source/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
1496:Libraries/FreeRTOS/Source/tasks.c **** 		{
1497:Libraries/FreeRTOS/Source/tasks.c **** 			/* Switch Newlib's _impure_ptr variable to point to the _reent
1498:Libraries/FreeRTOS/Source/tasks.c **** 			structure specific to the task that will run first. */
1499:Libraries/FreeRTOS/Source/tasks.c **** 			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
1500:Libraries/FreeRTOS/Source/tasks.c **** 		}
1501:Libraries/FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
1502:Libraries/FreeRTOS/Source/tasks.c **** 
1503:Libraries/FreeRTOS/Source/tasks.c **** 		xSchedulerRunning = pdTRUE;
1504:Libraries/FreeRTOS/Source/tasks.c **** 		xTickCount = ( TickType_t ) 0U;
1505:Libraries/FreeRTOS/Source/tasks.c **** 
1506:Libraries/FreeRTOS/Source/tasks.c **** 		/* If configGENERATE_RUN_TIME_STATS is defined then the following
1507:Libraries/FreeRTOS/Source/tasks.c **** 		macro must be defined to configure the timer/counter used to generate
1508:Libraries/FreeRTOS/Source/tasks.c **** 		the run time counter time base. */
1509:Libraries/FreeRTOS/Source/tasks.c **** 		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
1510:Libraries/FreeRTOS/Source/tasks.c **** 
1511:Libraries/FreeRTOS/Source/tasks.c **** 		/* Setting up the timer tick is hardware specific and thus in the
1512:Libraries/FreeRTOS/Source/tasks.c **** 		portable interface. */
1513:Libraries/FreeRTOS/Source/tasks.c **** 		if( xPortStartScheduler() != pdFALSE )
1514:Libraries/FreeRTOS/Source/tasks.c **** 		{
1515:Libraries/FreeRTOS/Source/tasks.c **** 			/* Should not reach here as if the scheduler is running the
1516:Libraries/FreeRTOS/Source/tasks.c **** 			function will not return. */
1517:Libraries/FreeRTOS/Source/tasks.c **** 		}
1518:Libraries/FreeRTOS/Source/tasks.c **** 		else
1519:Libraries/FreeRTOS/Source/tasks.c **** 		{
1520:Libraries/FreeRTOS/Source/tasks.c **** 			/* Should only reach here if a task calls xTaskEndScheduler(). */
1521:Libraries/FreeRTOS/Source/tasks.c **** 		}
1522:Libraries/FreeRTOS/Source/tasks.c **** 	}
1523:Libraries/FreeRTOS/Source/tasks.c **** 	else
1524:Libraries/FreeRTOS/Source/tasks.c **** 	{
1525:Libraries/FreeRTOS/Source/tasks.c **** 		/* This line will only be reached if the kernel could not be started,
1526:Libraries/FreeRTOS/Source/tasks.c **** 		because there was not enough FreeRTOS heap to create the idle task
1527:Libraries/FreeRTOS/Source/tasks.c **** 		or the timer task. */
1528:Libraries/FreeRTOS/Source/tasks.c **** 		configASSERT( xReturn );
1529:Libraries/FreeRTOS/Source/tasks.c **** 	}
1530:Libraries/FreeRTOS/Source/tasks.c **** }
1531:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1532:Libraries/FreeRTOS/Source/tasks.c **** 
1533:Libraries/FreeRTOS/Source/tasks.c **** void vTaskEndScheduler( void )
1534:Libraries/FreeRTOS/Source/tasks.c **** {
1535:Libraries/FreeRTOS/Source/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
1536:Libraries/FreeRTOS/Source/tasks.c **** 	routine so the original ISRs can be restored if necessary.  The port
1537:Libraries/FreeRTOS/Source/tasks.c **** 	layer must ensure interrupts enable	bit is left in the correct state. */
1538:Libraries/FreeRTOS/Source/tasks.c **** 	portDISABLE_INTERRUPTS();
1539:Libraries/FreeRTOS/Source/tasks.c **** 	xSchedulerRunning = pdFALSE;
1540:Libraries/FreeRTOS/Source/tasks.c **** 	vPortEndScheduler();
1541:Libraries/FreeRTOS/Source/tasks.c **** }
1542:Libraries/FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1543:Libraries/FreeRTOS/Source/tasks.c **** 
1544:Libraries/FreeRTOS/Source/tasks.c **** void vTaskSuspendAll( void )
1545:Libraries/FreeRTOS/Source/tasks.c **** {
1546:Libraries/FreeRTOS/Source/tasks.c **** 	/* A critical section is not required as the variable is of type
1547:Libraries/FreeRTOS/Source/tasks.c **** 	BaseType_t.  Please read Richard Barry's reply in the following link to a
1548:Libraries/FreeRTOS/Source/tasks.c **** 	post in the FreeRTOS support forum before reporting this as a bug! -
1549:Libraries/FreeRTOS/Source/tasks.c **** 	http://goo.gl/wu4acr */
1550:Libraries/FreeRTOS/Source/tasks.c **** 	++uxSchedulerSuspended;
1551:Libraries/FreeRTOS/Source/tasks.c **** }
1552:Libraries/FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1553:Libraries/FreeRTOS/Source/tasks.c **** 
1554:Libraries/FreeRTOS/Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
1555:Libraries/FreeRTOS/Source/tasks.c **** 
1556:Libraries/FreeRTOS/Source/tasks.c **** 	static TickType_t prvGetExpectedIdleTime( void )
1557:Libraries/FreeRTOS/Source/tasks.c **** 	{
1558:Libraries/FreeRTOS/Source/tasks.c **** 	TickType_t xReturn;
1559:Libraries/FreeRTOS/Source/tasks.c **** 
1560:Libraries/FreeRTOS/Source/tasks.c **** 		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
1561:Libraries/FreeRTOS/Source/tasks.c **** 		{
1562:Libraries/FreeRTOS/Source/tasks.c **** 			xReturn = 0;
1563:Libraries/FreeRTOS/Source/tasks.c **** 		}
1564:Libraries/FreeRTOS/Source/tasks.c **** 		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
1565:Libraries/FreeRTOS/Source/tasks.c **** 		{
1566:Libraries/FreeRTOS/Source/tasks.c **** 			/* There are other idle priority tasks in the ready state.  If
1567:Libraries/FreeRTOS/Source/tasks.c **** 			time slicing is used then the very next tick interrupt must be
1568:Libraries/FreeRTOS/Source/tasks.c **** 			processed. */
1569:Libraries/FreeRTOS/Source/tasks.c **** 			xReturn = 0;
1570:Libraries/FreeRTOS/Source/tasks.c **** 		}
1571:Libraries/FreeRTOS/Source/tasks.c **** 		else
1572:Libraries/FreeRTOS/Source/tasks.c **** 		{
1573:Libraries/FreeRTOS/Source/tasks.c **** 			xReturn = xNextTaskUnblockTime - xTickCount;
1574:Libraries/FreeRTOS/Source/tasks.c **** 		}
1575:Libraries/FreeRTOS/Source/tasks.c **** 
1576:Libraries/FreeRTOS/Source/tasks.c **** 		return xReturn;
1577:Libraries/FreeRTOS/Source/tasks.c **** 	}
1578:Libraries/FreeRTOS/Source/tasks.c **** 
1579:Libraries/FreeRTOS/Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
1580:Libraries/FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1581:Libraries/FreeRTOS/Source/tasks.c **** 
1582:Libraries/FreeRTOS/Source/tasks.c **** BaseType_t xTaskResumeAll( void )
1583:Libraries/FreeRTOS/Source/tasks.c **** {
1584:Libraries/FreeRTOS/Source/tasks.c **** TCB_t *pxTCB;
1585:Libraries/FreeRTOS/Source/tasks.c **** BaseType_t xAlreadyYielded = pdFALSE;
1586:Libraries/FreeRTOS/Source/tasks.c **** 
1587:Libraries/FreeRTOS/Source/tasks.c **** 	/* If uxSchedulerSuspended is zero then this function does not match a
1588:Libraries/FreeRTOS/Source/tasks.c **** 	previous call to vTaskSuspendAll(). */
1589:Libraries/FreeRTOS/Source/tasks.c **** 	configASSERT( uxSchedulerSuspended );
1590:Libraries/FreeRTOS/Source/tasks.c **** 
1591:Libraries/FreeRTOS/Source/tasks.c **** 	/* It is possible that an ISR caused a task to be removed from an event
1592:Libraries/FreeRTOS/Source/tasks.c **** 	list while the scheduler was suspended.  If this was the case then the
1593:Libraries/FreeRTOS/Source/tasks.c **** 	removed task will have been added to the xPendingReadyList.  Once the
1594:Libraries/FreeRTOS/Source/tasks.c **** 	scheduler has been resumed it is safe to move all the pending ready
1595:Libraries/FreeRTOS/Source/tasks.c **** 	tasks from this list into their appropriate ready list. */
1596:Libraries/FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
1597:Libraries/FreeRTOS/Source/tasks.c **** 	{
1598:Libraries/FreeRTOS/Source/tasks.c **** 		--uxSchedulerSuspended;
1599:Libraries/FreeRTOS/Source/tasks.c **** 
1600:Libraries/FreeRTOS/Source/tasks.c **** 		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
1601:Libraries/FreeRTOS/Source/tasks.c **** 		{
1602:Libraries/FreeRTOS/Source/tasks.c **** 			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
1603:Libraries/FreeRTOS/Source/tasks.c **** 			{
1604:Libraries/FreeRTOS/Source/tasks.c **** 				/* Move any readied tasks from the pending list into the
1605:Libraries/FreeRTOS/Source/tasks.c **** 				appropriate ready list. */
1606:Libraries/FreeRTOS/Source/tasks.c **** 				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
1607:Libraries/FreeRTOS/Source/tasks.c **** 				{
1608:Libraries/FreeRTOS/Source/tasks.c **** 					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
1609:Libraries/FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
1610:Libraries/FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
1611:Libraries/FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
1612:Libraries/FreeRTOS/Source/tasks.c **** 
1613:Libraries/FreeRTOS/Source/tasks.c **** 					/* If we have moved a task that has a priority higher than
1614:Libraries/FreeRTOS/Source/tasks.c **** 					the current task then we should yield. */
1615:Libraries/FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1616:Libraries/FreeRTOS/Source/tasks.c **** 					{
1617:Libraries/FreeRTOS/Source/tasks.c **** 						xYieldPending = pdTRUE;
1618:Libraries/FreeRTOS/Source/tasks.c **** 					}
1619:Libraries/FreeRTOS/Source/tasks.c **** 					else
1620:Libraries/FreeRTOS/Source/tasks.c **** 					{
1621:Libraries/FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1622:Libraries/FreeRTOS/Source/tasks.c **** 					}
1623:Libraries/FreeRTOS/Source/tasks.c **** 				}
1624:Libraries/FreeRTOS/Source/tasks.c **** 
1625:Libraries/FreeRTOS/Source/tasks.c **** 				/* If any ticks occurred while the scheduler was suspended then
1626:Libraries/FreeRTOS/Source/tasks.c **** 				they should be processed now.  This ensures the tick count does
1627:Libraries/FreeRTOS/Source/tasks.c **** 				not	slip, and that any delayed tasks are resumed at the correct
1628:Libraries/FreeRTOS/Source/tasks.c **** 				time. */
1629:Libraries/FreeRTOS/Source/tasks.c **** 				if( uxPendedTicks > ( UBaseType_t ) 0U )
1630:Libraries/FreeRTOS/Source/tasks.c **** 				{
1631:Libraries/FreeRTOS/Source/tasks.c **** 					while( uxPendedTicks > ( UBaseType_t ) 0U )
1632:Libraries/FreeRTOS/Source/tasks.c **** 					{
1633:Libraries/FreeRTOS/Source/tasks.c **** 						if( xTaskIncrementTick() != pdFALSE )
1634:Libraries/FreeRTOS/Source/tasks.c **** 						{
1635:Libraries/FreeRTOS/Source/tasks.c **** 							xYieldPending = pdTRUE;
1636:Libraries/FreeRTOS/Source/tasks.c **** 						}
1637:Libraries/FreeRTOS/Source/tasks.c **** 						else
1638:Libraries/FreeRTOS/Source/tasks.c **** 						{
1639:Libraries/FreeRTOS/Source/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
1640:Libraries/FreeRTOS/Source/tasks.c **** 						}
1641:Libraries/FreeRTOS/Source/tasks.c **** 						--uxPendedTicks;
1642:Libraries/FreeRTOS/Source/tasks.c **** 					}
1643:Libraries/FreeRTOS/Source/tasks.c **** 				}
1644:Libraries/FreeRTOS/Source/tasks.c **** 				else
1645:Libraries/FreeRTOS/Source/tasks.c **** 				{
1646:Libraries/FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1647:Libraries/FreeRTOS/Source/tasks.c **** 				}
1648:Libraries/FreeRTOS/Source/tasks.c **** 
1649:Libraries/FreeRTOS/Source/tasks.c **** 				if( xYieldPending == pdTRUE )
1650:Libraries/FreeRTOS/Source/tasks.c **** 				{
1651:Libraries/FreeRTOS/Source/tasks.c **** 					#if( configUSE_PREEMPTION != 0 )
1652:Libraries/FreeRTOS/Source/tasks.c **** 					{
1653:Libraries/FreeRTOS/Source/tasks.c **** 						xAlreadyYielded = pdTRUE;
1654:Libraries/FreeRTOS/Source/tasks.c **** 					}
1655:Libraries/FreeRTOS/Source/tasks.c **** 					#endif
1656:Libraries/FreeRTOS/Source/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
1657:Libraries/FreeRTOS/Source/tasks.c **** 				}
1658:Libraries/FreeRTOS/Source/tasks.c **** 				else
1659:Libraries/FreeRTOS/Source/tasks.c **** 				{
1660:Libraries/FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1661:Libraries/FreeRTOS/Source/tasks.c **** 				}
1662:Libraries/FreeRTOS/Source/tasks.c **** 			}
1663:Libraries/FreeRTOS/Source/tasks.c **** 		}
1664:Libraries/FreeRTOS/Source/tasks.c **** 		else
1665:Libraries/FreeRTOS/Source/tasks.c **** 		{
1666:Libraries/FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1667:Libraries/FreeRTOS/Source/tasks.c **** 		}
1668:Libraries/FreeRTOS/Source/tasks.c **** 	}
1669:Libraries/FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
1670:Libraries/FreeRTOS/Source/tasks.c **** 
1671:Libraries/FreeRTOS/Source/tasks.c **** 	return xAlreadyYielded;
1672:Libraries/FreeRTOS/Source/tasks.c **** }
1673:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1674:Libraries/FreeRTOS/Source/tasks.c **** 
1675:Libraries/FreeRTOS/Source/tasks.c **** TickType_t xTaskGetTickCount( void )
1676:Libraries/FreeRTOS/Source/tasks.c **** {
1677:Libraries/FreeRTOS/Source/tasks.c **** TickType_t xTicks;
1678:Libraries/FreeRTOS/Source/tasks.c **** 
1679:Libraries/FreeRTOS/Source/tasks.c **** 	/* Critical section required if running on a 16 bit processor. */
1680:Libraries/FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
1681:Libraries/FreeRTOS/Source/tasks.c **** 	{
1682:Libraries/FreeRTOS/Source/tasks.c **** 		xTicks = xTickCount;
1683:Libraries/FreeRTOS/Source/tasks.c **** 	}
1684:Libraries/FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
1685:Libraries/FreeRTOS/Source/tasks.c **** 
1686:Libraries/FreeRTOS/Source/tasks.c **** 	return xTicks;
1687:Libraries/FreeRTOS/Source/tasks.c **** }
1688:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1689:Libraries/FreeRTOS/Source/tasks.c **** 
1690:Libraries/FreeRTOS/Source/tasks.c **** TickType_t xTaskGetTickCountFromISR( void )
1691:Libraries/FreeRTOS/Source/tasks.c **** {
1692:Libraries/FreeRTOS/Source/tasks.c **** TickType_t xReturn;
1693:Libraries/FreeRTOS/Source/tasks.c **** UBaseType_t uxSavedInterruptStatus;
1694:Libraries/FreeRTOS/Source/tasks.c **** 
1695:Libraries/FreeRTOS/Source/tasks.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1696:Libraries/FreeRTOS/Source/tasks.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1697:Libraries/FreeRTOS/Source/tasks.c **** 	above the maximum system call priority are kept permanently enabled, even
1698:Libraries/FreeRTOS/Source/tasks.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1699:Libraries/FreeRTOS/Source/tasks.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1700:Libraries/FreeRTOS/Source/tasks.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1701:Libraries/FreeRTOS/Source/tasks.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1702:Libraries/FreeRTOS/Source/tasks.c **** 	assigned a priority above the configured maximum system call priority.
1703:Libraries/FreeRTOS/Source/tasks.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1704:Libraries/FreeRTOS/Source/tasks.c **** 	that have been assigned a priority at or (logically) below the maximum
1705:Libraries/FreeRTOS/Source/tasks.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1706:Libraries/FreeRTOS/Source/tasks.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1707:Libraries/FreeRTOS/Source/tasks.c **** 	More information (albeit Cortex-M specific) is provided on the following
1708:Libraries/FreeRTOS/Source/tasks.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1709:Libraries/FreeRTOS/Source/tasks.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1710:Libraries/FreeRTOS/Source/tasks.c **** 
1711:Libraries/FreeRTOS/Source/tasks.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1712:Libraries/FreeRTOS/Source/tasks.c **** 	{
1713:Libraries/FreeRTOS/Source/tasks.c **** 		xReturn = xTickCount;
1714:Libraries/FreeRTOS/Source/tasks.c **** 	}
1715:Libraries/FreeRTOS/Source/tasks.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1716:Libraries/FreeRTOS/Source/tasks.c **** 
1717:Libraries/FreeRTOS/Source/tasks.c **** 	return xReturn;
1718:Libraries/FreeRTOS/Source/tasks.c **** }
1719:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1720:Libraries/FreeRTOS/Source/tasks.c **** 
1721:Libraries/FreeRTOS/Source/tasks.c **** UBaseType_t uxTaskGetNumberOfTasks( void )
1722:Libraries/FreeRTOS/Source/tasks.c **** {
1723:Libraries/FreeRTOS/Source/tasks.c **** 	/* A critical section is not required because the variables are of type
1724:Libraries/FreeRTOS/Source/tasks.c **** 	BaseType_t. */
1725:Libraries/FreeRTOS/Source/tasks.c **** 	return uxCurrentNumberOfTasks;
1726:Libraries/FreeRTOS/Source/tasks.c **** }
1727:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1728:Libraries/FreeRTOS/Source/tasks.c **** 
1729:Libraries/FreeRTOS/Source/tasks.c **** #if ( INCLUDE_pcTaskGetTaskName == 1 )
1730:Libraries/FreeRTOS/Source/tasks.c **** 
1731:Libraries/FreeRTOS/Source/tasks.c **** 	char *pcTaskGetTaskName( TaskHandle_t xTaskToQuery )
1732:Libraries/FreeRTOS/Source/tasks.c **** 	{
1733:Libraries/FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
1734:Libraries/FreeRTOS/Source/tasks.c **** 
1735:Libraries/FreeRTOS/Source/tasks.c **** 		/* If null is passed in here then the name of the calling task is being queried. */
1736:Libraries/FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
1737:Libraries/FreeRTOS/Source/tasks.c **** 		configASSERT( pxTCB );
1738:Libraries/FreeRTOS/Source/tasks.c **** 		return &( pxTCB->pcTaskName[ 0 ] );
1739:Libraries/FreeRTOS/Source/tasks.c **** 	}
1740:Libraries/FreeRTOS/Source/tasks.c **** 
1741:Libraries/FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_pcTaskGetTaskName */
1742:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1743:Libraries/FreeRTOS/Source/tasks.c **** 
1744:Libraries/FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1745:Libraries/FreeRTOS/Source/tasks.c **** 
1746:Libraries/FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArra
1747:Libraries/FreeRTOS/Source/tasks.c **** 	{
1748:Libraries/FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
1749:Libraries/FreeRTOS/Source/tasks.c **** 
1750:Libraries/FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
1751:Libraries/FreeRTOS/Source/tasks.c **** 		{
1752:Libraries/FreeRTOS/Source/tasks.c **** 			/* Is there a space in the array for each task in the system? */
1753:Libraries/FreeRTOS/Source/tasks.c **** 			if( uxArraySize >= uxCurrentNumberOfTasks )
1754:Libraries/FreeRTOS/Source/tasks.c **** 			{
1755:Libraries/FreeRTOS/Source/tasks.c **** 				/* Fill in an TaskStatus_t structure with information on each
1756:Libraries/FreeRTOS/Source/tasks.c **** 				task in the Ready state. */
1757:Libraries/FreeRTOS/Source/tasks.c **** 				do
1758:Libraries/FreeRTOS/Source/tasks.c **** 				{
1759:Libraries/FreeRTOS/Source/tasks.c **** 					uxQueue--;
1760:Libraries/FreeRTOS/Source/tasks.c **** 					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[
1761:Libraries/FreeRTOS/Source/tasks.c **** 
1762:Libraries/FreeRTOS/Source/tasks.c **** 				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the cast
1763:Libraries/FreeRTOS/Source/tasks.c **** 
1764:Libraries/FreeRTOS/Source/tasks.c **** 				/* Fill in an TaskStatus_t structure with information on each
1765:Libraries/FreeRTOS/Source/tasks.c **** 				task in the Blocked state. */
1766:Libraries/FreeRTOS/Source/tasks.c **** 				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayed
1767:Libraries/FreeRTOS/Source/tasks.c **** 				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflo
1768:Libraries/FreeRTOS/Source/tasks.c **** 
1769:Libraries/FreeRTOS/Source/tasks.c **** 				#if( INCLUDE_vTaskDelete == 1 )
1770:Libraries/FreeRTOS/Source/tasks.c **** 				{
1771:Libraries/FreeRTOS/Source/tasks.c **** 					/* Fill in an TaskStatus_t structure with information on
1772:Libraries/FreeRTOS/Source/tasks.c **** 					each task that has been deleted but not yet cleaned up. */
1773:Libraries/FreeRTOS/Source/tasks.c **** 					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermina
1774:Libraries/FreeRTOS/Source/tasks.c **** 				}
1775:Libraries/FreeRTOS/Source/tasks.c **** 				#endif
1776:Libraries/FreeRTOS/Source/tasks.c **** 
1777:Libraries/FreeRTOS/Source/tasks.c **** 				#if ( INCLUDE_vTaskSuspend == 1 )
1778:Libraries/FreeRTOS/Source/tasks.c **** 				{
1779:Libraries/FreeRTOS/Source/tasks.c **** 					/* Fill in an TaskStatus_t structure with information on
1780:Libraries/FreeRTOS/Source/tasks.c **** 					each task in the Suspended state. */
1781:Libraries/FreeRTOS/Source/tasks.c **** 					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, 
1782:Libraries/FreeRTOS/Source/tasks.c **** 				}
1783:Libraries/FreeRTOS/Source/tasks.c **** 				#endif
1784:Libraries/FreeRTOS/Source/tasks.c **** 
1785:Libraries/FreeRTOS/Source/tasks.c **** 				#if ( configGENERATE_RUN_TIME_STATS == 1)
1786:Libraries/FreeRTOS/Source/tasks.c **** 				{
1787:Libraries/FreeRTOS/Source/tasks.c **** 					if( pulTotalRunTime != NULL )
1788:Libraries/FreeRTOS/Source/tasks.c **** 					{
1789:Libraries/FreeRTOS/Source/tasks.c **** 						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1790:Libraries/FreeRTOS/Source/tasks.c **** 							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
1791:Libraries/FreeRTOS/Source/tasks.c **** 						#else
1792:Libraries/FreeRTOS/Source/tasks.c **** 							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
1793:Libraries/FreeRTOS/Source/tasks.c **** 						#endif
1794:Libraries/FreeRTOS/Source/tasks.c **** 					}
1795:Libraries/FreeRTOS/Source/tasks.c **** 				}
1796:Libraries/FreeRTOS/Source/tasks.c **** 				#else
1797:Libraries/FreeRTOS/Source/tasks.c **** 				{
1798:Libraries/FreeRTOS/Source/tasks.c **** 					if( pulTotalRunTime != NULL )
1799:Libraries/FreeRTOS/Source/tasks.c **** 					{
1800:Libraries/FreeRTOS/Source/tasks.c **** 						*pulTotalRunTime = 0;
1801:Libraries/FreeRTOS/Source/tasks.c **** 					}
1802:Libraries/FreeRTOS/Source/tasks.c **** 				}
1803:Libraries/FreeRTOS/Source/tasks.c **** 				#endif
1804:Libraries/FreeRTOS/Source/tasks.c **** 			}
1805:Libraries/FreeRTOS/Source/tasks.c **** 			else
1806:Libraries/FreeRTOS/Source/tasks.c **** 			{
1807:Libraries/FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1808:Libraries/FreeRTOS/Source/tasks.c **** 			}
1809:Libraries/FreeRTOS/Source/tasks.c **** 		}
1810:Libraries/FreeRTOS/Source/tasks.c **** 		( void ) xTaskResumeAll();
1811:Libraries/FreeRTOS/Source/tasks.c **** 
1812:Libraries/FreeRTOS/Source/tasks.c **** 		return uxTask;
1813:Libraries/FreeRTOS/Source/tasks.c **** 	}
1814:Libraries/FreeRTOS/Source/tasks.c **** 
1815:Libraries/FreeRTOS/Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
1816:Libraries/FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1817:Libraries/FreeRTOS/Source/tasks.c **** 
1818:Libraries/FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1819:Libraries/FreeRTOS/Source/tasks.c **** 
1820:Libraries/FreeRTOS/Source/tasks.c **** 	TaskHandle_t xTaskGetIdleTaskHandle( void )
1821:Libraries/FreeRTOS/Source/tasks.c **** 	{
1822:Libraries/FreeRTOS/Source/tasks.c **** 		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
1823:Libraries/FreeRTOS/Source/tasks.c **** 		started, then xIdleTaskHandle will be NULL. */
1824:Libraries/FreeRTOS/Source/tasks.c **** 		configASSERT( ( xIdleTaskHandle != NULL ) );
1825:Libraries/FreeRTOS/Source/tasks.c **** 		return xIdleTaskHandle;
1826:Libraries/FreeRTOS/Source/tasks.c **** 	}
1827:Libraries/FreeRTOS/Source/tasks.c **** 
1828:Libraries/FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_xTaskGetIdleTaskHandle */
1829:Libraries/FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1830:Libraries/FreeRTOS/Source/tasks.c **** 
1831:Libraries/FreeRTOS/Source/tasks.c **** /* This conditional compilation should use inequality to 0, not equality to 1.
1832:Libraries/FreeRTOS/Source/tasks.c **** This is to ensure vTaskStepTick() is available when user defined low power mode
1833:Libraries/FreeRTOS/Source/tasks.c **** implementations require configUSE_TICKLESS_IDLE to be set to a value other than
1834:Libraries/FreeRTOS/Source/tasks.c **** 1. */
1835:Libraries/FreeRTOS/Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
1836:Libraries/FreeRTOS/Source/tasks.c **** 
1837:Libraries/FreeRTOS/Source/tasks.c **** 	void vTaskStepTick( const TickType_t xTicksToJump )
1838:Libraries/FreeRTOS/Source/tasks.c **** 	{
1839:Libraries/FreeRTOS/Source/tasks.c **** 		/* Correct the tick count value after a period during which the tick
1840:Libraries/FreeRTOS/Source/tasks.c **** 		was suppressed.  Note this does *not* call the tick hook function for
1841:Libraries/FreeRTOS/Source/tasks.c **** 		each stepped tick. */
1842:Libraries/FreeRTOS/Source/tasks.c **** 		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
1843:Libraries/FreeRTOS/Source/tasks.c **** 		xTickCount += xTicksToJump;
1844:Libraries/FreeRTOS/Source/tasks.c **** 		traceINCREASE_TICK_COUNT( xTicksToJump );
1845:Libraries/FreeRTOS/Source/tasks.c **** 	}
1846:Libraries/FreeRTOS/Source/tasks.c **** 
1847:Libraries/FreeRTOS/Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
1848:Libraries/FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1849:Libraries/FreeRTOS/Source/tasks.c **** 
1850:Libraries/FreeRTOS/Source/tasks.c **** BaseType_t xTaskIncrementTick( void )
1851:Libraries/FreeRTOS/Source/tasks.c **** {
1852:Libraries/FreeRTOS/Source/tasks.c **** TCB_t * pxTCB;
1853:Libraries/FreeRTOS/Source/tasks.c **** TickType_t xItemValue;
1854:Libraries/FreeRTOS/Source/tasks.c **** BaseType_t xSwitchRequired = pdFALSE;
1855:Libraries/FreeRTOS/Source/tasks.c **** 
1856:Libraries/FreeRTOS/Source/tasks.c **** 	/* Called by the portable layer each time a tick interrupt occurs.
1857:Libraries/FreeRTOS/Source/tasks.c **** 	Increments the tick then checks to see if the new tick value will cause any
1858:Libraries/FreeRTOS/Source/tasks.c **** 	tasks to be unblocked. */
1859:Libraries/FreeRTOS/Source/tasks.c **** 	traceTASK_INCREMENT_TICK( xTickCount );
1860:Libraries/FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
1861:Libraries/FreeRTOS/Source/tasks.c **** 	{
1862:Libraries/FreeRTOS/Source/tasks.c **** 		/* Increment the RTOS tick, switching the delayed and overflowed
1863:Libraries/FreeRTOS/Source/tasks.c **** 		delayed lists if it wraps to 0. */
1864:Libraries/FreeRTOS/Source/tasks.c **** 		++xTickCount;
1865:Libraries/FreeRTOS/Source/tasks.c **** 
1866:Libraries/FreeRTOS/Source/tasks.c **** 		{
1867:Libraries/FreeRTOS/Source/tasks.c **** 			/* Minor optimisation.  The tick count cannot change in this
1868:Libraries/FreeRTOS/Source/tasks.c **** 			block. */
1869:Libraries/FreeRTOS/Source/tasks.c **** 			const TickType_t xConstTickCount = xTickCount;
1870:Libraries/FreeRTOS/Source/tasks.c **** 
1871:Libraries/FreeRTOS/Source/tasks.c **** 			if( xConstTickCount == ( TickType_t ) 0U )
1872:Libraries/FreeRTOS/Source/tasks.c **** 			{
1873:Libraries/FreeRTOS/Source/tasks.c **** 				taskSWITCH_DELAYED_LISTS();
1874:Libraries/FreeRTOS/Source/tasks.c **** 			}
1875:Libraries/FreeRTOS/Source/tasks.c **** 			else
1876:Libraries/FreeRTOS/Source/tasks.c **** 			{
1877:Libraries/FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1878:Libraries/FreeRTOS/Source/tasks.c **** 			}
1879:Libraries/FreeRTOS/Source/tasks.c **** 
1880:Libraries/FreeRTOS/Source/tasks.c **** 			/* See if this tick has made a timeout expire.  Tasks are stored in
1881:Libraries/FreeRTOS/Source/tasks.c **** 			the	queue in the order of their wake time - meaning once one task
1882:Libraries/FreeRTOS/Source/tasks.c **** 			has been found whose block time has not expired there is no need to
1883:Libraries/FreeRTOS/Source/tasks.c **** 			look any further	down the list. */
1884:Libraries/FreeRTOS/Source/tasks.c **** 			if( xConstTickCount >= xNextTaskUnblockTime )
1885:Libraries/FreeRTOS/Source/tasks.c **** 			{
1886:Libraries/FreeRTOS/Source/tasks.c **** 				for( ;; )
1887:Libraries/FreeRTOS/Source/tasks.c **** 				{
1888:Libraries/FreeRTOS/Source/tasks.c **** 					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
1889:Libraries/FreeRTOS/Source/tasks.c **** 					{
1890:Libraries/FreeRTOS/Source/tasks.c **** 						/* The delayed list is empty.  Set xNextTaskUnblockTime
1891:Libraries/FreeRTOS/Source/tasks.c **** 						to the maximum possible value so it is extremely
1892:Libraries/FreeRTOS/Source/tasks.c **** 						unlikely that the
1893:Libraries/FreeRTOS/Source/tasks.c **** 						if( xTickCount >= xNextTaskUnblockTime ) test will pass
1894:Libraries/FreeRTOS/Source/tasks.c **** 						next time through. */
1895:Libraries/FreeRTOS/Source/tasks.c **** 						xNextTaskUnblockTime = portMAX_DELAY;
1896:Libraries/FreeRTOS/Source/tasks.c **** 						break;
1897:Libraries/FreeRTOS/Source/tasks.c **** 					}
1898:Libraries/FreeRTOS/Source/tasks.c **** 					else
1899:Libraries/FreeRTOS/Source/tasks.c **** 					{
1900:Libraries/FreeRTOS/Source/tasks.c **** 						/* The delayed list is not empty, get the value of the
1901:Libraries/FreeRTOS/Source/tasks.c **** 						item at the head of the delayed list.  This is the time
1902:Libraries/FreeRTOS/Source/tasks.c **** 						at which the task at the head of the delayed list must
1903:Libraries/FreeRTOS/Source/tasks.c **** 						be removed from the Blocked state. */
1904:Libraries/FreeRTOS/Source/tasks.c **** 						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
1905:Libraries/FreeRTOS/Source/tasks.c **** 						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
1906:Libraries/FreeRTOS/Source/tasks.c **** 
1907:Libraries/FreeRTOS/Source/tasks.c **** 						if( xConstTickCount < xItemValue )
1908:Libraries/FreeRTOS/Source/tasks.c **** 						{
1909:Libraries/FreeRTOS/Source/tasks.c **** 							/* It is not time to unblock this item yet, but the
1910:Libraries/FreeRTOS/Source/tasks.c **** 							item value is the time at which the task at the head
1911:Libraries/FreeRTOS/Source/tasks.c **** 							of the blocked list must be removed from the Blocked
1912:Libraries/FreeRTOS/Source/tasks.c **** 							state -	so record the item value in
1913:Libraries/FreeRTOS/Source/tasks.c **** 							xNextTaskUnblockTime. */
1914:Libraries/FreeRTOS/Source/tasks.c **** 							xNextTaskUnblockTime = xItemValue;
1915:Libraries/FreeRTOS/Source/tasks.c **** 							break;
1916:Libraries/FreeRTOS/Source/tasks.c **** 						}
1917:Libraries/FreeRTOS/Source/tasks.c **** 						else
1918:Libraries/FreeRTOS/Source/tasks.c **** 						{
1919:Libraries/FreeRTOS/Source/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
1920:Libraries/FreeRTOS/Source/tasks.c **** 						}
1921:Libraries/FreeRTOS/Source/tasks.c **** 
1922:Libraries/FreeRTOS/Source/tasks.c **** 						/* It is time to remove the item from the Blocked state. */
1923:Libraries/FreeRTOS/Source/tasks.c **** 						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
1924:Libraries/FreeRTOS/Source/tasks.c **** 
1925:Libraries/FreeRTOS/Source/tasks.c **** 						/* Is the task waiting on an event also?  If so remove
1926:Libraries/FreeRTOS/Source/tasks.c **** 						it from the event list. */
1927:Libraries/FreeRTOS/Source/tasks.c **** 						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
1928:Libraries/FreeRTOS/Source/tasks.c **** 						{
1929:Libraries/FreeRTOS/Source/tasks.c **** 							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
1930:Libraries/FreeRTOS/Source/tasks.c **** 						}
1931:Libraries/FreeRTOS/Source/tasks.c **** 						else
1932:Libraries/FreeRTOS/Source/tasks.c **** 						{
1933:Libraries/FreeRTOS/Source/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
1934:Libraries/FreeRTOS/Source/tasks.c **** 						}
1935:Libraries/FreeRTOS/Source/tasks.c **** 
1936:Libraries/FreeRTOS/Source/tasks.c **** 						/* Place the unblocked task into the appropriate ready
1937:Libraries/FreeRTOS/Source/tasks.c **** 						list. */
1938:Libraries/FreeRTOS/Source/tasks.c **** 						prvAddTaskToReadyList( pxTCB );
1939:Libraries/FreeRTOS/Source/tasks.c **** 
1940:Libraries/FreeRTOS/Source/tasks.c **** 						/* A task being unblocked cannot cause an immediate
1941:Libraries/FreeRTOS/Source/tasks.c **** 						context switch if preemption is turned off. */
1942:Libraries/FreeRTOS/Source/tasks.c **** 						#if (  configUSE_PREEMPTION == 1 )
1943:Libraries/FreeRTOS/Source/tasks.c **** 						{
1944:Libraries/FreeRTOS/Source/tasks.c **** 							/* Preemption is on, but a context switch should
1945:Libraries/FreeRTOS/Source/tasks.c **** 							only be performed if the unblocked task has a
1946:Libraries/FreeRTOS/Source/tasks.c **** 							priority that is equal to or higher than the
1947:Libraries/FreeRTOS/Source/tasks.c **** 							currently executing task. */
1948:Libraries/FreeRTOS/Source/tasks.c **** 							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1949:Libraries/FreeRTOS/Source/tasks.c **** 							{
1950:Libraries/FreeRTOS/Source/tasks.c **** 								xSwitchRequired = pdTRUE;
1951:Libraries/FreeRTOS/Source/tasks.c **** 							}
1952:Libraries/FreeRTOS/Source/tasks.c **** 							else
1953:Libraries/FreeRTOS/Source/tasks.c **** 							{
1954:Libraries/FreeRTOS/Source/tasks.c **** 								mtCOVERAGE_TEST_MARKER();
1955:Libraries/FreeRTOS/Source/tasks.c **** 							}
1956:Libraries/FreeRTOS/Source/tasks.c **** 						}
1957:Libraries/FreeRTOS/Source/tasks.c **** 						#endif /* configUSE_PREEMPTION */
1958:Libraries/FreeRTOS/Source/tasks.c **** 					}
1959:Libraries/FreeRTOS/Source/tasks.c **** 				}
1960:Libraries/FreeRTOS/Source/tasks.c **** 			}
1961:Libraries/FreeRTOS/Source/tasks.c **** 		}
1962:Libraries/FreeRTOS/Source/tasks.c **** 
1963:Libraries/FreeRTOS/Source/tasks.c **** 		/* Tasks of equal priority to the currently running task will share
1964:Libraries/FreeRTOS/Source/tasks.c **** 		processing time (time slice) if preemption is on, and the application
1965:Libraries/FreeRTOS/Source/tasks.c **** 		writer has not explicitly turned time slicing off. */
1966:Libraries/FreeRTOS/Source/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
1967:Libraries/FreeRTOS/Source/tasks.c **** 		{
1968:Libraries/FreeRTOS/Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_
1969:Libraries/FreeRTOS/Source/tasks.c **** 			{
1970:Libraries/FreeRTOS/Source/tasks.c **** 				xSwitchRequired = pdTRUE;
1971:Libraries/FreeRTOS/Source/tasks.c **** 			}
1972:Libraries/FreeRTOS/Source/tasks.c **** 			else
1973:Libraries/FreeRTOS/Source/tasks.c **** 			{
1974:Libraries/FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1975:Libraries/FreeRTOS/Source/tasks.c **** 			}
1976:Libraries/FreeRTOS/Source/tasks.c **** 		}
1977:Libraries/FreeRTOS/Source/tasks.c **** 		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
1978:Libraries/FreeRTOS/Source/tasks.c **** 
1979:Libraries/FreeRTOS/Source/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
1980:Libraries/FreeRTOS/Source/tasks.c **** 		{
1981:Libraries/FreeRTOS/Source/tasks.c **** 			/* Guard against the tick hook being called when the pended tick
1982:Libraries/FreeRTOS/Source/tasks.c **** 			count is being unwound (when the scheduler is being unlocked). */
1983:Libraries/FreeRTOS/Source/tasks.c **** 			if( uxPendedTicks == ( UBaseType_t ) 0U )
1984:Libraries/FreeRTOS/Source/tasks.c **** 			{
1985:Libraries/FreeRTOS/Source/tasks.c **** 				vApplicationTickHook();
1986:Libraries/FreeRTOS/Source/tasks.c **** 			}
1987:Libraries/FreeRTOS/Source/tasks.c **** 			else
1988:Libraries/FreeRTOS/Source/tasks.c **** 			{
1989:Libraries/FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1990:Libraries/FreeRTOS/Source/tasks.c **** 			}
1991:Libraries/FreeRTOS/Source/tasks.c **** 		}
1992:Libraries/FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_TICK_HOOK */
1993:Libraries/FreeRTOS/Source/tasks.c **** 	}
1994:Libraries/FreeRTOS/Source/tasks.c **** 	else
1995:Libraries/FreeRTOS/Source/tasks.c **** 	{
1996:Libraries/FreeRTOS/Source/tasks.c **** 		++uxPendedTicks;
1997:Libraries/FreeRTOS/Source/tasks.c **** 
1998:Libraries/FreeRTOS/Source/tasks.c **** 		/* The tick hook gets called at regular intervals, even if the
1999:Libraries/FreeRTOS/Source/tasks.c **** 		scheduler is locked. */
2000:Libraries/FreeRTOS/Source/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
2001:Libraries/FreeRTOS/Source/tasks.c **** 		{
2002:Libraries/FreeRTOS/Source/tasks.c **** 			vApplicationTickHook();
2003:Libraries/FreeRTOS/Source/tasks.c **** 		}
2004:Libraries/FreeRTOS/Source/tasks.c **** 		#endif
2005:Libraries/FreeRTOS/Source/tasks.c **** 	}
2006:Libraries/FreeRTOS/Source/tasks.c **** 
2007:Libraries/FreeRTOS/Source/tasks.c **** 	#if ( configUSE_PREEMPTION == 1 )
2008:Libraries/FreeRTOS/Source/tasks.c **** 	{
2009:Libraries/FreeRTOS/Source/tasks.c **** 		if( xYieldPending != pdFALSE )
2010:Libraries/FreeRTOS/Source/tasks.c **** 		{
2011:Libraries/FreeRTOS/Source/tasks.c **** 			xSwitchRequired = pdTRUE;
2012:Libraries/FreeRTOS/Source/tasks.c **** 		}
2013:Libraries/FreeRTOS/Source/tasks.c **** 		else
2014:Libraries/FreeRTOS/Source/tasks.c **** 		{
2015:Libraries/FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2016:Libraries/FreeRTOS/Source/tasks.c **** 		}
2017:Libraries/FreeRTOS/Source/tasks.c **** 	}
2018:Libraries/FreeRTOS/Source/tasks.c **** 	#endif /* configUSE_PREEMPTION */
2019:Libraries/FreeRTOS/Source/tasks.c **** 
2020:Libraries/FreeRTOS/Source/tasks.c **** 	return xSwitchRequired;
2021:Libraries/FreeRTOS/Source/tasks.c **** }
2022:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2023:Libraries/FreeRTOS/Source/tasks.c **** 
2024:Libraries/FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2025:Libraries/FreeRTOS/Source/tasks.c **** 
2026:Libraries/FreeRTOS/Source/tasks.c **** 	void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction )
2027:Libraries/FreeRTOS/Source/tasks.c **** 	{
2028:Libraries/FreeRTOS/Source/tasks.c **** 	TCB_t *xTCB;
2029:Libraries/FreeRTOS/Source/tasks.c **** 
2030:Libraries/FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then it is the task hook of the calling task that is
2031:Libraries/FreeRTOS/Source/tasks.c **** 		getting set. */
2032:Libraries/FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
2033:Libraries/FreeRTOS/Source/tasks.c **** 		{
2034:Libraries/FreeRTOS/Source/tasks.c **** 			xTCB = ( TCB_t * ) pxCurrentTCB;
2035:Libraries/FreeRTOS/Source/tasks.c **** 		}
2036:Libraries/FreeRTOS/Source/tasks.c **** 		else
2037:Libraries/FreeRTOS/Source/tasks.c **** 		{
2038:Libraries/FreeRTOS/Source/tasks.c **** 			xTCB = ( TCB_t * ) xTask;
2039:Libraries/FreeRTOS/Source/tasks.c **** 		}
2040:Libraries/FreeRTOS/Source/tasks.c **** 
2041:Libraries/FreeRTOS/Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
2042:Libraries/FreeRTOS/Source/tasks.c **** 		the value can be accessed from an interrupt. */
2043:Libraries/FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
2044:Libraries/FreeRTOS/Source/tasks.c **** 			xTCB->pxTaskTag = pxHookFunction;
2045:Libraries/FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
2046:Libraries/FreeRTOS/Source/tasks.c **** 	}
2047:Libraries/FreeRTOS/Source/tasks.c **** 
2048:Libraries/FreeRTOS/Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2049:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2050:Libraries/FreeRTOS/Source/tasks.c **** 
2051:Libraries/FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2052:Libraries/FreeRTOS/Source/tasks.c **** 
2053:Libraries/FreeRTOS/Source/tasks.c **** 	TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )
2054:Libraries/FreeRTOS/Source/tasks.c **** 	{
2055:Libraries/FreeRTOS/Source/tasks.c **** 	TCB_t *xTCB;
2056:Libraries/FreeRTOS/Source/tasks.c **** 	TaskHookFunction_t xReturn;
2057:Libraries/FreeRTOS/Source/tasks.c **** 
2058:Libraries/FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
2059:Libraries/FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
2060:Libraries/FreeRTOS/Source/tasks.c **** 		{
2061:Libraries/FreeRTOS/Source/tasks.c **** 			xTCB = ( TCB_t * ) pxCurrentTCB;
2062:Libraries/FreeRTOS/Source/tasks.c **** 		}
2063:Libraries/FreeRTOS/Source/tasks.c **** 		else
2064:Libraries/FreeRTOS/Source/tasks.c **** 		{
2065:Libraries/FreeRTOS/Source/tasks.c **** 			xTCB = ( TCB_t * ) xTask;
2066:Libraries/FreeRTOS/Source/tasks.c **** 		}
2067:Libraries/FreeRTOS/Source/tasks.c **** 
2068:Libraries/FreeRTOS/Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
2069:Libraries/FreeRTOS/Source/tasks.c **** 		the value can be accessed from an interrupt. */
2070:Libraries/FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
2071:Libraries/FreeRTOS/Source/tasks.c **** 		{
2072:Libraries/FreeRTOS/Source/tasks.c **** 			xReturn = xTCB->pxTaskTag;
2073:Libraries/FreeRTOS/Source/tasks.c **** 		}
2074:Libraries/FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
2075:Libraries/FreeRTOS/Source/tasks.c **** 
2076:Libraries/FreeRTOS/Source/tasks.c **** 		return xReturn;
2077:Libraries/FreeRTOS/Source/tasks.c **** 	}
2078:Libraries/FreeRTOS/Source/tasks.c **** 
2079:Libraries/FreeRTOS/Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2080:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2081:Libraries/FreeRTOS/Source/tasks.c **** 
2082:Libraries/FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2083:Libraries/FreeRTOS/Source/tasks.c **** 
2084:Libraries/FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter )
2085:Libraries/FreeRTOS/Source/tasks.c **** 	{
2086:Libraries/FreeRTOS/Source/tasks.c **** 	TCB_t *xTCB;
2087:Libraries/FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn;
2088:Libraries/FreeRTOS/Source/tasks.c **** 
2089:Libraries/FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then we are calling our own task hook. */
2090:Libraries/FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
2091:Libraries/FreeRTOS/Source/tasks.c **** 		{
2092:Libraries/FreeRTOS/Source/tasks.c **** 			xTCB = ( TCB_t * ) pxCurrentTCB;
2093:Libraries/FreeRTOS/Source/tasks.c **** 		}
2094:Libraries/FreeRTOS/Source/tasks.c **** 		else
2095:Libraries/FreeRTOS/Source/tasks.c **** 		{
2096:Libraries/FreeRTOS/Source/tasks.c **** 			xTCB = ( TCB_t * ) xTask;
2097:Libraries/FreeRTOS/Source/tasks.c **** 		}
2098:Libraries/FreeRTOS/Source/tasks.c **** 
2099:Libraries/FreeRTOS/Source/tasks.c **** 		if( xTCB->pxTaskTag != NULL )
2100:Libraries/FreeRTOS/Source/tasks.c **** 		{
2101:Libraries/FreeRTOS/Source/tasks.c **** 			xReturn = xTCB->pxTaskTag( pvParameter );
2102:Libraries/FreeRTOS/Source/tasks.c **** 		}
2103:Libraries/FreeRTOS/Source/tasks.c **** 		else
2104:Libraries/FreeRTOS/Source/tasks.c **** 		{
2105:Libraries/FreeRTOS/Source/tasks.c **** 			xReturn = pdFAIL;
2106:Libraries/FreeRTOS/Source/tasks.c **** 		}
2107:Libraries/FreeRTOS/Source/tasks.c **** 
2108:Libraries/FreeRTOS/Source/tasks.c **** 		return xReturn;
2109:Libraries/FreeRTOS/Source/tasks.c **** 	}
2110:Libraries/FreeRTOS/Source/tasks.c **** 
2111:Libraries/FreeRTOS/Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2112:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2113:Libraries/FreeRTOS/Source/tasks.c **** 
2114:Libraries/FreeRTOS/Source/tasks.c **** void vTaskSwitchContext( void )
2115:Libraries/FreeRTOS/Source/tasks.c **** {
2116:Libraries/FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
2117:Libraries/FreeRTOS/Source/tasks.c **** 	{
2118:Libraries/FreeRTOS/Source/tasks.c **** 		/* The scheduler is currently suspended - do not allow a context
2119:Libraries/FreeRTOS/Source/tasks.c **** 		switch. */
2120:Libraries/FreeRTOS/Source/tasks.c **** 		xYieldPending = pdTRUE;
2121:Libraries/FreeRTOS/Source/tasks.c **** 	}
2122:Libraries/FreeRTOS/Source/tasks.c **** 	else
2123:Libraries/FreeRTOS/Source/tasks.c **** 	{
2124:Libraries/FreeRTOS/Source/tasks.c **** 		xYieldPending = pdFALSE;
2125:Libraries/FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_OUT();
2126:Libraries/FreeRTOS/Source/tasks.c **** 
2127:Libraries/FreeRTOS/Source/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
2128:Libraries/FreeRTOS/Source/tasks.c **** 		{
2129:Libraries/FreeRTOS/Source/tasks.c **** 				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
2130:Libraries/FreeRTOS/Source/tasks.c **** 					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
2131:Libraries/FreeRTOS/Source/tasks.c **** 				#else
2132:Libraries/FreeRTOS/Source/tasks.c **** 					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
2133:Libraries/FreeRTOS/Source/tasks.c **** 				#endif
2134:Libraries/FreeRTOS/Source/tasks.c **** 
2135:Libraries/FreeRTOS/Source/tasks.c **** 				/* Add the amount of time the task has been running to the
2136:Libraries/FreeRTOS/Source/tasks.c **** 				accumulated	time so far.  The time the task started running was
2137:Libraries/FreeRTOS/Source/tasks.c **** 				stored in ulTaskSwitchedInTime.  Note that there is no overflow
2138:Libraries/FreeRTOS/Source/tasks.c **** 				protection here	so count values are only valid until the timer
2139:Libraries/FreeRTOS/Source/tasks.c **** 				overflows.  The guard against negative values is to protect
2140:Libraries/FreeRTOS/Source/tasks.c **** 				against suspect run time stat counter implementations - which
2141:Libraries/FreeRTOS/Source/tasks.c **** 				are provided by the application, not the kernel. */
2142:Libraries/FreeRTOS/Source/tasks.c **** 				if( ulTotalRunTime > ulTaskSwitchedInTime )
2143:Libraries/FreeRTOS/Source/tasks.c **** 				{
2144:Libraries/FreeRTOS/Source/tasks.c **** 					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
2145:Libraries/FreeRTOS/Source/tasks.c **** 				}
2146:Libraries/FreeRTOS/Source/tasks.c **** 				else
2147:Libraries/FreeRTOS/Source/tasks.c **** 				{
2148:Libraries/FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
2149:Libraries/FreeRTOS/Source/tasks.c **** 				}
2150:Libraries/FreeRTOS/Source/tasks.c **** 				ulTaskSwitchedInTime = ulTotalRunTime;
2151:Libraries/FreeRTOS/Source/tasks.c **** 		}
2152:Libraries/FreeRTOS/Source/tasks.c **** 		#endif /* configGENERATE_RUN_TIME_STATS */
2153:Libraries/FreeRTOS/Source/tasks.c **** 
2154:Libraries/FreeRTOS/Source/tasks.c **** 		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
2155:Libraries/FreeRTOS/Source/tasks.c **** 		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
2156:Libraries/FreeRTOS/Source/tasks.c **** 
2157:Libraries/FreeRTOS/Source/tasks.c **** 		taskSELECT_HIGHEST_PRIORITY_TASK();
2158:Libraries/FreeRTOS/Source/tasks.c **** 
2159:Libraries/FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_IN();
2160:Libraries/FreeRTOS/Source/tasks.c **** 
2161:Libraries/FreeRTOS/Source/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
2162:Libraries/FreeRTOS/Source/tasks.c **** 		{
2163:Libraries/FreeRTOS/Source/tasks.c **** 			/* Switch Newlib's _impure_ptr variable to point to the _reent
2164:Libraries/FreeRTOS/Source/tasks.c **** 			structure specific to this task. */
2165:Libraries/FreeRTOS/Source/tasks.c **** 			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
2166:Libraries/FreeRTOS/Source/tasks.c **** 		}
2167:Libraries/FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
2168:Libraries/FreeRTOS/Source/tasks.c **** 	}
2169:Libraries/FreeRTOS/Source/tasks.c **** }
2170:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2171:Libraries/FreeRTOS/Source/tasks.c **** 
2172:Libraries/FreeRTOS/Source/tasks.c **** void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
2173:Libraries/FreeRTOS/Source/tasks.c **** {
2174:Libraries/FreeRTOS/Source/tasks.c **** TickType_t xTimeToWake;
2175:Libraries/FreeRTOS/Source/tasks.c **** 
2176:Libraries/FreeRTOS/Source/tasks.c **** 	configASSERT( pxEventList );
2177:Libraries/FreeRTOS/Source/tasks.c **** 
2178:Libraries/FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
2179:Libraries/FreeRTOS/Source/tasks.c **** 	SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
2180:Libraries/FreeRTOS/Source/tasks.c **** 
2181:Libraries/FreeRTOS/Source/tasks.c **** 	/* Place the event list item of the TCB in the appropriate event list.
2182:Libraries/FreeRTOS/Source/tasks.c **** 	This is placed in the list in priority order so the highest priority task
2183:Libraries/FreeRTOS/Source/tasks.c **** 	is the first to be woken by the event.  The queue that contains the event
2184:Libraries/FreeRTOS/Source/tasks.c **** 	list is locked, preventing simultaneous access from interrupts. */
2185:Libraries/FreeRTOS/Source/tasks.c **** 	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
2186:Libraries/FreeRTOS/Source/tasks.c **** 
2187:Libraries/FreeRTOS/Source/tasks.c **** 	/* The task must be removed from from the ready list before it is added to
2188:Libraries/FreeRTOS/Source/tasks.c **** 	the blocked list as the same list item is used for both lists.  Exclusive
2189:Libraries/FreeRTOS/Source/tasks.c **** 	access to the ready lists guaranteed because the scheduler is locked. */
2190:Libraries/FreeRTOS/Source/tasks.c **** 	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
2191:Libraries/FreeRTOS/Source/tasks.c **** 	{
2192:Libraries/FreeRTOS/Source/tasks.c **** 		/* The current task must be in a ready list, so there is no need to
2193:Libraries/FreeRTOS/Source/tasks.c **** 		check, and the port reset macro can be called directly. */
2194:Libraries/FreeRTOS/Source/tasks.c **** 		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
2195:Libraries/FreeRTOS/Source/tasks.c **** 	}
2196:Libraries/FreeRTOS/Source/tasks.c **** 	else
2197:Libraries/FreeRTOS/Source/tasks.c **** 	{
2198:Libraries/FreeRTOS/Source/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
2199:Libraries/FreeRTOS/Source/tasks.c **** 	}
2200:Libraries/FreeRTOS/Source/tasks.c **** 
2201:Libraries/FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
2202:Libraries/FreeRTOS/Source/tasks.c **** 	{
2203:Libraries/FreeRTOS/Source/tasks.c **** 		if( xTicksToWait == portMAX_DELAY )
2204:Libraries/FreeRTOS/Source/tasks.c **** 		{
2205:Libraries/FreeRTOS/Source/tasks.c **** 			/* Add the task to the suspended task list instead of a delayed task
2206:Libraries/FreeRTOS/Source/tasks.c **** 			list to ensure the task is not woken by a timing event.  It will
2207:Libraries/FreeRTOS/Source/tasks.c **** 			block indefinitely. */
2208:Libraries/FreeRTOS/Source/tasks.c **** 			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
2209:Libraries/FreeRTOS/Source/tasks.c **** 		}
2210:Libraries/FreeRTOS/Source/tasks.c **** 		else
2211:Libraries/FreeRTOS/Source/tasks.c **** 		{
2212:Libraries/FreeRTOS/Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event
2213:Libraries/FreeRTOS/Source/tasks.c **** 			does not occur.  This may overflow but this doesn't matter, the
2214:Libraries/FreeRTOS/Source/tasks.c **** 			scheduler will handle it. */
2215:Libraries/FreeRTOS/Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
2216:Libraries/FreeRTOS/Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
2217:Libraries/FreeRTOS/Source/tasks.c **** 		}
2218:Libraries/FreeRTOS/Source/tasks.c **** 	}
2219:Libraries/FreeRTOS/Source/tasks.c **** 	#else /* INCLUDE_vTaskSuspend */
2220:Libraries/FreeRTOS/Source/tasks.c **** 	{
2221:Libraries/FreeRTOS/Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
2222:Libraries/FreeRTOS/Source/tasks.c **** 			not occur.  This may overflow but this doesn't matter, the scheduler
2223:Libraries/FreeRTOS/Source/tasks.c **** 			will handle it. */
2224:Libraries/FreeRTOS/Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
2225:Libraries/FreeRTOS/Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
2226:Libraries/FreeRTOS/Source/tasks.c **** 	}
2227:Libraries/FreeRTOS/Source/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
2228:Libraries/FreeRTOS/Source/tasks.c **** }
2229:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2230:Libraries/FreeRTOS/Source/tasks.c **** 
2231:Libraries/FreeRTOS/Source/tasks.c **** void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickT
2232:Libraries/FreeRTOS/Source/tasks.c **** {
2233:Libraries/FreeRTOS/Source/tasks.c **** TickType_t xTimeToWake;
2234:Libraries/FreeRTOS/Source/tasks.c **** 
2235:Libraries/FreeRTOS/Source/tasks.c **** 	configASSERT( pxEventList );
2236:Libraries/FreeRTOS/Source/tasks.c **** 
2237:Libraries/FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
2238:Libraries/FreeRTOS/Source/tasks.c **** 	the event groups implementation. */
2239:Libraries/FreeRTOS/Source/tasks.c **** 	configASSERT( uxSchedulerSuspended != 0 );
2240:Libraries/FreeRTOS/Source/tasks.c **** 
2241:Libraries/FreeRTOS/Source/tasks.c **** 	/* Store the item value in the event list item.  It is safe to access the
2242:Libraries/FreeRTOS/Source/tasks.c **** 	event list item here as interrupts won't access the event list item of a
2243:Libraries/FreeRTOS/Source/tasks.c **** 	task that is not in the Blocked state. */
2244:Libraries/FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE
2245:Libraries/FreeRTOS/Source/tasks.c **** 
2246:Libraries/FreeRTOS/Source/tasks.c **** 	/* Place the event list item of the TCB at the end of the appropriate event
2247:Libraries/FreeRTOS/Source/tasks.c **** 	list.  It is safe to access the event list here because it is part of an
2248:Libraries/FreeRTOS/Source/tasks.c **** 	event group implementation - and interrupts don't access event groups
2249:Libraries/FreeRTOS/Source/tasks.c **** 	directly (instead they access them indirectly by pending function calls to
2250:Libraries/FreeRTOS/Source/tasks.c **** 	the task level). */
2251:Libraries/FreeRTOS/Source/tasks.c **** 	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
2252:Libraries/FreeRTOS/Source/tasks.c **** 
2253:Libraries/FreeRTOS/Source/tasks.c **** 	/* The task must be removed from the ready list before it is added to the
2254:Libraries/FreeRTOS/Source/tasks.c **** 	blocked list.  Exclusive access can be assured to the ready list as the
2255:Libraries/FreeRTOS/Source/tasks.c **** 	scheduler is locked. */
2256:Libraries/FreeRTOS/Source/tasks.c **** 	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
2257:Libraries/FreeRTOS/Source/tasks.c **** 	{
2258:Libraries/FreeRTOS/Source/tasks.c **** 		/* The current task must be in a ready list, so there is no need to
2259:Libraries/FreeRTOS/Source/tasks.c **** 		check, and the port reset macro can be called directly. */
2260:Libraries/FreeRTOS/Source/tasks.c **** 		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
2261:Libraries/FreeRTOS/Source/tasks.c **** 	}
2262:Libraries/FreeRTOS/Source/tasks.c **** 	else
2263:Libraries/FreeRTOS/Source/tasks.c **** 	{
2264:Libraries/FreeRTOS/Source/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
2265:Libraries/FreeRTOS/Source/tasks.c **** 	}
2266:Libraries/FreeRTOS/Source/tasks.c **** 
2267:Libraries/FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
2268:Libraries/FreeRTOS/Source/tasks.c **** 	{
2269:Libraries/FreeRTOS/Source/tasks.c **** 		if( xTicksToWait == portMAX_DELAY )
2270:Libraries/FreeRTOS/Source/tasks.c **** 		{
2271:Libraries/FreeRTOS/Source/tasks.c **** 			/* Add the task to the suspended task list instead of a delayed task
2272:Libraries/FreeRTOS/Source/tasks.c **** 			list to ensure it is not woken by a timing event.  It will block
2273:Libraries/FreeRTOS/Source/tasks.c **** 			indefinitely. */
2274:Libraries/FreeRTOS/Source/tasks.c **** 			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
2275:Libraries/FreeRTOS/Source/tasks.c **** 		}
2276:Libraries/FreeRTOS/Source/tasks.c **** 		else
2277:Libraries/FreeRTOS/Source/tasks.c **** 		{
2278:Libraries/FreeRTOS/Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event
2279:Libraries/FreeRTOS/Source/tasks.c **** 			does not occur.  This may overflow but this doesn't matter, the
2280:Libraries/FreeRTOS/Source/tasks.c **** 			kernel will manage it correctly. */
2281:Libraries/FreeRTOS/Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
2282:Libraries/FreeRTOS/Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
2283:Libraries/FreeRTOS/Source/tasks.c **** 		}
2284:Libraries/FreeRTOS/Source/tasks.c **** 	}
2285:Libraries/FreeRTOS/Source/tasks.c **** 	#else /* INCLUDE_vTaskSuspend */
2286:Libraries/FreeRTOS/Source/tasks.c **** 	{
2287:Libraries/FreeRTOS/Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
2288:Libraries/FreeRTOS/Source/tasks.c **** 			not occur.  This may overflow but this doesn't matter, the kernel
2289:Libraries/FreeRTOS/Source/tasks.c **** 			will manage it correctly. */
2290:Libraries/FreeRTOS/Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
2291:Libraries/FreeRTOS/Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
2292:Libraries/FreeRTOS/Source/tasks.c **** 	}
2293:Libraries/FreeRTOS/Source/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
2294:Libraries/FreeRTOS/Source/tasks.c **** }
2295:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2296:Libraries/FreeRTOS/Source/tasks.c **** 
2297:Libraries/FreeRTOS/Source/tasks.c **** #if configUSE_TIMERS == 1
2298:Libraries/FreeRTOS/Source/tasks.c **** 
2299:Libraries/FreeRTOS/Source/tasks.c **** 	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, const TickType_t xTicksToWait )
2300:Libraries/FreeRTOS/Source/tasks.c **** 	{
2301:Libraries/FreeRTOS/Source/tasks.c **** 	TickType_t xTimeToWake;
2302:Libraries/FreeRTOS/Source/tasks.c **** 
2303:Libraries/FreeRTOS/Source/tasks.c **** 		configASSERT( pxEventList );
2304:Libraries/FreeRTOS/Source/tasks.c **** 
2305:Libraries/FreeRTOS/Source/tasks.c **** 		/* This function should not be called by application code hence the
2306:Libraries/FreeRTOS/Source/tasks.c **** 		'Restricted' in its name.  It is not part of the public API.  It is
2307:Libraries/FreeRTOS/Source/tasks.c **** 		designed for use by kernel code, and has special calling requirements -
2308:Libraries/FreeRTOS/Source/tasks.c **** 		it should be called from a critical section. */
2309:Libraries/FreeRTOS/Source/tasks.c **** 
2310:Libraries/FreeRTOS/Source/tasks.c **** 
2311:Libraries/FreeRTOS/Source/tasks.c **** 		/* Place the event list item of the TCB in the appropriate event list.
2312:Libraries/FreeRTOS/Source/tasks.c **** 		In this case it is assume that this is the only task that is going to
2313:Libraries/FreeRTOS/Source/tasks.c **** 		be waiting on this event list, so the faster vListInsertEnd() function
2314:Libraries/FreeRTOS/Source/tasks.c **** 		can be used in place of vListInsert. */
2315:Libraries/FreeRTOS/Source/tasks.c **** 		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
2316:Libraries/FreeRTOS/Source/tasks.c **** 
2317:Libraries/FreeRTOS/Source/tasks.c **** 		/* We must remove this task from the ready list before adding it to the
2318:Libraries/FreeRTOS/Source/tasks.c **** 		blocked list as the same list item is used for both lists.  This
2319:Libraries/FreeRTOS/Source/tasks.c **** 		function is called form a critical section. */
2320:Libraries/FreeRTOS/Source/tasks.c **** 		if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
2321:Libraries/FreeRTOS/Source/tasks.c **** 		{
2322:Libraries/FreeRTOS/Source/tasks.c **** 			/* The current task must be in a ready list, so there is no need to
2323:Libraries/FreeRTOS/Source/tasks.c **** 			check, and the port reset macro can be called directly. */
2324:Libraries/FreeRTOS/Source/tasks.c **** 			portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
2325:Libraries/FreeRTOS/Source/tasks.c **** 		}
2326:Libraries/FreeRTOS/Source/tasks.c **** 		else
2327:Libraries/FreeRTOS/Source/tasks.c **** 		{
2328:Libraries/FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2329:Libraries/FreeRTOS/Source/tasks.c **** 		}
2330:Libraries/FreeRTOS/Source/tasks.c **** 
2331:Libraries/FreeRTOS/Source/tasks.c **** 		/* Calculate the time at which the task should be woken if the event does
2332:Libraries/FreeRTOS/Source/tasks.c **** 		not occur.  This may overflow but this doesn't matter. */
2333:Libraries/FreeRTOS/Source/tasks.c **** 		xTimeToWake = xTickCount + xTicksToWait;
2334:Libraries/FreeRTOS/Source/tasks.c **** 
2335:Libraries/FreeRTOS/Source/tasks.c **** 		traceTASK_DELAY_UNTIL();
2336:Libraries/FreeRTOS/Source/tasks.c **** 		prvAddCurrentTaskToDelayedList( xTimeToWake );
2337:Libraries/FreeRTOS/Source/tasks.c **** 	}
2338:Libraries/FreeRTOS/Source/tasks.c **** 
2339:Libraries/FreeRTOS/Source/tasks.c **** #endif /* configUSE_TIMERS */
2340:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2341:Libraries/FreeRTOS/Source/tasks.c **** 
2342:Libraries/FreeRTOS/Source/tasks.c **** BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
2343:Libraries/FreeRTOS/Source/tasks.c **** {
2344:Libraries/FreeRTOS/Source/tasks.c **** TCB_t *pxUnblockedTCB;
2345:Libraries/FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
2346:Libraries/FreeRTOS/Source/tasks.c **** 
2347:Libraries/FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
2348:Libraries/FreeRTOS/Source/tasks.c **** 	called from a critical section within an ISR. */
2349:Libraries/FreeRTOS/Source/tasks.c **** 
2350:Libraries/FreeRTOS/Source/tasks.c **** 	/* The event list is sorted in priority order, so the first in the list can
2351:Libraries/FreeRTOS/Source/tasks.c **** 	be removed as it is known to be the highest priority.  Remove the TCB from
2352:Libraries/FreeRTOS/Source/tasks.c **** 	the delayed list, and add it to the ready list.
2353:Libraries/FreeRTOS/Source/tasks.c **** 
2354:Libraries/FreeRTOS/Source/tasks.c **** 	If an event is for a queue that is locked then this function will never
2355:Libraries/FreeRTOS/Source/tasks.c **** 	get called - the lock count on the queue will get modified instead.  This
2356:Libraries/FreeRTOS/Source/tasks.c **** 	means exclusive access to the event list is guaranteed here.
2357:Libraries/FreeRTOS/Source/tasks.c **** 
2358:Libraries/FreeRTOS/Source/tasks.c **** 	This function assumes that a check has already been made to ensure that
2359:Libraries/FreeRTOS/Source/tasks.c **** 	pxEventList is not empty. */
2360:Libraries/FreeRTOS/Source/tasks.c **** 	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
2361:Libraries/FreeRTOS/Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
2362:Libraries/FreeRTOS/Source/tasks.c **** 	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
2363:Libraries/FreeRTOS/Source/tasks.c **** 
2364:Libraries/FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
2365:Libraries/FreeRTOS/Source/tasks.c **** 	{
2366:Libraries/FreeRTOS/Source/tasks.c **** 		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
2367:Libraries/FreeRTOS/Source/tasks.c **** 		prvAddTaskToReadyList( pxUnblockedTCB );
2368:Libraries/FreeRTOS/Source/tasks.c **** 	}
2369:Libraries/FreeRTOS/Source/tasks.c **** 	else
2370:Libraries/FreeRTOS/Source/tasks.c **** 	{
2371:Libraries/FreeRTOS/Source/tasks.c **** 		/* The delayed and ready lists cannot be accessed, so hold this task
2372:Libraries/FreeRTOS/Source/tasks.c **** 		pending until the scheduler is resumed. */
2373:Libraries/FreeRTOS/Source/tasks.c **** 		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
2374:Libraries/FreeRTOS/Source/tasks.c **** 	}
2375:Libraries/FreeRTOS/Source/tasks.c **** 
2376:Libraries/FreeRTOS/Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
2377:Libraries/FreeRTOS/Source/tasks.c **** 	{
2378:Libraries/FreeRTOS/Source/tasks.c **** 		/* Return true if the task removed from the event list has a higher
2379:Libraries/FreeRTOS/Source/tasks.c **** 		priority than the calling task.  This allows the calling task to know if
2380:Libraries/FreeRTOS/Source/tasks.c **** 		it should force a context switch now. */
2381:Libraries/FreeRTOS/Source/tasks.c **** 		xReturn = pdTRUE;
2382:Libraries/FreeRTOS/Source/tasks.c **** 
2383:Libraries/FreeRTOS/Source/tasks.c **** 		/* Mark that a yield is pending in case the user is not using the
2384:Libraries/FreeRTOS/Source/tasks.c **** 		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
2385:Libraries/FreeRTOS/Source/tasks.c **** 		xYieldPending = pdTRUE;
2386:Libraries/FreeRTOS/Source/tasks.c **** 	}
2387:Libraries/FreeRTOS/Source/tasks.c **** 	else
2388:Libraries/FreeRTOS/Source/tasks.c **** 	{
2389:Libraries/FreeRTOS/Source/tasks.c **** 		xReturn = pdFALSE;
2390:Libraries/FreeRTOS/Source/tasks.c **** 	}
2391:Libraries/FreeRTOS/Source/tasks.c **** 
2392:Libraries/FreeRTOS/Source/tasks.c **** 	return xReturn;
2393:Libraries/FreeRTOS/Source/tasks.c **** }
2394:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2395:Libraries/FreeRTOS/Source/tasks.c **** 
2396:Libraries/FreeRTOS/Source/tasks.c **** BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemV
2397:Libraries/FreeRTOS/Source/tasks.c **** {
2398:Libraries/FreeRTOS/Source/tasks.c **** TCB_t *pxUnblockedTCB;
2399:Libraries/FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
2400:Libraries/FreeRTOS/Source/tasks.c **** 
2401:Libraries/FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
2402:Libraries/FreeRTOS/Source/tasks.c **** 	the event flags implementation. */
2403:Libraries/FreeRTOS/Source/tasks.c **** 	configASSERT( uxSchedulerSuspended != pdFALSE );
2404:Libraries/FreeRTOS/Source/tasks.c **** 
2405:Libraries/FreeRTOS/Source/tasks.c **** 	/* Store the new item value in the event list. */
2406:Libraries/FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
2407:Libraries/FreeRTOS/Source/tasks.c **** 
2408:Libraries/FreeRTOS/Source/tasks.c **** 	/* Remove the event list form the event flag.  Interrupts do not access
2409:Libraries/FreeRTOS/Source/tasks.c **** 	event flags. */
2410:Libraries/FreeRTOS/Source/tasks.c **** 	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
2411:Libraries/FreeRTOS/Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
2412:Libraries/FreeRTOS/Source/tasks.c **** 	( void ) uxListRemove( pxEventListItem );
2413:Libraries/FreeRTOS/Source/tasks.c **** 
2414:Libraries/FreeRTOS/Source/tasks.c **** 	/* Remove the task from the delayed list and add it to the ready list.  The
2415:Libraries/FreeRTOS/Source/tasks.c **** 	scheduler is suspended so interrupts will not be accessing the ready
2416:Libraries/FreeRTOS/Source/tasks.c **** 	lists. */
2417:Libraries/FreeRTOS/Source/tasks.c **** 	( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
2418:Libraries/FreeRTOS/Source/tasks.c **** 	prvAddTaskToReadyList( pxUnblockedTCB );
2419:Libraries/FreeRTOS/Source/tasks.c **** 
2420:Libraries/FreeRTOS/Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
2421:Libraries/FreeRTOS/Source/tasks.c **** 	{
2422:Libraries/FreeRTOS/Source/tasks.c **** 		/* Return true if the task removed from the event list has
2423:Libraries/FreeRTOS/Source/tasks.c **** 		a higher priority than the calling task.  This allows
2424:Libraries/FreeRTOS/Source/tasks.c **** 		the calling task to know if it should force a context
2425:Libraries/FreeRTOS/Source/tasks.c **** 		switch now. */
2426:Libraries/FreeRTOS/Source/tasks.c **** 		xReturn = pdTRUE;
2427:Libraries/FreeRTOS/Source/tasks.c **** 
2428:Libraries/FreeRTOS/Source/tasks.c **** 		/* Mark that a yield is pending in case the user is not using the
2429:Libraries/FreeRTOS/Source/tasks.c **** 		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
2430:Libraries/FreeRTOS/Source/tasks.c **** 		xYieldPending = pdTRUE;
2431:Libraries/FreeRTOS/Source/tasks.c **** 	}
2432:Libraries/FreeRTOS/Source/tasks.c **** 	else
2433:Libraries/FreeRTOS/Source/tasks.c **** 	{
2434:Libraries/FreeRTOS/Source/tasks.c **** 		xReturn = pdFALSE;
2435:Libraries/FreeRTOS/Source/tasks.c **** 	}
2436:Libraries/FreeRTOS/Source/tasks.c **** 
2437:Libraries/FreeRTOS/Source/tasks.c **** 	return xReturn;
2438:Libraries/FreeRTOS/Source/tasks.c **** }
2439:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2440:Libraries/FreeRTOS/Source/tasks.c **** 
2441:Libraries/FreeRTOS/Source/tasks.c **** void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
2442:Libraries/FreeRTOS/Source/tasks.c **** {
2443:Libraries/FreeRTOS/Source/tasks.c **** 	configASSERT( pxTimeOut );
2444:Libraries/FreeRTOS/Source/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
2445:Libraries/FreeRTOS/Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
2446:Libraries/FreeRTOS/Source/tasks.c **** }
2447:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2448:Libraries/FreeRTOS/Source/tasks.c **** 
2449:Libraries/FreeRTOS/Source/tasks.c **** BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
2450:Libraries/FreeRTOS/Source/tasks.c **** {
2451:Libraries/FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
2452:Libraries/FreeRTOS/Source/tasks.c **** 
2453:Libraries/FreeRTOS/Source/tasks.c **** 	configASSERT( pxTimeOut );
2454:Libraries/FreeRTOS/Source/tasks.c **** 	configASSERT( pxTicksToWait );
2455:Libraries/FreeRTOS/Source/tasks.c **** 
2456:Libraries/FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
2457:Libraries/FreeRTOS/Source/tasks.c **** 	{
2458:Libraries/FreeRTOS/Source/tasks.c **** 		/* Minor optimisation.  The tick count cannot change in this block. */
2459:Libraries/FreeRTOS/Source/tasks.c **** 		const TickType_t xConstTickCount = xTickCount;
2460:Libraries/FreeRTOS/Source/tasks.c **** 
2461:Libraries/FreeRTOS/Source/tasks.c **** 		#if ( INCLUDE_vTaskSuspend == 1 )
2462:Libraries/FreeRTOS/Source/tasks.c **** 			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
2463:Libraries/FreeRTOS/Source/tasks.c **** 			the maximum block time then the task should block indefinitely, and
2464:Libraries/FreeRTOS/Source/tasks.c **** 			therefore never time out. */
2465:Libraries/FreeRTOS/Source/tasks.c **** 			if( *pxTicksToWait == portMAX_DELAY )
2466:Libraries/FreeRTOS/Source/tasks.c **** 			{
2467:Libraries/FreeRTOS/Source/tasks.c **** 				xReturn = pdFALSE;
2468:Libraries/FreeRTOS/Source/tasks.c **** 			}
2469:Libraries/FreeRTOS/Source/tasks.c **** 			else /* We are not blocking indefinitely, perform the checks below. */
2470:Libraries/FreeRTOS/Source/tasks.c **** 		#endif
2471:Libraries/FreeRTOS/Source/tasks.c **** 
2472:Libraries/FreeRTOS/Source/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEn
2473:Libraries/FreeRTOS/Source/tasks.c **** 		{
2474:Libraries/FreeRTOS/Source/tasks.c **** 			/* The tick count is greater than the time at which vTaskSetTimeout()
2475:Libraries/FreeRTOS/Source/tasks.c **** 			was called, but has also overflowed since vTaskSetTimeOut() was called.
2476:Libraries/FreeRTOS/Source/tasks.c **** 			It must have wrapped all the way around and gone past us again. This
2477:Libraries/FreeRTOS/Source/tasks.c **** 			passed since vTaskSetTimeout() was called. */
2478:Libraries/FreeRTOS/Source/tasks.c **** 			xReturn = pdTRUE;
2479:Libraries/FreeRTOS/Source/tasks.c **** 		}
2480:Libraries/FreeRTOS/Source/tasks.c **** 		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
2481:Libraries/FreeRTOS/Source/tasks.c **** 		{
2482:Libraries/FreeRTOS/Source/tasks.c **** 			/* Not a genuine timeout. Adjust parameters for time remaining. */
2483:Libraries/FreeRTOS/Source/tasks.c **** 			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
2484:Libraries/FreeRTOS/Source/tasks.c **** 			vTaskSetTimeOutState( pxTimeOut );
2485:Libraries/FreeRTOS/Source/tasks.c **** 			xReturn = pdFALSE;
2486:Libraries/FreeRTOS/Source/tasks.c **** 		}
2487:Libraries/FreeRTOS/Source/tasks.c **** 		else
2488:Libraries/FreeRTOS/Source/tasks.c **** 		{
2489:Libraries/FreeRTOS/Source/tasks.c **** 			xReturn = pdTRUE;
2490:Libraries/FreeRTOS/Source/tasks.c **** 		}
2491:Libraries/FreeRTOS/Source/tasks.c **** 	}
2492:Libraries/FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
2493:Libraries/FreeRTOS/Source/tasks.c **** 
2494:Libraries/FreeRTOS/Source/tasks.c **** 	return xReturn;
2495:Libraries/FreeRTOS/Source/tasks.c **** }
2496:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2497:Libraries/FreeRTOS/Source/tasks.c **** 
2498:Libraries/FreeRTOS/Source/tasks.c **** void vTaskMissedYield( void )
2499:Libraries/FreeRTOS/Source/tasks.c **** {
2500:Libraries/FreeRTOS/Source/tasks.c **** 	xYieldPending = pdTRUE;
2501:Libraries/FreeRTOS/Source/tasks.c **** }
2502:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2503:Libraries/FreeRTOS/Source/tasks.c **** 
2504:Libraries/FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2505:Libraries/FreeRTOS/Source/tasks.c **** 
2506:Libraries/FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
2507:Libraries/FreeRTOS/Source/tasks.c **** 	{
2508:Libraries/FreeRTOS/Source/tasks.c **** 	UBaseType_t uxReturn;
2509:Libraries/FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
2510:Libraries/FreeRTOS/Source/tasks.c **** 
2511:Libraries/FreeRTOS/Source/tasks.c **** 		if( xTask != NULL )
2512:Libraries/FreeRTOS/Source/tasks.c **** 		{
2513:Libraries/FreeRTOS/Source/tasks.c **** 			pxTCB = ( TCB_t * ) xTask;
2514:Libraries/FreeRTOS/Source/tasks.c **** 			uxReturn = pxTCB->uxTaskNumber;
2515:Libraries/FreeRTOS/Source/tasks.c **** 		}
2516:Libraries/FreeRTOS/Source/tasks.c **** 		else
2517:Libraries/FreeRTOS/Source/tasks.c **** 		{
2518:Libraries/FreeRTOS/Source/tasks.c **** 			uxReturn = 0U;
2519:Libraries/FreeRTOS/Source/tasks.c **** 		}
2520:Libraries/FreeRTOS/Source/tasks.c **** 
2521:Libraries/FreeRTOS/Source/tasks.c **** 		return uxReturn;
2522:Libraries/FreeRTOS/Source/tasks.c **** 	}
2523:Libraries/FreeRTOS/Source/tasks.c **** 
2524:Libraries/FreeRTOS/Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
2525:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2526:Libraries/FreeRTOS/Source/tasks.c **** 
2527:Libraries/FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2528:Libraries/FreeRTOS/Source/tasks.c **** 
2529:Libraries/FreeRTOS/Source/tasks.c **** 	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
2530:Libraries/FreeRTOS/Source/tasks.c **** 	{
2531:Libraries/FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
2532:Libraries/FreeRTOS/Source/tasks.c **** 
2533:Libraries/FreeRTOS/Source/tasks.c **** 		if( xTask != NULL )
2534:Libraries/FreeRTOS/Source/tasks.c **** 		{
2535:Libraries/FreeRTOS/Source/tasks.c **** 			pxTCB = ( TCB_t * ) xTask;
2536:Libraries/FreeRTOS/Source/tasks.c **** 			pxTCB->uxTaskNumber = uxHandle;
2537:Libraries/FreeRTOS/Source/tasks.c **** 		}
2538:Libraries/FreeRTOS/Source/tasks.c **** 	}
2539:Libraries/FreeRTOS/Source/tasks.c **** 
2540:Libraries/FreeRTOS/Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
2541:Libraries/FreeRTOS/Source/tasks.c **** 
2542:Libraries/FreeRTOS/Source/tasks.c **** /*
2543:Libraries/FreeRTOS/Source/tasks.c ****  * -----------------------------------------------------------
2544:Libraries/FreeRTOS/Source/tasks.c ****  * The Idle task.
2545:Libraries/FreeRTOS/Source/tasks.c ****  * ----------------------------------------------------------
2546:Libraries/FreeRTOS/Source/tasks.c ****  *
2547:Libraries/FreeRTOS/Source/tasks.c ****  * The portTASK_FUNCTION() macro is used to allow port/compiler specific
2548:Libraries/FreeRTOS/Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
2549:Libraries/FreeRTOS/Source/tasks.c ****  *
2550:Libraries/FreeRTOS/Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
2551:Libraries/FreeRTOS/Source/tasks.c ****  *
2552:Libraries/FreeRTOS/Source/tasks.c ****  */
2553:Libraries/FreeRTOS/Source/tasks.c **** static portTASK_FUNCTION( prvIdleTask, pvParameters )
2554:Libraries/FreeRTOS/Source/tasks.c **** {
2555:Libraries/FreeRTOS/Source/tasks.c **** 	/* Stop warnings. */
2556:Libraries/FreeRTOS/Source/tasks.c **** 	( void ) pvParameters;
2557:Libraries/FreeRTOS/Source/tasks.c **** 
2558:Libraries/FreeRTOS/Source/tasks.c **** 	for( ;; )
2559:Libraries/FreeRTOS/Source/tasks.c **** 	{
2560:Libraries/FreeRTOS/Source/tasks.c **** 		/* See if any tasks have been deleted. */
2561:Libraries/FreeRTOS/Source/tasks.c **** 		prvCheckTasksWaitingTermination();
2562:Libraries/FreeRTOS/Source/tasks.c **** 
2563:Libraries/FreeRTOS/Source/tasks.c **** 		#if ( configUSE_PREEMPTION == 0 )
2564:Libraries/FreeRTOS/Source/tasks.c **** 		{
2565:Libraries/FreeRTOS/Source/tasks.c **** 			/* If we are not using preemption we keep forcing a task switch to
2566:Libraries/FreeRTOS/Source/tasks.c **** 			see if any other task has become available.  If we are using
2567:Libraries/FreeRTOS/Source/tasks.c **** 			preemption we don't need to do this as any task becoming available
2568:Libraries/FreeRTOS/Source/tasks.c **** 			will automatically get the processor anyway. */
2569:Libraries/FreeRTOS/Source/tasks.c **** 			taskYIELD();
2570:Libraries/FreeRTOS/Source/tasks.c **** 		}
2571:Libraries/FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_PREEMPTION */
2572:Libraries/FreeRTOS/Source/tasks.c **** 
2573:Libraries/FreeRTOS/Source/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
2574:Libraries/FreeRTOS/Source/tasks.c **** 		{
2575:Libraries/FreeRTOS/Source/tasks.c **** 			/* When using preemption tasks of equal priority will be
2576:Libraries/FreeRTOS/Source/tasks.c **** 			timesliced.  If a task that is sharing the idle priority is ready
2577:Libraries/FreeRTOS/Source/tasks.c **** 			to run then the idle task should yield before the end of the
2578:Libraries/FreeRTOS/Source/tasks.c **** 			timeslice.
2579:Libraries/FreeRTOS/Source/tasks.c **** 
2580:Libraries/FreeRTOS/Source/tasks.c **** 			A critical region is not required here as we are just reading from
2581:Libraries/FreeRTOS/Source/tasks.c **** 			the list, and an occasional incorrect value will not matter.  If
2582:Libraries/FreeRTOS/Source/tasks.c **** 			the ready list at the idle priority contains more than one task
2583:Libraries/FreeRTOS/Source/tasks.c **** 			then a task other than the idle task is ready to execute. */
2584:Libraries/FreeRTOS/Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
2585:Libraries/FreeRTOS/Source/tasks.c **** 			{
2586:Libraries/FreeRTOS/Source/tasks.c **** 				taskYIELD();
2587:Libraries/FreeRTOS/Source/tasks.c **** 			}
2588:Libraries/FreeRTOS/Source/tasks.c **** 			else
2589:Libraries/FreeRTOS/Source/tasks.c **** 			{
2590:Libraries/FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2591:Libraries/FreeRTOS/Source/tasks.c **** 			}
2592:Libraries/FreeRTOS/Source/tasks.c **** 		}
2593:Libraries/FreeRTOS/Source/tasks.c **** 		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
2594:Libraries/FreeRTOS/Source/tasks.c **** 
2595:Libraries/FreeRTOS/Source/tasks.c **** 		#if ( configUSE_IDLE_HOOK == 1 )
2596:Libraries/FreeRTOS/Source/tasks.c **** 		{
2597:Libraries/FreeRTOS/Source/tasks.c **** 			extern void vApplicationIdleHook( void );
2598:Libraries/FreeRTOS/Source/tasks.c **** 
2599:Libraries/FreeRTOS/Source/tasks.c **** 			/* Call the user defined function from within the idle task.  This
2600:Libraries/FreeRTOS/Source/tasks.c **** 			allows the application designer to add background functionality
2601:Libraries/FreeRTOS/Source/tasks.c **** 			without the overhead of a separate task.
2602:Libraries/FreeRTOS/Source/tasks.c **** 			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
2603:Libraries/FreeRTOS/Source/tasks.c **** 			CALL A FUNCTION THAT MIGHT BLOCK. */
2604:Libraries/FreeRTOS/Source/tasks.c **** 			vApplicationIdleHook();
2605:Libraries/FreeRTOS/Source/tasks.c **** 		}
2606:Libraries/FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_IDLE_HOOK */
2607:Libraries/FreeRTOS/Source/tasks.c **** 
2608:Libraries/FreeRTOS/Source/tasks.c **** 		/* This conditional compilation should use inequality to 0, not equality
2609:Libraries/FreeRTOS/Source/tasks.c **** 		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
2610:Libraries/FreeRTOS/Source/tasks.c **** 		user defined low power mode	implementations require
2611:Libraries/FreeRTOS/Source/tasks.c **** 		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
2612:Libraries/FreeRTOS/Source/tasks.c **** 		#if ( configUSE_TICKLESS_IDLE != 0 )
2613:Libraries/FreeRTOS/Source/tasks.c **** 		{
2614:Libraries/FreeRTOS/Source/tasks.c **** 		TickType_t xExpectedIdleTime;
2615:Libraries/FreeRTOS/Source/tasks.c **** 
2616:Libraries/FreeRTOS/Source/tasks.c **** 			/* It is not desirable to suspend then resume the scheduler on
2617:Libraries/FreeRTOS/Source/tasks.c **** 			each iteration of the idle task.  Therefore, a preliminary
2618:Libraries/FreeRTOS/Source/tasks.c **** 			test of the expected idle time is performed without the
2619:Libraries/FreeRTOS/Source/tasks.c **** 			scheduler suspended.  The result here is not necessarily
2620:Libraries/FreeRTOS/Source/tasks.c **** 			valid. */
2621:Libraries/FreeRTOS/Source/tasks.c **** 			xExpectedIdleTime = prvGetExpectedIdleTime();
2622:Libraries/FreeRTOS/Source/tasks.c **** 
2623:Libraries/FreeRTOS/Source/tasks.c **** 			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
2624:Libraries/FreeRTOS/Source/tasks.c **** 			{
2625:Libraries/FreeRTOS/Source/tasks.c **** 				vTaskSuspendAll();
2626:Libraries/FreeRTOS/Source/tasks.c **** 				{
2627:Libraries/FreeRTOS/Source/tasks.c **** 					/* Now the scheduler is suspended, the expected idle
2628:Libraries/FreeRTOS/Source/tasks.c **** 					time can be sampled again, and this time its value can
2629:Libraries/FreeRTOS/Source/tasks.c **** 					be used. */
2630:Libraries/FreeRTOS/Source/tasks.c **** 					configASSERT( xNextTaskUnblockTime >= xTickCount );
2631:Libraries/FreeRTOS/Source/tasks.c **** 					xExpectedIdleTime = prvGetExpectedIdleTime();
2632:Libraries/FreeRTOS/Source/tasks.c **** 
2633:Libraries/FreeRTOS/Source/tasks.c **** 					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
2634:Libraries/FreeRTOS/Source/tasks.c **** 					{
2635:Libraries/FreeRTOS/Source/tasks.c **** 						traceLOW_POWER_IDLE_BEGIN();
2636:Libraries/FreeRTOS/Source/tasks.c **** 						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
2637:Libraries/FreeRTOS/Source/tasks.c **** 						traceLOW_POWER_IDLE_END();
2638:Libraries/FreeRTOS/Source/tasks.c **** 					}
2639:Libraries/FreeRTOS/Source/tasks.c **** 					else
2640:Libraries/FreeRTOS/Source/tasks.c **** 					{
2641:Libraries/FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2642:Libraries/FreeRTOS/Source/tasks.c **** 					}
2643:Libraries/FreeRTOS/Source/tasks.c **** 				}
2644:Libraries/FreeRTOS/Source/tasks.c **** 				( void ) xTaskResumeAll();
2645:Libraries/FreeRTOS/Source/tasks.c **** 			}
2646:Libraries/FreeRTOS/Source/tasks.c **** 			else
2647:Libraries/FreeRTOS/Source/tasks.c **** 			{
2648:Libraries/FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2649:Libraries/FreeRTOS/Source/tasks.c **** 			}
2650:Libraries/FreeRTOS/Source/tasks.c **** 		}
2651:Libraries/FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_TICKLESS_IDLE */
2652:Libraries/FreeRTOS/Source/tasks.c **** 	}
2653:Libraries/FreeRTOS/Source/tasks.c **** }
2654:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2655:Libraries/FreeRTOS/Source/tasks.c **** 
2656:Libraries/FreeRTOS/Source/tasks.c **** #if configUSE_TICKLESS_IDLE != 0
2657:Libraries/FreeRTOS/Source/tasks.c **** 
2658:Libraries/FreeRTOS/Source/tasks.c **** 	eSleepModeStatus eTaskConfirmSleepModeStatus( void )
2659:Libraries/FreeRTOS/Source/tasks.c **** 	{
2660:Libraries/FreeRTOS/Source/tasks.c **** 	eSleepModeStatus eReturn = eStandardSleep;
2661:Libraries/FreeRTOS/Source/tasks.c **** 
2662:Libraries/FreeRTOS/Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
2663:Libraries/FreeRTOS/Source/tasks.c **** 		{
2664:Libraries/FreeRTOS/Source/tasks.c **** 			/* A task was made ready while the scheduler was suspended. */
2665:Libraries/FreeRTOS/Source/tasks.c **** 			eReturn = eAbortSleep;
2666:Libraries/FreeRTOS/Source/tasks.c **** 		}
2667:Libraries/FreeRTOS/Source/tasks.c **** 		else if( xYieldPending != pdFALSE )
2668:Libraries/FreeRTOS/Source/tasks.c **** 		{
2669:Libraries/FreeRTOS/Source/tasks.c **** 			/* A yield was pended while the scheduler was suspended. */
2670:Libraries/FreeRTOS/Source/tasks.c **** 			eReturn = eAbortSleep;
2671:Libraries/FreeRTOS/Source/tasks.c **** 		}
2672:Libraries/FreeRTOS/Source/tasks.c **** 		else
2673:Libraries/FreeRTOS/Source/tasks.c **** 		{
2674:Libraries/FreeRTOS/Source/tasks.c **** 			#if configUSE_TIMERS == 0
2675:Libraries/FreeRTOS/Source/tasks.c **** 			{
2676:Libraries/FreeRTOS/Source/tasks.c **** 				/* The idle task exists in addition to the application tasks. */
2677:Libraries/FreeRTOS/Source/tasks.c **** 				const UBaseType_t uxNonApplicationTasks = 1;
2678:Libraries/FreeRTOS/Source/tasks.c **** 
2679:Libraries/FreeRTOS/Source/tasks.c **** 				/* If timers are not being used and all the tasks are in the
2680:Libraries/FreeRTOS/Source/tasks.c **** 				suspended list (which might mean they have an infinite block
2681:Libraries/FreeRTOS/Source/tasks.c **** 				time rather than actually being suspended) then it is safe to
2682:Libraries/FreeRTOS/Source/tasks.c **** 				turn all clocks off and just wait for external interrupts. */
2683:Libraries/FreeRTOS/Source/tasks.c **** 				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicati
2684:Libraries/FreeRTOS/Source/tasks.c **** 				{
2685:Libraries/FreeRTOS/Source/tasks.c **** 					eReturn = eNoTasksWaitingTimeout;
2686:Libraries/FreeRTOS/Source/tasks.c **** 				}
2687:Libraries/FreeRTOS/Source/tasks.c **** 				else
2688:Libraries/FreeRTOS/Source/tasks.c **** 				{
2689:Libraries/FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
2690:Libraries/FreeRTOS/Source/tasks.c **** 				}
2691:Libraries/FreeRTOS/Source/tasks.c **** 			}
2692:Libraries/FreeRTOS/Source/tasks.c **** 			#endif /* configUSE_TIMERS */
2693:Libraries/FreeRTOS/Source/tasks.c **** 		}
2694:Libraries/FreeRTOS/Source/tasks.c **** 
2695:Libraries/FreeRTOS/Source/tasks.c **** 		return eReturn;
2696:Libraries/FreeRTOS/Source/tasks.c **** 	}
2697:Libraries/FreeRTOS/Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
2698:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2699:Libraries/FreeRTOS/Source/tasks.c **** 
2700:Libraries/FreeRTOS/Source/tasks.c **** static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t 
2701:Libraries/FreeRTOS/Source/tasks.c **** {
2702:Libraries/FreeRTOS/Source/tasks.c **** UBaseType_t x;
2703:Libraries/FreeRTOS/Source/tasks.c **** 
2704:Libraries/FreeRTOS/Source/tasks.c **** 	/* Store the task name in the TCB. */
2705:Libraries/FreeRTOS/Source/tasks.c **** 	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
2706:Libraries/FreeRTOS/Source/tasks.c **** 	{
2707:Libraries/FreeRTOS/Source/tasks.c **** 		pxTCB->pcTaskName[ x ] = pcName[ x ];
2708:Libraries/FreeRTOS/Source/tasks.c **** 
2709:Libraries/FreeRTOS/Source/tasks.c **** 		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
2710:Libraries/FreeRTOS/Source/tasks.c **** 		configMAX_TASK_NAME_LEN characters just in case the memory after the
2711:Libraries/FreeRTOS/Source/tasks.c **** 		string is not accessible (extremely unlikely). */
2712:Libraries/FreeRTOS/Source/tasks.c **** 		if( pcName[ x ] == 0x00 )
2713:Libraries/FreeRTOS/Source/tasks.c **** 		{
2714:Libraries/FreeRTOS/Source/tasks.c **** 			break;
2715:Libraries/FreeRTOS/Source/tasks.c **** 		}
2716:Libraries/FreeRTOS/Source/tasks.c **** 		else
2717:Libraries/FreeRTOS/Source/tasks.c **** 		{
2718:Libraries/FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2719:Libraries/FreeRTOS/Source/tasks.c **** 		}
2720:Libraries/FreeRTOS/Source/tasks.c **** 	}
2721:Libraries/FreeRTOS/Source/tasks.c **** 
2722:Libraries/FreeRTOS/Source/tasks.c **** 	/* Ensure the name string is terminated in the case that the string length
2723:Libraries/FreeRTOS/Source/tasks.c **** 	was greater or equal to configMAX_TASK_NAME_LEN. */
2724:Libraries/FreeRTOS/Source/tasks.c **** 	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
2725:Libraries/FreeRTOS/Source/tasks.c **** 
2726:Libraries/FreeRTOS/Source/tasks.c **** 	/* This is used as an array index so must ensure it's not too large.  First
2727:Libraries/FreeRTOS/Source/tasks.c **** 	remove the privilege bit if one is present. */
2728:Libraries/FreeRTOS/Source/tasks.c **** 	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
2729:Libraries/FreeRTOS/Source/tasks.c **** 	{
2730:Libraries/FreeRTOS/Source/tasks.c **** 		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
2731:Libraries/FreeRTOS/Source/tasks.c **** 	}
2732:Libraries/FreeRTOS/Source/tasks.c **** 	else
2733:Libraries/FreeRTOS/Source/tasks.c **** 	{
2734:Libraries/FreeRTOS/Source/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
2735:Libraries/FreeRTOS/Source/tasks.c **** 	}
2736:Libraries/FreeRTOS/Source/tasks.c **** 
2737:Libraries/FreeRTOS/Source/tasks.c **** 	pxTCB->uxPriority = uxPriority;
2738:Libraries/FreeRTOS/Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
2739:Libraries/FreeRTOS/Source/tasks.c **** 	{
2740:Libraries/FreeRTOS/Source/tasks.c **** 		pxTCB->uxBasePriority = uxPriority;
2741:Libraries/FreeRTOS/Source/tasks.c **** 	}
2742:Libraries/FreeRTOS/Source/tasks.c **** 	#endif /* configUSE_MUTEXES */
2743:Libraries/FreeRTOS/Source/tasks.c **** 
2744:Libraries/FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
2745:Libraries/FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
2746:Libraries/FreeRTOS/Source/tasks.c **** 
2747:Libraries/FreeRTOS/Source/tasks.c **** 	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
2748:Libraries/FreeRTOS/Source/tasks.c **** 	back to	the containing TCB from a generic item in a list. */
2749:Libraries/FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
2750:Libraries/FreeRTOS/Source/tasks.c **** 
2751:Libraries/FreeRTOS/Source/tasks.c **** 	/* Event lists are always in priority order. */
2752:Libraries/FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickT
2753:Libraries/FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
2754:Libraries/FreeRTOS/Source/tasks.c **** 
2755:Libraries/FreeRTOS/Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
2756:Libraries/FreeRTOS/Source/tasks.c **** 	{
2757:Libraries/FreeRTOS/Source/tasks.c **** 		pxTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
2758:Libraries/FreeRTOS/Source/tasks.c **** 	}
2759:Libraries/FreeRTOS/Source/tasks.c **** 	#endif /* portCRITICAL_NESTING_IN_TCB */
2760:Libraries/FreeRTOS/Source/tasks.c **** 
2761:Libraries/FreeRTOS/Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
2762:Libraries/FreeRTOS/Source/tasks.c **** 	{
2763:Libraries/FreeRTOS/Source/tasks.c **** 		pxTCB->pxTaskTag = NULL;
2764:Libraries/FreeRTOS/Source/tasks.c **** 	}
2765:Libraries/FreeRTOS/Source/tasks.c **** 	#endif /* configUSE_APPLICATION_TASK_TAG */
2766:Libraries/FreeRTOS/Source/tasks.c **** 
2767:Libraries/FreeRTOS/Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
2768:Libraries/FreeRTOS/Source/tasks.c **** 	{
2769:Libraries/FreeRTOS/Source/tasks.c **** 		pxTCB->ulRunTimeCounter = 0UL;
2770:Libraries/FreeRTOS/Source/tasks.c **** 	}
2771:Libraries/FreeRTOS/Source/tasks.c **** 	#endif /* configGENERATE_RUN_TIME_STATS */
2772:Libraries/FreeRTOS/Source/tasks.c **** 
2773:Libraries/FreeRTOS/Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
2774:Libraries/FreeRTOS/Source/tasks.c **** 	{
2775:Libraries/FreeRTOS/Source/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );
2776:Libraries/FreeRTOS/Source/tasks.c **** 	}
2777:Libraries/FreeRTOS/Source/tasks.c **** 	#else /* portUSING_MPU_WRAPPERS */
2778:Libraries/FreeRTOS/Source/tasks.c **** 	{
2779:Libraries/FreeRTOS/Source/tasks.c **** 		( void ) xRegions;
2780:Libraries/FreeRTOS/Source/tasks.c **** 		( void ) usStackDepth;
2781:Libraries/FreeRTOS/Source/tasks.c **** 	}
2782:Libraries/FreeRTOS/Source/tasks.c **** 	#endif /* portUSING_MPU_WRAPPERS */
2783:Libraries/FreeRTOS/Source/tasks.c **** 
2784:Libraries/FreeRTOS/Source/tasks.c **** 	#if ( configUSE_NEWLIB_REENTRANT == 1 )
2785:Libraries/FreeRTOS/Source/tasks.c **** 	{
2786:Libraries/FreeRTOS/Source/tasks.c **** 		/* Initialise this task's Newlib reent structure. */
2787:Libraries/FreeRTOS/Source/tasks.c **** 		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
2788:Libraries/FreeRTOS/Source/tasks.c **** 	}
2789:Libraries/FreeRTOS/Source/tasks.c **** 	#endif /* configUSE_NEWLIB_REENTRANT */
2790:Libraries/FreeRTOS/Source/tasks.c **** }
2791:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2792:Libraries/FreeRTOS/Source/tasks.c **** 
2793:Libraries/FreeRTOS/Source/tasks.c **** #if ( portUSING_MPU_WRAPPERS == 1 )
2794:Libraries/FreeRTOS/Source/tasks.c **** 
2795:Libraries/FreeRTOS/Source/tasks.c **** 	void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify, const MemoryRegion_t * const xRegions )
2796:Libraries/FreeRTOS/Source/tasks.c **** 	{
2797:Libraries/FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
2798:Libraries/FreeRTOS/Source/tasks.c **** 
2799:Libraries/FreeRTOS/Source/tasks.c **** 		/* If null is passed in here then we are deleting ourselves. */
2800:Libraries/FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToModify );
2801:Libraries/FreeRTOS/Source/tasks.c **** 
2802:Libraries/FreeRTOS/Source/tasks.c ****         vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
2803:Libraries/FreeRTOS/Source/tasks.c **** 	}
2804:Libraries/FreeRTOS/Source/tasks.c **** 
2805:Libraries/FreeRTOS/Source/tasks.c **** #endif /* portUSING_MPU_WRAPPERS */
2806:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2807:Libraries/FreeRTOS/Source/tasks.c **** 
2808:Libraries/FreeRTOS/Source/tasks.c **** static void prvInitialiseTaskLists( void )
2809:Libraries/FreeRTOS/Source/tasks.c **** {
  28              		.loc 1 2809 0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 0
  31              		@ frame_needed = 0, uses_anonymous_args = 0
  32              	.LVL0:
  33 0000 38B5     		push	{r3, r4, r5, lr}
  34              	.LCFI0:
  35              		.cfi_def_cfa_offset 16
  36              		.cfi_offset 3, -16
  37              		.cfi_offset 4, -12
  38              		.cfi_offset 5, -8
  39              		.cfi_offset 14, -4
  40 0002 40F20005 		movw	r5, #:lower16:.LANCHOR0
  41 0006 C0F20005 		movt	r5, #:upper16:.LANCHOR0
  42              		.loc 1 2809 0
  43 000a 0024     		movs	r4, #0
  44              	.LVL1:
  45              	.L3:
2810:Libraries/FreeRTOS/Source/tasks.c **** UBaseType_t uxPriority;
2811:Libraries/FreeRTOS/Source/tasks.c **** 
2812:Libraries/FreeRTOS/Source/tasks.c **** 	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriorit
2813:Libraries/FreeRTOS/Source/tasks.c **** 	{
2814:Libraries/FreeRTOS/Source/tasks.c **** 		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
  46              		.loc 1 2814 0 discriminator 2
  47 000c 2819     		adds	r0, r5, r4
  48 000e 1434     		adds	r4, r4, #20
  49 0010 FFF7FEFF 		bl	vListInitialise
  50              	.LVL2:
2812:Libraries/FreeRTOS/Source/tasks.c **** 	{
  51              		.loc 1 2812 0 discriminator 2
  52 0014 642C     		cmp	r4, #100
  53 0016 F9D1     		bne	.L3
2815:Libraries/FreeRTOS/Source/tasks.c **** 	}
2816:Libraries/FreeRTOS/Source/tasks.c **** 
2817:Libraries/FreeRTOS/Source/tasks.c **** 	vListInitialise( &xDelayedTaskList1 );
  54              		.loc 1 2817 0
  55 0018 40F20005 		movw	r5, #:lower16:.LANCHOR1
  56 001c C0F20005 		movt	r5, #:upper16:.LANCHOR1
2818:Libraries/FreeRTOS/Source/tasks.c **** 	vListInitialise( &xDelayedTaskList2 );
  57              		.loc 1 2818 0
  58 0020 40F20004 		movw	r4, #:lower16:.LANCHOR2
2817:Libraries/FreeRTOS/Source/tasks.c **** 	vListInitialise( &xDelayedTaskList2 );
  59              		.loc 1 2817 0
  60 0024 2846     		mov	r0, r5
  61              		.loc 1 2818 0
  62 0026 C0F20004 		movt	r4, #:upper16:.LANCHOR2
2817:Libraries/FreeRTOS/Source/tasks.c **** 	vListInitialise( &xDelayedTaskList2 );
  63              		.loc 1 2817 0
  64 002a FFF7FEFF 		bl	vListInitialise
  65              	.LVL3:
  66              		.loc 1 2818 0
  67 002e 2046     		mov	r0, r4
  68 0030 FFF7FEFF 		bl	vListInitialise
  69              	.LVL4:
2819:Libraries/FreeRTOS/Source/tasks.c **** 	vListInitialise( &xPendingReadyList );
  70              		.loc 1 2819 0
  71 0034 40F20000 		movw	r0, #:lower16:.LANCHOR3
  72 0038 C0F20000 		movt	r0, #:upper16:.LANCHOR3
  73 003c FFF7FEFF 		bl	vListInitialise
  74              	.LVL5:
2820:Libraries/FreeRTOS/Source/tasks.c **** 
2821:Libraries/FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
2822:Libraries/FreeRTOS/Source/tasks.c **** 	{
2823:Libraries/FreeRTOS/Source/tasks.c **** 		vListInitialise( &xTasksWaitingTermination );
  75              		.loc 1 2823 0
  76 0040 40F20000 		movw	r0, #:lower16:.LANCHOR4
  77 0044 C0F20000 		movt	r0, #:upper16:.LANCHOR4
  78 0048 FFF7FEFF 		bl	vListInitialise
  79              	.LVL6:
2824:Libraries/FreeRTOS/Source/tasks.c **** 	}
2825:Libraries/FreeRTOS/Source/tasks.c **** 	#endif /* INCLUDE_vTaskDelete */
2826:Libraries/FreeRTOS/Source/tasks.c **** 
2827:Libraries/FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
2828:Libraries/FreeRTOS/Source/tasks.c **** 	{
2829:Libraries/FreeRTOS/Source/tasks.c **** 		vListInitialise( &xSuspendedTaskList );
  80              		.loc 1 2829 0
  81 004c 40F20000 		movw	r0, #:lower16:.LANCHOR5
  82 0050 C0F20000 		movt	r0, #:upper16:.LANCHOR5
  83 0054 FFF7FEFF 		bl	vListInitialise
  84              	.LVL7:
2830:Libraries/FreeRTOS/Source/tasks.c **** 	}
2831:Libraries/FreeRTOS/Source/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
2832:Libraries/FreeRTOS/Source/tasks.c **** 
2833:Libraries/FreeRTOS/Source/tasks.c **** 	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
2834:Libraries/FreeRTOS/Source/tasks.c **** 	using list2. */
2835:Libraries/FreeRTOS/Source/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
  85              		.loc 1 2835 0
  86 0058 40F20002 		movw	r2, #:lower16:.LANCHOR6
2836:Libraries/FreeRTOS/Source/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
  87              		.loc 1 2836 0
  88 005c 40F20003 		movw	r3, #:lower16:.LANCHOR7
2835:Libraries/FreeRTOS/Source/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
  89              		.loc 1 2835 0
  90 0060 C0F20002 		movt	r2, #:upper16:.LANCHOR6
  91              		.loc 1 2836 0
  92 0064 C0F20003 		movt	r3, #:upper16:.LANCHOR7
2835:Libraries/FreeRTOS/Source/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
  93              		.loc 1 2835 0
  94 0068 1560     		str	r5, [r2]
  95              		.loc 1 2836 0
  96 006a 1C60     		str	r4, [r3]
  97 006c 38BD     		pop	{r3, r4, r5, pc}
  98              		.cfi_endproc
  99              	.LFE152:
 101 006e 00BF     		.section	.text.xTaskGenericCreate,"ax",%progbits
 102              		.align	2
 103              		.global	xTaskGenericCreate
 104              		.thumb
 105              		.thumb_func
 107              	xTaskGenericCreate:
 108              	.LFB123:
 517:Libraries/FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
 109              		.loc 1 517 0
 110              		.cfi_startproc
 111              		@ args = 16, pretend = 0, frame = 0
 112              		@ frame_needed = 0, uses_anonymous_args = 0
 113              	.LVL8:
 114 0000 2DE9F84F 		push	{r3, r4, r5, r6, r7, r8, r9, r10, fp, lr}
 115              	.LCFI1:
 116              		.cfi_def_cfa_offset 40
 117              		.cfi_offset 3, -40
 118              		.cfi_offset 4, -36
 119              		.cfi_offset 5, -32
 120              		.cfi_offset 6, -28
 121              		.cfi_offset 7, -24
 122              		.cfi_offset 8, -20
 123              		.cfi_offset 9, -16
 124              		.cfi_offset 10, -12
 125              		.cfi_offset 11, -8
 126              		.cfi_offset 14, -4
 517:Libraries/FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
 127              		.loc 1 517 0
 128 0004 0A9F     		ldr	r7, [sp, #40]
 129 0006 DDF82CA0 		ldr	r10, [sp, #44]
 130 000a 0C9E     		ldr	r6, [sp, #48]
 521:Libraries/FreeRTOS/Source/tasks.c **** 	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );
 131              		.loc 1 521 0
 132 000c 8146     		mov	r9, r0
 517:Libraries/FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
 133              		.loc 1 517 0
 134 000e 0D46     		mov	r5, r1
 135 0010 9046     		mov	r8, r2
 136 0012 9B46     		mov	fp, r3
 521:Libraries/FreeRTOS/Source/tasks.c **** 	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );
 137              		.loc 1 521 0
 138 0014 0028     		cmp	r0, #0
 139 0016 00F0C580 		beq	.L74
 522:Libraries/FreeRTOS/Source/tasks.c **** 
 140              		.loc 1 522 0
 141 001a 042F     		cmp	r7, #4
 142 001c 02D9     		bls	.L8
 522:Libraries/FreeRTOS/Source/tasks.c **** 
 143              		.loc 1 522 0 is_stmt 0 discriminator 1
 144 001e FFF7FEFF 		bl	ulPortSetInterruptMask
 145              	.LVL9:
 146              	.L9:
 147 0022 FEE7     		b	.L9
 148              	.LVL10:
 149              	.L8:
 150              	.LBB22:
 151              	.LBB23:
2837:Libraries/FreeRTOS/Source/tasks.c **** }
2838:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2839:Libraries/FreeRTOS/Source/tasks.c **** 
2840:Libraries/FreeRTOS/Source/tasks.c **** static void prvCheckTasksWaitingTermination( void )
2841:Libraries/FreeRTOS/Source/tasks.c **** {
2842:Libraries/FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
2843:Libraries/FreeRTOS/Source/tasks.c **** 	{
2844:Libraries/FreeRTOS/Source/tasks.c **** 		BaseType_t xListIsEmpty;
2845:Libraries/FreeRTOS/Source/tasks.c **** 
2846:Libraries/FreeRTOS/Source/tasks.c **** 		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
2847:Libraries/FreeRTOS/Source/tasks.c **** 		too often in the idle task. */
2848:Libraries/FreeRTOS/Source/tasks.c **** 		while( uxTasksDeleted > ( UBaseType_t ) 0U )
2849:Libraries/FreeRTOS/Source/tasks.c **** 		{
2850:Libraries/FreeRTOS/Source/tasks.c **** 			vTaskSuspendAll();
2851:Libraries/FreeRTOS/Source/tasks.c **** 			{
2852:Libraries/FreeRTOS/Source/tasks.c **** 				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
2853:Libraries/FreeRTOS/Source/tasks.c **** 			}
2854:Libraries/FreeRTOS/Source/tasks.c **** 			( void ) xTaskResumeAll();
2855:Libraries/FreeRTOS/Source/tasks.c **** 
2856:Libraries/FreeRTOS/Source/tasks.c **** 			if( xListIsEmpty == pdFALSE )
2857:Libraries/FreeRTOS/Source/tasks.c **** 			{
2858:Libraries/FreeRTOS/Source/tasks.c **** 				TCB_t *pxTCB;
2859:Libraries/FreeRTOS/Source/tasks.c **** 
2860:Libraries/FreeRTOS/Source/tasks.c **** 				taskENTER_CRITICAL();
2861:Libraries/FreeRTOS/Source/tasks.c **** 				{
2862:Libraries/FreeRTOS/Source/tasks.c **** 					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
2863:Libraries/FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
2864:Libraries/FreeRTOS/Source/tasks.c **** 					--uxCurrentNumberOfTasks;
2865:Libraries/FreeRTOS/Source/tasks.c **** 					--uxTasksDeleted;
2866:Libraries/FreeRTOS/Source/tasks.c **** 				}
2867:Libraries/FreeRTOS/Source/tasks.c **** 				taskEXIT_CRITICAL();
2868:Libraries/FreeRTOS/Source/tasks.c **** 
2869:Libraries/FreeRTOS/Source/tasks.c **** 				prvDeleteTCB( pxTCB );
2870:Libraries/FreeRTOS/Source/tasks.c **** 			}
2871:Libraries/FreeRTOS/Source/tasks.c **** 			else
2872:Libraries/FreeRTOS/Source/tasks.c **** 			{
2873:Libraries/FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2874:Libraries/FreeRTOS/Source/tasks.c **** 			}
2875:Libraries/FreeRTOS/Source/tasks.c **** 		}
2876:Libraries/FreeRTOS/Source/tasks.c **** 	}
2877:Libraries/FreeRTOS/Source/tasks.c **** 	#endif /* vTaskDelete */
2878:Libraries/FreeRTOS/Source/tasks.c **** }
2879:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2880:Libraries/FreeRTOS/Source/tasks.c **** 
2881:Libraries/FreeRTOS/Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
2882:Libraries/FreeRTOS/Source/tasks.c **** {
2883:Libraries/FreeRTOS/Source/tasks.c **** 	/* The list item will be inserted in wake time order. */
2884:Libraries/FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
2885:Libraries/FreeRTOS/Source/tasks.c **** 
2886:Libraries/FreeRTOS/Source/tasks.c **** 	if( xTimeToWake < xTickCount )
2887:Libraries/FreeRTOS/Source/tasks.c **** 	{
2888:Libraries/FreeRTOS/Source/tasks.c **** 		/* Wake time has overflowed.  Place this item in the overflow list. */
2889:Libraries/FreeRTOS/Source/tasks.c **** 		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
2890:Libraries/FreeRTOS/Source/tasks.c **** 	}
2891:Libraries/FreeRTOS/Source/tasks.c **** 	else
2892:Libraries/FreeRTOS/Source/tasks.c **** 	{
2893:Libraries/FreeRTOS/Source/tasks.c **** 		/* The wake time has not overflowed, so the current block list is used. */
2894:Libraries/FreeRTOS/Source/tasks.c **** 		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
2895:Libraries/FreeRTOS/Source/tasks.c **** 
2896:Libraries/FreeRTOS/Source/tasks.c **** 		/* If the task entering the blocked state was placed at the head of the
2897:Libraries/FreeRTOS/Source/tasks.c **** 		list of blocked tasks then xNextTaskUnblockTime needs to be updated
2898:Libraries/FreeRTOS/Source/tasks.c **** 		too. */
2899:Libraries/FreeRTOS/Source/tasks.c **** 		if( xTimeToWake < xNextTaskUnblockTime )
2900:Libraries/FreeRTOS/Source/tasks.c **** 		{
2901:Libraries/FreeRTOS/Source/tasks.c **** 			xNextTaskUnblockTime = xTimeToWake;
2902:Libraries/FreeRTOS/Source/tasks.c **** 		}
2903:Libraries/FreeRTOS/Source/tasks.c **** 		else
2904:Libraries/FreeRTOS/Source/tasks.c **** 		{
2905:Libraries/FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2906:Libraries/FreeRTOS/Source/tasks.c **** 		}
2907:Libraries/FreeRTOS/Source/tasks.c **** 	}
2908:Libraries/FreeRTOS/Source/tasks.c **** }
2909:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2910:Libraries/FreeRTOS/Source/tasks.c **** 
2911:Libraries/FreeRTOS/Source/tasks.c **** static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuff
2912:Libraries/FreeRTOS/Source/tasks.c **** {
2913:Libraries/FreeRTOS/Source/tasks.c **** TCB_t *pxNewTCB;
2914:Libraries/FreeRTOS/Source/tasks.c **** 
2915:Libraries/FreeRTOS/Source/tasks.c **** 	/* Allocate space for the TCB.  Where the memory comes from depends on
2916:Libraries/FreeRTOS/Source/tasks.c **** 	the implementation of the port malloc function. */
2917:Libraries/FreeRTOS/Source/tasks.c **** 	pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 152              		.loc 1 2917 0 is_stmt 1
 153 0024 4820     		movs	r0, #72
 154              	.LVL11:
 155 0026 FFF7FEFF 		bl	pvPortMalloc
 156              	.LVL12:
2918:Libraries/FreeRTOS/Source/tasks.c **** 
2919:Libraries/FreeRTOS/Source/tasks.c **** 	if( pxNewTCB != NULL )
 157              		.loc 1 2919 0
 158 002a 0446     		mov	r4, r0
 159 002c 0028     		cmp	r0, #0
 160 002e 00F0D780 		beq	.L10
2920:Libraries/FreeRTOS/Source/tasks.c **** 	{
2921:Libraries/FreeRTOS/Source/tasks.c **** 		/* Allocate space for the stack used by the task being created.
2922:Libraries/FreeRTOS/Source/tasks.c **** 		The base of the stack memory stored in the TCB so the task can
2923:Libraries/FreeRTOS/Source/tasks.c **** 		be deleted later if required. */
2924:Libraries/FreeRTOS/Source/tasks.c **** 		pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof
 161              		.loc 1 2924 0
 162 0032 002E     		cmp	r6, #0
 163 0034 00F0C980 		beq	.L75
 164 0038 0663     		str	r6, [r0, #48]
 165 003a 3046     		mov	r0, r6
 166              	.LVL13:
 167              	.L12:
 168              	.LBE23:
 169              	.LBE22:
 170              	.LBB25:
 171              	.LBB26:
 172              	.LBB27:
2707:Libraries/FreeRTOS/Source/tasks.c **** 
 173              		.loc 1 2707 0
 174 003c 2A78     		ldrb	r2, [r5]	@ zero_extendqisi2
 175              	.LBE27:
 176              	.LBE26:
 552:Libraries/FreeRTOS/Source/tasks.c **** 			pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINTER_
 177              		.loc 1 552 0
 178 003e 08F18043 		add	r3, r8, #1073741824
 179              	.LBB32:
 180              	.LBB28:
2707:Libraries/FreeRTOS/Source/tasks.c **** 
 181              		.loc 1 2707 0
 182 0042 84F83420 		strb	r2, [r4, #52]
 183              	.LBE28:
 184              	.LBE32:
 552:Libraries/FreeRTOS/Source/tasks.c **** 			pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINTER_
 185              		.loc 1 552 0
 186 0046 013B     		subs	r3, r3, #1
 187              	.LBB33:
 188              	.LBB29:
2712:Libraries/FreeRTOS/Source/tasks.c **** 		{
 189              		.loc 1 2712 0
 190 0048 2A78     		ldrb	r2, [r5]	@ zero_extendqisi2
 191              	.LBE29:
 192              	.LBE33:
 552:Libraries/FreeRTOS/Source/tasks.c **** 			pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINTER_
 193              		.loc 1 552 0
 194 004a 00EB8303 		add	r3, r0, r3, lsl #2
 553:Libraries/FreeRTOS/Source/tasks.c **** 
 195              		.loc 1 553 0
 196 004e 23F00706 		bic	r6, r3, #7
 197              	.LVL14:
 198              	.LBB34:
 199              	.LBB30:
2712:Libraries/FreeRTOS/Source/tasks.c **** 		{
 200              		.loc 1 2712 0
 201 0052 002A     		cmp	r2, #0
 202 0054 47D0     		beq	.L20
 203              	.LVL15:
2707:Libraries/FreeRTOS/Source/tasks.c **** 
 204              		.loc 1 2707 0
 205 0056 6B78     		ldrb	r3, [r5, #1]	@ zero_extendqisi2
 206 0058 84F83530 		strb	r3, [r4, #53]
2712:Libraries/FreeRTOS/Source/tasks.c **** 		{
 207              		.loc 1 2712 0
 208 005c 6B78     		ldrb	r3, [r5, #1]	@ zero_extendqisi2
 209 005e 002B     		cmp	r3, #0
 210 0060 41D0     		beq	.L20
 211              	.LVL16:
2707:Libraries/FreeRTOS/Source/tasks.c **** 
 212              		.loc 1 2707 0
 213 0062 AB78     		ldrb	r3, [r5, #2]	@ zero_extendqisi2
 214 0064 84F83630 		strb	r3, [r4, #54]
2712:Libraries/FreeRTOS/Source/tasks.c **** 		{
 215              		.loc 1 2712 0
 216 0068 AB78     		ldrb	r3, [r5, #2]	@ zero_extendqisi2
 217 006a 002B     		cmp	r3, #0
 218 006c 3BD0     		beq	.L20
 219              	.LVL17:
2707:Libraries/FreeRTOS/Source/tasks.c **** 
 220              		.loc 1 2707 0
 221 006e EB78     		ldrb	r3, [r5, #3]	@ zero_extendqisi2
 222 0070 84F83730 		strb	r3, [r4, #55]
2712:Libraries/FreeRTOS/Source/tasks.c **** 		{
 223              		.loc 1 2712 0
 224 0074 EB78     		ldrb	r3, [r5, #3]	@ zero_extendqisi2
 225 0076 002B     		cmp	r3, #0
 226 0078 35D0     		beq	.L20
 227              	.LVL18:
2707:Libraries/FreeRTOS/Source/tasks.c **** 
 228              		.loc 1 2707 0
 229 007a 2B79     		ldrb	r3, [r5, #4]	@ zero_extendqisi2
 230 007c 84F83830 		strb	r3, [r4, #56]
2712:Libraries/FreeRTOS/Source/tasks.c **** 		{
 231              		.loc 1 2712 0
 232 0080 2B79     		ldrb	r3, [r5, #4]	@ zero_extendqisi2
 233 0082 002B     		cmp	r3, #0
 234 0084 2FD0     		beq	.L20
 235              	.LVL19:
2707:Libraries/FreeRTOS/Source/tasks.c **** 
 236              		.loc 1 2707 0
 237 0086 6B79     		ldrb	r3, [r5, #5]	@ zero_extendqisi2
 238 0088 84F83930 		strb	r3, [r4, #57]
2712:Libraries/FreeRTOS/Source/tasks.c **** 		{
 239              		.loc 1 2712 0
 240 008c 6B79     		ldrb	r3, [r5, #5]	@ zero_extendqisi2
 241 008e 53B3     		cbz	r3, .L20
 242              	.LVL20:
2707:Libraries/FreeRTOS/Source/tasks.c **** 
 243              		.loc 1 2707 0
 244 0090 AB79     		ldrb	r3, [r5, #6]	@ zero_extendqisi2
 245 0092 84F83A30 		strb	r3, [r4, #58]
2712:Libraries/FreeRTOS/Source/tasks.c **** 		{
 246              		.loc 1 2712 0
 247 0096 AB79     		ldrb	r3, [r5, #6]	@ zero_extendqisi2
 248 0098 2BB3     		cbz	r3, .L20
 249              	.LVL21:
2707:Libraries/FreeRTOS/Source/tasks.c **** 
 250              		.loc 1 2707 0
 251 009a EB79     		ldrb	r3, [r5, #7]	@ zero_extendqisi2
 252 009c 84F83B30 		strb	r3, [r4, #59]
2712:Libraries/FreeRTOS/Source/tasks.c **** 		{
 253              		.loc 1 2712 0
 254 00a0 EB79     		ldrb	r3, [r5, #7]	@ zero_extendqisi2
 255 00a2 03B3     		cbz	r3, .L20
 256              	.LVL22:
2707:Libraries/FreeRTOS/Source/tasks.c **** 
 257              		.loc 1 2707 0
 258 00a4 2B7A     		ldrb	r3, [r5, #8]	@ zero_extendqisi2
 259 00a6 84F83C30 		strb	r3, [r4, #60]
2712:Libraries/FreeRTOS/Source/tasks.c **** 		{
 260              		.loc 1 2712 0
 261 00aa 2B7A     		ldrb	r3, [r5, #8]	@ zero_extendqisi2
 262 00ac DBB1     		cbz	r3, .L20
 263              	.LVL23:
2707:Libraries/FreeRTOS/Source/tasks.c **** 
 264              		.loc 1 2707 0
 265 00ae 6B7A     		ldrb	r3, [r5, #9]	@ zero_extendqisi2
 266 00b0 84F83D30 		strb	r3, [r4, #61]
2712:Libraries/FreeRTOS/Source/tasks.c **** 		{
 267              		.loc 1 2712 0
 268 00b4 6B7A     		ldrb	r3, [r5, #9]	@ zero_extendqisi2
 269 00b6 B3B1     		cbz	r3, .L20
 270              	.LVL24:
2707:Libraries/FreeRTOS/Source/tasks.c **** 
 271              		.loc 1 2707 0
 272 00b8 AB7A     		ldrb	r3, [r5, #10]	@ zero_extendqisi2
 273 00ba 84F83E30 		strb	r3, [r4, #62]
2712:Libraries/FreeRTOS/Source/tasks.c **** 		{
 274              		.loc 1 2712 0
 275 00be AB7A     		ldrb	r3, [r5, #10]	@ zero_extendqisi2
 276 00c0 8BB1     		cbz	r3, .L20
 277              	.LVL25:
2707:Libraries/FreeRTOS/Source/tasks.c **** 
 278              		.loc 1 2707 0
 279 00c2 EB7A     		ldrb	r3, [r5, #11]	@ zero_extendqisi2
 280 00c4 84F83F30 		strb	r3, [r4, #63]
2712:Libraries/FreeRTOS/Source/tasks.c **** 		{
 281              		.loc 1 2712 0
 282 00c8 EB7A     		ldrb	r3, [r5, #11]	@ zero_extendqisi2
 283 00ca 63B1     		cbz	r3, .L20
 284              	.LVL26:
2707:Libraries/FreeRTOS/Source/tasks.c **** 
 285              		.loc 1 2707 0
 286 00cc 2B7B     		ldrb	r3, [r5, #12]	@ zero_extendqisi2
 287 00ce 84F84030 		strb	r3, [r4, #64]
2712:Libraries/FreeRTOS/Source/tasks.c **** 		{
 288              		.loc 1 2712 0
 289 00d2 2B7B     		ldrb	r3, [r5, #12]	@ zero_extendqisi2
 290 00d4 3BB1     		cbz	r3, .L20
 291              	.LVL27:
2707:Libraries/FreeRTOS/Source/tasks.c **** 
 292              		.loc 1 2707 0
 293 00d6 6B7B     		ldrb	r3, [r5, #13]	@ zero_extendqisi2
 294 00d8 84F84130 		strb	r3, [r4, #65]
2712:Libraries/FreeRTOS/Source/tasks.c **** 		{
 295              		.loc 1 2712 0
 296 00dc 6B7B     		ldrb	r3, [r5, #13]	@ zero_extendqisi2
 297 00de 13B1     		cbz	r3, .L20
 298              	.LVL28:
2707:Libraries/FreeRTOS/Source/tasks.c **** 
 299              		.loc 1 2707 0
 300 00e0 AB7B     		ldrb	r3, [r5, #14]	@ zero_extendqisi2
 301 00e2 84F84230 		strb	r3, [r4, #66]
 302              	.LVL29:
 303              	.L20:
2724:Libraries/FreeRTOS/Source/tasks.c **** 
 304              		.loc 1 2724 0
 305 00e6 0023     		movs	r3, #0
2744:Libraries/FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 306              		.loc 1 2744 0
 307 00e8 04F10408 		add	r8, r4, #4
 308              	.LVL30:
2724:Libraries/FreeRTOS/Source/tasks.c **** 
 309              		.loc 1 2724 0
 310 00ec 84F84330 		strb	r3, [r4, #67]
2744:Libraries/FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 311              		.loc 1 2744 0
 312 00f0 4046     		mov	r0, r8
2737:Libraries/FreeRTOS/Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 313              		.loc 1 2737 0
 314 00f2 E762     		str	r7, [r4, #44]
2740:Libraries/FreeRTOS/Source/tasks.c **** 	}
 315              		.loc 1 2740 0
 316 00f4 6764     		str	r7, [r4, #68]
2744:Libraries/FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 317              		.loc 1 2744 0
 318 00f6 FFF7FEFF 		bl	vListInitialiseItem
 319              	.LVL31:
2745:Libraries/FreeRTOS/Source/tasks.c **** 
 320              		.loc 1 2745 0
 321 00fa 04F11800 		add	r0, r4, #24
 322 00fe FFF7FEFF 		bl	vListInitialiseItem
 323              	.LVL32:
2752:Libraries/FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 324              		.loc 1 2752 0
 325 0102 C7F10503 		rsb	r3, r7, #5
2749:Libraries/FreeRTOS/Source/tasks.c **** 
 326              		.loc 1 2749 0
 327 0106 2461     		str	r4, [r4, #16]
2753:Libraries/FreeRTOS/Source/tasks.c **** 
 328              		.loc 1 2753 0
 329 0108 6462     		str	r4, [r4, #36]
 330              	.LBE30:
 331              	.LBE34:
 585:Libraries/FreeRTOS/Source/tasks.c **** 		}
 332              		.loc 1 585 0
 333 010a 3046     		mov	r0, r6
 334 010c 4946     		mov	r1, r9
 335 010e 5A46     		mov	r2, fp
 336              	.LBB35:
 337              	.LBB31:
2752:Libraries/FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 338              		.loc 1 2752 0
 339 0110 A361     		str	r3, [r4, #24]
 340              	.LBE31:
 341              	.LBE35:
 585:Libraries/FreeRTOS/Source/tasks.c **** 		}
 342              		.loc 1 585 0
 343 0112 FFF7FEFF 		bl	pxPortInitialiseStack
 344              	.LVL33:
 345 0116 2060     		str	r0, [r4]
 589:Libraries/FreeRTOS/Source/tasks.c **** 		{
 346              		.loc 1 589 0
 347 0118 BAF1000F 		cmp	r10, #0
 348 011c 01D0     		beq	.L13
 594:Libraries/FreeRTOS/Source/tasks.c **** 		}
 349              		.loc 1 594 0
 350 011e CAF80040 		str	r4, [r10]
 351              	.L13:
 603:Libraries/FreeRTOS/Source/tasks.c **** 		{
 352              		.loc 1 603 0
 353 0122 FFF7FEFF 		bl	vPortEnterCritical
 354              	.LVL34:
 605:Libraries/FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB == NULL )
 355              		.loc 1 605 0
 356 0126 40F20003 		movw	r3, #:lower16:.LANCHOR8
 357 012a C0F20003 		movt	r3, #:upper16:.LANCHOR8
 606:Libraries/FreeRTOS/Source/tasks.c **** 			{
 358              		.loc 1 606 0
 359 012e 40F20006 		movw	r6, #:lower16:.LANCHOR9
 360              	.LVL35:
 605:Libraries/FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB == NULL )
 361              		.loc 1 605 0
 362 0132 1A68     		ldr	r2, [r3]
 606:Libraries/FreeRTOS/Source/tasks.c **** 			{
 363              		.loc 1 606 0
 364 0134 C0F20006 		movt	r6, #:upper16:.LANCHOR9
 605:Libraries/FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB == NULL )
 365              		.loc 1 605 0
 366 0138 0132     		adds	r2, r2, #1
 367 013a 1A60     		str	r2, [r3]
 606:Libraries/FreeRTOS/Source/tasks.c **** 			{
 368              		.loc 1 606 0
 369 013c 3268     		ldr	r2, [r6]
 370 013e 002A     		cmp	r2, #0
 371 0140 38D0     		beq	.L76
 629:Libraries/FreeRTOS/Source/tasks.c **** 				{
 372              		.loc 1 629 0
 373 0142 40F20005 		movw	r5, #:lower16:.LANCHOR10
 374              	.LVL36:
 375 0146 C0F20005 		movt	r5, #:upper16:.LANCHOR10
 376 014a 2B68     		ldr	r3, [r5]
 377 014c 23B9     		cbnz	r3, .L16
 631:Libraries/FreeRTOS/Source/tasks.c **** 					{
 378              		.loc 1 631 0
 379 014e 3368     		ldr	r3, [r6]
 380 0150 DB6A     		ldr	r3, [r3, #44]
 381 0152 9F42     		cmp	r7, r3
 633:Libraries/FreeRTOS/Source/tasks.c **** 					}
 382              		.loc 1 633 0
 383 0154 28BF     		it	cs
 384 0156 3460     		strcs	r4, [r6]
 385              	.L16:
 646:Libraries/FreeRTOS/Source/tasks.c **** 
 386              		.loc 1 646 0
 387 0158 40F20000 		movw	r0, #:lower16:.LANCHOR11
 388 015c C0F20000 		movt	r0, #:upper16:.LANCHOR11
 656:Libraries/FreeRTOS/Source/tasks.c **** 
 389              		.loc 1 656 0
 390 0160 40F20002 		movw	r2, #:lower16:.LANCHOR12
 391 0164 C0F20002 		movt	r2, #:upper16:.LANCHOR12
 646:Libraries/FreeRTOS/Source/tasks.c **** 
 392              		.loc 1 646 0
 393 0168 0168     		ldr	r1, [r0]
 656:Libraries/FreeRTOS/Source/tasks.c **** 
 394              		.loc 1 656 0
 395 016a E36A     		ldr	r3, [r4, #44]
 396 016c 1468     		ldr	r4, [r2]
 397              	.LVL37:
 646:Libraries/FreeRTOS/Source/tasks.c **** 
 398              		.loc 1 646 0
 399 016e 0131     		adds	r1, r1, #1
 656:Libraries/FreeRTOS/Source/tasks.c **** 
 400              		.loc 1 656 0
 401 0170 A342     		cmp	r3, r4
 646:Libraries/FreeRTOS/Source/tasks.c **** 
 402              		.loc 1 646 0
 403 0172 0160     		str	r1, [r0]
 656:Libraries/FreeRTOS/Source/tasks.c **** 
 404              		.loc 1 656 0
 405 0174 40F20000 		movw	r0, #:lower16:.LANCHOR0
 406 0178 88BF     		it	hi
 407 017a 1360     		strhi	r3, [r2]
 408 017c C0F20000 		movt	r0, #:upper16:.LANCHOR0
 409 0180 03EB8303 		add	r3, r3, r3, lsl #2
 410 0184 00EB8300 		add	r0, r0, r3, lsl #2
 411 0188 4146     		mov	r1, r8
 412 018a FFF7FEFF 		bl	vListInsertEnd
 413              	.LVL38:
 661:Libraries/FreeRTOS/Source/tasks.c **** 	}
 414              		.loc 1 661 0
 415 018e FFF7FEFF 		bl	vPortExitCritical
 416              	.LVL39:
 417              	.LBE25:
 671:Libraries/FreeRTOS/Source/tasks.c **** 		{
 418              		.loc 1 671 0
 419 0192 2B68     		ldr	r3, [r5]
 420 0194 1BB1     		cbz	r3, .L23
 675:Libraries/FreeRTOS/Source/tasks.c **** 			{
 421              		.loc 1 675 0
 422 0196 3368     		ldr	r3, [r6]
 423 0198 DB6A     		ldr	r3, [r3, #44]
 424 019a 9F42     		cmp	r7, r3
 425 019c 05D8     		bhi	.L77
 426              	.L23:
 427              	.LBB36:
 658:Libraries/FreeRTOS/Source/tasks.c **** 			portSETUP_TCB( pxNewTCB );
 428              		.loc 1 658 0
 429 019e 0120     		movs	r0, #1
 430 01a0 BDE8F88F 		pop	{r3, r4, r5, r6, r7, r8, r9, r10, fp, pc}
 431              	.LVL40:
 432              	.L74:
 433              	.LBE36:
 521:Libraries/FreeRTOS/Source/tasks.c **** 	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );
 434              		.loc 1 521 0 discriminator 1
 435 01a4 FFF7FEFF 		bl	ulPortSetInterruptMask
 436              	.LVL41:
 437              	.L7:
 438 01a8 FEE7     		b	.L7
 439              	.LVL42:
 440              	.L77:
 677:Libraries/FreeRTOS/Source/tasks.c **** 			}
 441              		.loc 1 677 0
 442 01aa FFF7FEFF 		bl	vPortYield
 443              	.LVL43:
 444              	.LBB37:
 658:Libraries/FreeRTOS/Source/tasks.c **** 			portSETUP_TCB( pxNewTCB );
 445              		.loc 1 658 0
 446 01ae 0120     		movs	r0, #1
 447              	.LBE37:
 448 01b0 BDE8F88F 		pop	{r3, r4, r5, r6, r7, r8, r9, r10, fp, pc}
 449              	.LVL44:
 450              	.L76:
 451              	.LBB38:
 610:Libraries/FreeRTOS/Source/tasks.c **** 
 452              		.loc 1 610 0
 453 01b4 3460     		str	r4, [r6]
 612:Libraries/FreeRTOS/Source/tasks.c **** 				{
 454              		.loc 1 612 0
 455 01b6 1B68     		ldr	r3, [r3]
 456 01b8 012B     		cmp	r3, #1
 457 01ba 40F20005 		movw	r5, #:lower16:.LANCHOR10
 458              	.LVL45:
 459 01be 01D1     		bne	.L73
 617:Libraries/FreeRTOS/Source/tasks.c **** 				}
 460              		.loc 1 617 0
 461 01c0 FFF7FEFF 		bl	prvInitialiseTaskLists
 462              	.LVL46:
 463              	.L73:
 464 01c4 C0F20005 		movt	r5, #:upper16:.LANCHOR10
 465 01c8 C6E7     		b	.L16
 466              	.LVL47:
 467              	.L75:
 468              	.LBE38:
 469              	.LBB39:
 470              	.LBB24:
 471              		.loc 1 2924 0
 472 01ca 4FEA8800 		lsl	r0, r8, #2
 473              	.LVL48:
 474 01ce FFF7FEFF 		bl	pvPortMalloc
 475              	.LVL49:
 476 01d2 2063     		str	r0, [r4, #48]
2925:Libraries/FreeRTOS/Source/tasks.c **** 
2926:Libraries/FreeRTOS/Source/tasks.c **** 		if( pxNewTCB->pxStack == NULL )
 477              		.loc 1 2926 0
 478 01d4 0028     		cmp	r0, #0
 479 01d6 7FF431AF 		bne	.L12
2927:Libraries/FreeRTOS/Source/tasks.c **** 		{
2928:Libraries/FreeRTOS/Source/tasks.c **** 			/* Could not allocate the stack.  Delete the allocated TCB. */
2929:Libraries/FreeRTOS/Source/tasks.c **** 			vPortFree( pxNewTCB );
 480              		.loc 1 2929 0
 481 01da 2046     		mov	r0, r4
 482 01dc FFF7FEFF 		bl	vPortFree
 483              	.LVL50:
 484              	.L10:
 485              	.LBE24:
 486              	.LBE39:
 665:Libraries/FreeRTOS/Source/tasks.c **** 		traceTASK_CREATE_FAILED();
 487              		.loc 1 665 0
 488 01e0 4FF0FF30 		mov	r0, #-1
 691:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 489              		.loc 1 691 0
 490 01e4 BDE8F88F 		pop	{r3, r4, r5, r6, r7, r8, r9, r10, fp, pc}
 491              		.cfi_endproc
 492              	.LFE123:
 494              		.section	.text.vTaskDelete,"ax",%progbits
 495              		.align	2
 496              		.global	vTaskDelete
 497              		.thumb
 498              		.thumb_func
 500              	vTaskDelete:
 501              	.LFB124:
 697:Libraries/FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
 502              		.loc 1 697 0
 503              		.cfi_startproc
 504              		@ args = 0, pretend = 0, frame = 0
 505              		@ frame_needed = 0, uses_anonymous_args = 0
 506              	.LVL51:
 507 0000 38B5     		push	{r3, r4, r5, lr}
 508              	.LCFI2:
 509              		.cfi_def_cfa_offset 16
 510              		.cfi_offset 3, -16
 511              		.cfi_offset 4, -12
 512              		.cfi_offset 5, -8
 513              		.cfi_offset 14, -4
 697:Libraries/FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
 514              		.loc 1 697 0
 515 0002 0446     		mov	r4, r0
 700:Libraries/FreeRTOS/Source/tasks.c **** 		{
 516              		.loc 1 700 0
 517 0004 FFF7FEFF 		bl	vPortEnterCritical
 518              	.LVL52:
 704:Libraries/FreeRTOS/Source/tasks.c **** 
 519              		.loc 1 704 0
 520 0008 002C     		cmp	r4, #0
 521 000a 5CD0     		beq	.L92
 522              	.LVL53:
 523              	.L79:
 710:Libraries/FreeRTOS/Source/tasks.c **** 			{
 524              		.loc 1 710 0 discriminator 3
 525 000c 251D     		adds	r5, r4, #4
 526 000e 2846     		mov	r0, r5
 527 0010 FFF7FEFF 		bl	uxListRemove
 528              	.LVL54:
 720:Libraries/FreeRTOS/Source/tasks.c **** 			{
 529              		.loc 1 720 0 discriminator 3
 530 0014 A36A     		ldr	r3, [r4, #40]
 531 0016 1BB1     		cbz	r3, .L80
 722:Libraries/FreeRTOS/Source/tasks.c **** 			}
 532              		.loc 1 722 0
 533 0018 04F11800 		add	r0, r4, #24
 534 001c FFF7FEFF 		bl	uxListRemove
 535              	.LVL55:
 536              	.L80:
 729:Libraries/FreeRTOS/Source/tasks.c **** 
 537              		.loc 1 729 0
 538 0020 40F20000 		movw	r0, #:lower16:.LANCHOR4
 539 0024 2946     		mov	r1, r5
 540 0026 C0F20000 		movt	r0, #:upper16:.LANCHOR4
 541 002a FFF7FEFF 		bl	vListInsertEnd
 542              	.LVL56:
 734:Libraries/FreeRTOS/Source/tasks.c **** 
 543              		.loc 1 734 0
 544 002e 40F20002 		movw	r2, #:lower16:.LANCHOR13
 738:Libraries/FreeRTOS/Source/tasks.c **** 
 545              		.loc 1 738 0
 546 0032 40F20003 		movw	r3, #:lower16:.LANCHOR11
 547 0036 C0F20003 		movt	r3, #:upper16:.LANCHOR11
 734:Libraries/FreeRTOS/Source/tasks.c **** 
 548              		.loc 1 734 0
 549 003a C0F20002 		movt	r2, #:upper16:.LANCHOR13
 738:Libraries/FreeRTOS/Source/tasks.c **** 
 550              		.loc 1 738 0
 551 003e 1968     		ldr	r1, [r3]
 734:Libraries/FreeRTOS/Source/tasks.c **** 
 552              		.loc 1 734 0
 553 0040 1068     		ldr	r0, [r2]
 738:Libraries/FreeRTOS/Source/tasks.c **** 
 554              		.loc 1 738 0
 555 0042 0131     		adds	r1, r1, #1
 734:Libraries/FreeRTOS/Source/tasks.c **** 
 556              		.loc 1 734 0
 557 0044 0130     		adds	r0, r0, #1
 738:Libraries/FreeRTOS/Source/tasks.c **** 
 558              		.loc 1 738 0
 559 0046 1960     		str	r1, [r3]
 734:Libraries/FreeRTOS/Source/tasks.c **** 
 560              		.loc 1 734 0
 561 0048 1060     		str	r0, [r2]
 742:Libraries/FreeRTOS/Source/tasks.c **** 
 562              		.loc 1 742 0
 563 004a FFF7FEFF 		bl	vPortExitCritical
 564              	.LVL57:
 746:Libraries/FreeRTOS/Source/tasks.c **** 		{
 565              		.loc 1 746 0
 566 004e 40F20003 		movw	r3, #:lower16:.LANCHOR10
 567 0052 C0F20003 		movt	r3, #:upper16:.LANCHOR10
 568 0056 1B68     		ldr	r3, [r3]
 569 0058 83B3     		cbz	r3, .L78
 748:Libraries/FreeRTOS/Source/tasks.c **** 			{
 570              		.loc 1 748 0
 571 005a 40F20003 		movw	r3, #:lower16:.LANCHOR9
 572 005e C0F20003 		movt	r3, #:upper16:.LANCHOR9
 573 0062 1B68     		ldr	r3, [r3]
 574 0064 9C42     		cmp	r4, r3
 575 0066 20D0     		beq	.L93
 764:Libraries/FreeRTOS/Source/tasks.c **** 				{
 576              		.loc 1 764 0
 577 0068 FFF7FEFF 		bl	vPortEnterCritical
 578              	.LVL58:
 579              	.LBB44:
 580              	.LBB45:
2930:Libraries/FreeRTOS/Source/tasks.c **** 			pxNewTCB = NULL;
2931:Libraries/FreeRTOS/Source/tasks.c **** 		}
2932:Libraries/FreeRTOS/Source/tasks.c **** 		else
2933:Libraries/FreeRTOS/Source/tasks.c **** 		{
2934:Libraries/FreeRTOS/Source/tasks.c **** 			/* Avoid dependency on memset() if it is not required. */
2935:Libraries/FreeRTOS/Source/tasks.c **** 			#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_ux
2936:Libraries/FreeRTOS/Source/tasks.c **** 			{
2937:Libraries/FreeRTOS/Source/tasks.c **** 				/* Just to help debugging. */
2938:Libraries/FreeRTOS/Source/tasks.c **** 				( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeo
2939:Libraries/FreeRTOS/Source/tasks.c **** 			}
2940:Libraries/FreeRTOS/Source/tasks.c **** 			#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( I
2941:Libraries/FreeRTOS/Source/tasks.c **** 		}
2942:Libraries/FreeRTOS/Source/tasks.c **** 	}
2943:Libraries/FreeRTOS/Source/tasks.c **** 
2944:Libraries/FreeRTOS/Source/tasks.c **** 	return pxNewTCB;
2945:Libraries/FreeRTOS/Source/tasks.c **** }
2946:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2947:Libraries/FreeRTOS/Source/tasks.c **** 
2948:Libraries/FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2949:Libraries/FreeRTOS/Source/tasks.c **** 
2950:Libraries/FreeRTOS/Source/tasks.c **** 	static UBaseType_t prvListTaskWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, e
2951:Libraries/FreeRTOS/Source/tasks.c **** 	{
2952:Libraries/FreeRTOS/Source/tasks.c **** 	volatile TCB_t *pxNextTCB, *pxFirstTCB;
2953:Libraries/FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTask = 0;
2954:Libraries/FreeRTOS/Source/tasks.c **** 
2955:Libraries/FreeRTOS/Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
2956:Libraries/FreeRTOS/Source/tasks.c **** 		{
2957:Libraries/FreeRTOS/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
2958:Libraries/FreeRTOS/Source/tasks.c **** 
2959:Libraries/FreeRTOS/Source/tasks.c **** 			/* Populate an TaskStatus_t structure within the
2960:Libraries/FreeRTOS/Source/tasks.c **** 			pxTaskStatusArray array for each task that is referenced from
2961:Libraries/FreeRTOS/Source/tasks.c **** 			pxList.  See the definition of TaskStatus_t in task.h for the
2962:Libraries/FreeRTOS/Source/tasks.c **** 			meaning of each TaskStatus_t structure member. */
2963:Libraries/FreeRTOS/Source/tasks.c **** 			do
2964:Libraries/FreeRTOS/Source/tasks.c **** 			{
2965:Libraries/FreeRTOS/Source/tasks.c **** 				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
2966:Libraries/FreeRTOS/Source/tasks.c **** 
2967:Libraries/FreeRTOS/Source/tasks.c **** 				pxTaskStatusArray[ uxTask ].xHandle = ( TaskHandle_t ) pxNextTCB;
2968:Libraries/FreeRTOS/Source/tasks.c **** 				pxTaskStatusArray[ uxTask ].pcTaskName = ( const char * ) &( pxNextTCB->pcTaskName [ 0 ] );
2969:Libraries/FreeRTOS/Source/tasks.c **** 				pxTaskStatusArray[ uxTask ].xTaskNumber = pxNextTCB->uxTCBNumber;
2970:Libraries/FreeRTOS/Source/tasks.c **** 				pxTaskStatusArray[ uxTask ].eCurrentState = eState;
2971:Libraries/FreeRTOS/Source/tasks.c **** 				pxTaskStatusArray[ uxTask ].uxCurrentPriority = pxNextTCB->uxPriority;
2972:Libraries/FreeRTOS/Source/tasks.c **** 
2973:Libraries/FreeRTOS/Source/tasks.c **** 				#if ( INCLUDE_vTaskSuspend == 1 )
2974:Libraries/FreeRTOS/Source/tasks.c **** 				{
2975:Libraries/FreeRTOS/Source/tasks.c **** 					/* If the task is in the suspended list then there is a chance
2976:Libraries/FreeRTOS/Source/tasks.c **** 					it is actually just blocked indefinitely - so really it should
2977:Libraries/FreeRTOS/Source/tasks.c **** 					be reported as being in the Blocked state. */
2978:Libraries/FreeRTOS/Source/tasks.c **** 					if( eState == eSuspended )
2979:Libraries/FreeRTOS/Source/tasks.c **** 					{
2980:Libraries/FreeRTOS/Source/tasks.c **** 						if( listLIST_ITEM_CONTAINER( &( pxNextTCB->xEventListItem ) ) != NULL )
2981:Libraries/FreeRTOS/Source/tasks.c **** 						{
2982:Libraries/FreeRTOS/Source/tasks.c **** 							pxTaskStatusArray[ uxTask ].eCurrentState = eBlocked;
2983:Libraries/FreeRTOS/Source/tasks.c **** 						}
2984:Libraries/FreeRTOS/Source/tasks.c **** 					}
2985:Libraries/FreeRTOS/Source/tasks.c **** 				}
2986:Libraries/FreeRTOS/Source/tasks.c **** 				#endif /* INCLUDE_vTaskSuspend */
2987:Libraries/FreeRTOS/Source/tasks.c **** 
2988:Libraries/FreeRTOS/Source/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
2989:Libraries/FreeRTOS/Source/tasks.c **** 				{
2990:Libraries/FreeRTOS/Source/tasks.c **** 					pxTaskStatusArray[ uxTask ].uxBasePriority = pxNextTCB->uxBasePriority;
2991:Libraries/FreeRTOS/Source/tasks.c **** 				}
2992:Libraries/FreeRTOS/Source/tasks.c **** 				#else
2993:Libraries/FreeRTOS/Source/tasks.c **** 				{
2994:Libraries/FreeRTOS/Source/tasks.c **** 					pxTaskStatusArray[ uxTask ].uxBasePriority = 0;
2995:Libraries/FreeRTOS/Source/tasks.c **** 				}
2996:Libraries/FreeRTOS/Source/tasks.c **** 				#endif
2997:Libraries/FreeRTOS/Source/tasks.c **** 
2998:Libraries/FreeRTOS/Source/tasks.c **** 				#if ( configGENERATE_RUN_TIME_STATS == 1 )
2999:Libraries/FreeRTOS/Source/tasks.c **** 				{
3000:Libraries/FreeRTOS/Source/tasks.c **** 					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = pxNextTCB->ulRunTimeCounter;
3001:Libraries/FreeRTOS/Source/tasks.c **** 				}
3002:Libraries/FreeRTOS/Source/tasks.c **** 				#else
3003:Libraries/FreeRTOS/Source/tasks.c **** 				{
3004:Libraries/FreeRTOS/Source/tasks.c **** 					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = 0;
3005:Libraries/FreeRTOS/Source/tasks.c **** 				}
3006:Libraries/FreeRTOS/Source/tasks.c **** 				#endif
3007:Libraries/FreeRTOS/Source/tasks.c **** 
3008:Libraries/FreeRTOS/Source/tasks.c **** 				#if ( portSTACK_GROWTH > 0 )
3009:Libraries/FreeRTOS/Source/tasks.c **** 				{
3010:Libraries/FreeRTOS/Source/tasks.c **** 					pxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) p
3011:Libraries/FreeRTOS/Source/tasks.c **** 				}
3012:Libraries/FreeRTOS/Source/tasks.c **** 				#else
3013:Libraries/FreeRTOS/Source/tasks.c **** 				{
3014:Libraries/FreeRTOS/Source/tasks.c **** 					pxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) p
3015:Libraries/FreeRTOS/Source/tasks.c **** 				}
3016:Libraries/FreeRTOS/Source/tasks.c **** 				#endif
3017:Libraries/FreeRTOS/Source/tasks.c **** 
3018:Libraries/FreeRTOS/Source/tasks.c **** 				uxTask++;
3019:Libraries/FreeRTOS/Source/tasks.c **** 
3020:Libraries/FreeRTOS/Source/tasks.c **** 			} while( pxNextTCB != pxFirstTCB );
3021:Libraries/FreeRTOS/Source/tasks.c **** 		}
3022:Libraries/FreeRTOS/Source/tasks.c **** 		else
3023:Libraries/FreeRTOS/Source/tasks.c **** 		{
3024:Libraries/FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3025:Libraries/FreeRTOS/Source/tasks.c **** 		}
3026:Libraries/FreeRTOS/Source/tasks.c **** 
3027:Libraries/FreeRTOS/Source/tasks.c **** 		return uxTask;
3028:Libraries/FreeRTOS/Source/tasks.c **** 	}
3029:Libraries/FreeRTOS/Source/tasks.c **** 
3030:Libraries/FreeRTOS/Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3031:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3032:Libraries/FreeRTOS/Source/tasks.c **** 
3033:Libraries/FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
3034:Libraries/FreeRTOS/Source/tasks.c **** 
3035:Libraries/FreeRTOS/Source/tasks.c **** 	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
3036:Libraries/FreeRTOS/Source/tasks.c **** 	{
3037:Libraries/FreeRTOS/Source/tasks.c **** 	uint32_t ulCount = 0U;
3038:Libraries/FreeRTOS/Source/tasks.c **** 
3039:Libraries/FreeRTOS/Source/tasks.c **** 		while( *pucStackByte == tskSTACK_FILL_BYTE )
3040:Libraries/FreeRTOS/Source/tasks.c **** 		{
3041:Libraries/FreeRTOS/Source/tasks.c **** 			pucStackByte -= portSTACK_GROWTH;
3042:Libraries/FreeRTOS/Source/tasks.c **** 			ulCount++;
3043:Libraries/FreeRTOS/Source/tasks.c **** 		}
3044:Libraries/FreeRTOS/Source/tasks.c **** 
3045:Libraries/FreeRTOS/Source/tasks.c **** 		ulCount /= ( uint32_t ) sizeof( StackType_t );
3046:Libraries/FreeRTOS/Source/tasks.c **** 
3047:Libraries/FreeRTOS/Source/tasks.c **** 		return ( uint16_t ) ulCount;
3048:Libraries/FreeRTOS/Source/tasks.c **** 	}
3049:Libraries/FreeRTOS/Source/tasks.c **** 
3050:Libraries/FreeRTOS/Source/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) */
3051:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3052:Libraries/FreeRTOS/Source/tasks.c **** 
3053:Libraries/FreeRTOS/Source/tasks.c **** #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
3054:Libraries/FreeRTOS/Source/tasks.c **** 
3055:Libraries/FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
3056:Libraries/FreeRTOS/Source/tasks.c **** 	{
3057:Libraries/FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
3058:Libraries/FreeRTOS/Source/tasks.c **** 	uint8_t *pucEndOfStack;
3059:Libraries/FreeRTOS/Source/tasks.c **** 	UBaseType_t uxReturn;
3060:Libraries/FreeRTOS/Source/tasks.c **** 
3061:Libraries/FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
3062:Libraries/FreeRTOS/Source/tasks.c **** 
3063:Libraries/FreeRTOS/Source/tasks.c **** 		#if portSTACK_GROWTH < 0
3064:Libraries/FreeRTOS/Source/tasks.c **** 		{
3065:Libraries/FreeRTOS/Source/tasks.c **** 			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
3066:Libraries/FreeRTOS/Source/tasks.c **** 		}
3067:Libraries/FreeRTOS/Source/tasks.c **** 		#else
3068:Libraries/FreeRTOS/Source/tasks.c **** 		{
3069:Libraries/FreeRTOS/Source/tasks.c **** 			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
3070:Libraries/FreeRTOS/Source/tasks.c **** 		}
3071:Libraries/FreeRTOS/Source/tasks.c **** 		#endif
3072:Libraries/FreeRTOS/Source/tasks.c **** 
3073:Libraries/FreeRTOS/Source/tasks.c **** 		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
3074:Libraries/FreeRTOS/Source/tasks.c **** 
3075:Libraries/FreeRTOS/Source/tasks.c **** 		return uxReturn;
3076:Libraries/FreeRTOS/Source/tasks.c **** 	}
3077:Libraries/FreeRTOS/Source/tasks.c **** 
3078:Libraries/FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_uxTaskGetStackHighWaterMark */
3079:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3080:Libraries/FreeRTOS/Source/tasks.c **** 
3081:Libraries/FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
3082:Libraries/FreeRTOS/Source/tasks.c **** 
3083:Libraries/FreeRTOS/Source/tasks.c **** 	static void prvDeleteTCB( TCB_t *pxTCB )
3084:Libraries/FreeRTOS/Source/tasks.c **** 	{
3085:Libraries/FreeRTOS/Source/tasks.c **** 		/* This call is required specifically for the TriCore port.  It must be
3086:Libraries/FreeRTOS/Source/tasks.c **** 		above the vPortFree() calls.  The call is also used by ports/demos that
3087:Libraries/FreeRTOS/Source/tasks.c **** 		want to allocate and clean RAM statically. */
3088:Libraries/FreeRTOS/Source/tasks.c **** 		portCLEAN_UP_TCB( pxTCB );
3089:Libraries/FreeRTOS/Source/tasks.c **** 
3090:Libraries/FreeRTOS/Source/tasks.c **** 		/* Free up the memory allocated by the scheduler for the task.  It is up
3091:Libraries/FreeRTOS/Source/tasks.c **** 		to the task to free any memory allocated at the application level. */
3092:Libraries/FreeRTOS/Source/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
3093:Libraries/FreeRTOS/Source/tasks.c **** 		{
3094:Libraries/FreeRTOS/Source/tasks.c **** 			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
3095:Libraries/FreeRTOS/Source/tasks.c **** 		}
3096:Libraries/FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
3097:Libraries/FreeRTOS/Source/tasks.c **** 		vPortFreeAligned( pxTCB->pxStack );
3098:Libraries/FreeRTOS/Source/tasks.c **** 		vPortFree( pxTCB );
3099:Libraries/FreeRTOS/Source/tasks.c **** 	}
3100:Libraries/FreeRTOS/Source/tasks.c **** 
3101:Libraries/FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskDelete */
3102:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3103:Libraries/FreeRTOS/Source/tasks.c **** 
3104:Libraries/FreeRTOS/Source/tasks.c **** static void prvResetNextTaskUnblockTime( void )
3105:Libraries/FreeRTOS/Source/tasks.c **** {
3106:Libraries/FreeRTOS/Source/tasks.c **** TCB_t *pxTCB;
3107:Libraries/FreeRTOS/Source/tasks.c **** 
3108:Libraries/FreeRTOS/Source/tasks.c **** 	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 581              		.loc 1 3108 0
 582 006c 40F20003 		movw	r3, #:lower16:.LANCHOR6
 583 0070 C0F20003 		movt	r3, #:upper16:.LANCHOR6
 584 0074 1A68     		ldr	r2, [r3]
 585 0076 1268     		ldr	r2, [r2]
 586 0078 62B1     		cbz	r2, .L85
 587              	.LBB46:
 588              	.LBB47:
3109:Libraries/FreeRTOS/Source/tasks.c **** 	{
3110:Libraries/FreeRTOS/Source/tasks.c **** 		/* The new current delayed list is empty.  Set
3111:Libraries/FreeRTOS/Source/tasks.c **** 		xNextTaskUnblockTime to the maximum possible value so it is
3112:Libraries/FreeRTOS/Source/tasks.c **** 		extremely unlikely that the
3113:Libraries/FreeRTOS/Source/tasks.c **** 		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
3114:Libraries/FreeRTOS/Source/tasks.c **** 		there is an item in the delayed list. */
3115:Libraries/FreeRTOS/Source/tasks.c **** 		xNextTaskUnblockTime = portMAX_DELAY;
3116:Libraries/FreeRTOS/Source/tasks.c **** 	}
3117:Libraries/FreeRTOS/Source/tasks.c **** 	else
3118:Libraries/FreeRTOS/Source/tasks.c **** 	{
3119:Libraries/FreeRTOS/Source/tasks.c **** 		/* The new current delayed list is not empty, get the value of
3120:Libraries/FreeRTOS/Source/tasks.c **** 		the item at the head of the delayed list.  This is the time at
3121:Libraries/FreeRTOS/Source/tasks.c **** 		which the task at the head of the delayed list should be removed
3122:Libraries/FreeRTOS/Source/tasks.c **** 		from the Blocked state. */
3123:Libraries/FreeRTOS/Source/tasks.c **** 		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 589              		.loc 1 3123 0
 590 007a 1B68     		ldr	r3, [r3]
 591              	.LVL59:
 592 007c DB68     		ldr	r3, [r3, #12]
 593              	.LVL60:
3124:Libraries/FreeRTOS/Source/tasks.c **** 		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
 594              		.loc 1 3124 0
 595 007e DA68     		ldr	r2, [r3, #12]
 596 0080 40F20003 		movw	r3, #:lower16:.LANCHOR15
 597              	.LVL61:
 598 0084 C0F20003 		movt	r3, #:upper16:.LANCHOR15
 599 0088 5268     		ldr	r2, [r2, #4]
 600              	.LVL62:
 601 008a 1A60     		str	r2, [r3]
 602              	.LBE47:
 603              	.LBE46:
 604              	.LBE45:
 605              	.LBE44:
 771:Libraries/FreeRTOS/Source/tasks.c **** 
 606              		.loc 1 771 0
 607 008c BDE83840 		pop	{r3, r4, r5, lr}
 608              	.LVL63:
 768:Libraries/FreeRTOS/Source/tasks.c **** 			}
 609              		.loc 1 768 0
 610 0090 FFF7FEBF 		b	vPortExitCritical
 611              	.LVL64:
 612              	.L85:
 613              	.LBB49:
 614              	.LBB48:
3115:Libraries/FreeRTOS/Source/tasks.c **** 	}
 615              		.loc 1 3115 0
 616 0094 40F20003 		movw	r3, #:lower16:.LANCHOR15
 617 0098 C0F20003 		movt	r3, #:upper16:.LANCHOR15
 618 009c 4FF0FF32 		mov	r2, #-1
 619 00a0 1A60     		str	r2, [r3]
 620              	.LBE48:
 621              	.LBE49:
 771:Libraries/FreeRTOS/Source/tasks.c **** 
 622              		.loc 1 771 0
 623 00a2 BDE83840 		pop	{r3, r4, r5, lr}
 624              	.LVL65:
 768:Libraries/FreeRTOS/Source/tasks.c **** 			}
 625              		.loc 1 768 0
 626 00a6 FFF7FEBF 		b	vPortExitCritical
 627              	.LVL66:
 628              	.L93:
 750:Libraries/FreeRTOS/Source/tasks.c **** 
 629              		.loc 1 750 0
 630 00aa 40F20003 		movw	r3, #:lower16:.LANCHOR14
 631 00ae C0F20003 		movt	r3, #:upper16:.LANCHOR14
 632 00b2 1B68     		ldr	r3, [r3]
 633 00b4 1BB1     		cbz	r3, .L83
 750:Libraries/FreeRTOS/Source/tasks.c **** 
 634              		.loc 1 750 0 is_stmt 0 discriminator 1
 635 00b6 FFF7FEFF 		bl	ulPortSetInterruptMask
 636              	.LVL67:
 637              	.L84:
 638 00ba FEE7     		b	.L84
 639              	.L78:
 640 00bc 38BD     		pop	{r3, r4, r5, pc}
 641              	.LVL68:
 642              	.L83:
 771:Libraries/FreeRTOS/Source/tasks.c **** 
 643              		.loc 1 771 0 is_stmt 1
 644 00be BDE83840 		pop	{r3, r4, r5, lr}
 645              	.LVL69:
 758:Libraries/FreeRTOS/Source/tasks.c **** 			}
 646              		.loc 1 758 0
 647 00c2 FFF7FEBF 		b	vPortYield
 648              	.LVL70:
 649              	.L92:
 704:Libraries/FreeRTOS/Source/tasks.c **** 
 650              		.loc 1 704 0 discriminator 1
 651 00c6 40F20003 		movw	r3, #:lower16:.LANCHOR9
 652 00ca C0F20003 		movt	r3, #:upper16:.LANCHOR9
 653 00ce 1C68     		ldr	r4, [r3]
 654              	.LVL71:
 655 00d0 9CE7     		b	.L79
 656              		.cfi_endproc
 657              	.LFE124:
 659 00d2 00BF     		.section	.text.uxTaskPriorityGet,"ax",%progbits
 660              		.align	2
 661              		.global	uxTaskPriorityGet
 662              		.thumb
 663              		.thumb_func
 665              	uxTaskPriorityGet:
 666              	.LFB127:
1011:Libraries/FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
 667              		.loc 1 1011 0
 668              		.cfi_startproc
 669              		@ args = 0, pretend = 0, frame = 0
 670              		@ frame_needed = 0, uses_anonymous_args = 0
 671              	.LVL72:
 672 0000 10B5     		push	{r4, lr}
 673              	.LCFI3:
 674              		.cfi_def_cfa_offset 8
 675              		.cfi_offset 4, -8
 676              		.cfi_offset 14, -4
1011:Libraries/FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
 677              		.loc 1 1011 0
 678 0002 0446     		mov	r4, r0
1015:Libraries/FreeRTOS/Source/tasks.c **** 		{
 679              		.loc 1 1015 0
 680 0004 FFF7FEFF 		bl	vPortEnterCritical
 681              	.LVL73:
1019:Libraries/FreeRTOS/Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 682              		.loc 1 1019 0
 683 0008 24B1     		cbz	r4, .L96
 684              	.LVL74:
1020:Libraries/FreeRTOS/Source/tasks.c **** 		}
 685              		.loc 1 1020 0 discriminator 3
 686 000a E46A     		ldr	r4, [r4, #44]
 687              	.LVL75:
1022:Libraries/FreeRTOS/Source/tasks.c **** 
 688              		.loc 1 1022 0 discriminator 3
 689 000c FFF7FEFF 		bl	vPortExitCritical
 690              	.LVL76:
1025:Libraries/FreeRTOS/Source/tasks.c **** 
 691              		.loc 1 1025 0 discriminator 3
 692 0010 2046     		mov	r0, r4
 693 0012 10BD     		pop	{r4, pc}
 694              	.LVL77:
 695              	.L96:
1019:Libraries/FreeRTOS/Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 696              		.loc 1 1019 0 discriminator 1
 697 0014 40F20003 		movw	r3, #:lower16:.LANCHOR9
 698 0018 C0F20003 		movt	r3, #:upper16:.LANCHOR9
 699 001c 1C68     		ldr	r4, [r3]
 700              	.LVL78:
1020:Libraries/FreeRTOS/Source/tasks.c **** 		}
 701              		.loc 1 1020 0 discriminator 1
 702 001e E46A     		ldr	r4, [r4, #44]
 703              	.LVL79:
1022:Libraries/FreeRTOS/Source/tasks.c **** 
 704              		.loc 1 1022 0 discriminator 1
 705 0020 FFF7FEFF 		bl	vPortExitCritical
 706              	.LVL80:
1025:Libraries/FreeRTOS/Source/tasks.c **** 
 707              		.loc 1 1025 0 discriminator 1
 708 0024 2046     		mov	r0, r4
 709 0026 10BD     		pop	{r4, pc}
 710              		.cfi_endproc
 711              	.LFE127:
 713              		.section	.text.vTaskPrioritySet,"ax",%progbits
 714              		.align	2
 715              		.global	vTaskPrioritySet
 716              		.thumb
 717              		.thumb_func
 719              	vTaskPrioritySet:
 720              	.LFB128:
1033:Libraries/FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
 721              		.loc 1 1033 0
 722              		.cfi_startproc
 723              		@ args = 0, pretend = 0, frame = 0
 724              		@ frame_needed = 0, uses_anonymous_args = 0
 725              	.LVL81:
1038:Libraries/FreeRTOS/Source/tasks.c **** 
 726              		.loc 1 1038 0
 727 0000 0429     		cmp	r1, #4
1033:Libraries/FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
 728              		.loc 1 1033 0
 729 0002 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 730              	.LCFI4:
 731              		.cfi_def_cfa_offset 24
 732              		.cfi_offset 3, -24
 733              		.cfi_offset 4, -20
 734              		.cfi_offset 5, -16
 735              		.cfi_offset 6, -12
 736              		.cfi_offset 7, -8
 737              		.cfi_offset 14, -4
1033:Libraries/FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
 738              		.loc 1 1033 0
 739 0004 0D46     		mov	r5, r1
 740 0006 0446     		mov	r4, r0
1038:Libraries/FreeRTOS/Source/tasks.c **** 
 741              		.loc 1 1038 0
 742 0008 36D8     		bhi	.L113
1050:Libraries/FreeRTOS/Source/tasks.c **** 		{
 743              		.loc 1 1050 0
 744 000a FFF7FEFF 		bl	vPortEnterCritical
 745              	.LVL82:
1054:Libraries/FreeRTOS/Source/tasks.c **** 
 746              		.loc 1 1054 0
 747 000e 002C     		cmp	r4, #0
 748 0010 35D0     		beq	.L114
 749              	.LVL83:
 750              	.L100:
1060:Libraries/FreeRTOS/Source/tasks.c **** 			}
 751              		.loc 1 1060 0 discriminator 3
 752 0012 626C     		ldr	r2, [r4, #68]
 753              	.LVL84:
1068:Libraries/FreeRTOS/Source/tasks.c **** 			{
 754              		.loc 1 1068 0 discriminator 3
 755 0014 9542     		cmp	r5, r2
 756 0016 26D0     		beq	.L102
1074:Libraries/FreeRTOS/Source/tasks.c **** 					{
 757              		.loc 1 1074 0
 758 0018 40F20003 		movw	r3, #:lower16:.LANCHOR9
 759 001c C0F20003 		movt	r3, #:upper16:.LANCHOR9
1072:Libraries/FreeRTOS/Source/tasks.c **** 				{
 760              		.loc 1 1072 0
 761 0020 25D9     		bls	.L103
1074:Libraries/FreeRTOS/Source/tasks.c **** 					{
 762              		.loc 1 1074 0
 763 0022 1968     		ldr	r1, [r3]
 764 0024 8C42     		cmp	r4, r1
1036:Libraries/FreeRTOS/Source/tasks.c **** 
 765              		.loc 1 1036 0
 766 0026 08BF     		it	eq
 767 0028 0026     		moveq	r6, #0
1074:Libraries/FreeRTOS/Source/tasks.c **** 					{
 768              		.loc 1 1074 0
 769 002a 05D0     		beq	.L104
1079:Libraries/FreeRTOS/Source/tasks.c **** 						{
 770              		.loc 1 1079 0
 771 002c 1B68     		ldr	r3, [r3]
 772 002e DE6A     		ldr	r6, [r3, #44]
 773 0030 B542     		cmp	r5, r6
 774 0032 34BF     		ite	cc
 775 0034 0026     		movcc	r6, #0
 776 0036 0126     		movcs	r6, #1
 777              	.L104:
 778              	.LVL85:
1112:Libraries/FreeRTOS/Source/tasks.c **** 
 779              		.loc 1 1112 0
 780 0038 E36A     		ldr	r3, [r4, #44]
 781              	.LVL86:
1128:Libraries/FreeRTOS/Source/tasks.c **** 				}
 782              		.loc 1 1128 0
 783 003a 6564     		str	r5, [r4, #68]
1118:Libraries/FreeRTOS/Source/tasks.c **** 					{
 784              		.loc 1 1118 0
 785 003c 9A42     		cmp	r2, r3
1138:Libraries/FreeRTOS/Source/tasks.c **** 				{
 786              		.loc 1 1138 0
 787 003e A269     		ldr	r2, [r4, #24]
 788              	.LVL87:
1120:Libraries/FreeRTOS/Source/tasks.c **** 					}
 789              		.loc 1 1120 0
 790 0040 08BF     		it	eq
 791 0042 E562     		streq	r5, [r4, #44]
1138:Libraries/FreeRTOS/Source/tasks.c **** 				{
 792              		.loc 1 1138 0
 793 0044 002A     		cmp	r2, #0
1140:Libraries/FreeRTOS/Source/tasks.c **** 				}
 794              		.loc 1 1140 0
 795 0046 A4BF     		itt	ge
 796 0048 C5F10505 		rsbge	r5, r5, #5
 797              	.LVL88:
 798 004c A561     		strge	r5, [r4, #24]
1151:Libraries/FreeRTOS/Source/tasks.c **** 				{
 799              		.loc 1 1151 0
 800 004e 40F20005 		movw	r5, #:lower16:.LANCHOR0
 801 0052 03EB8303 		add	r3, r3, r3, lsl #2
 802              	.LVL89:
 803 0056 C0F20005 		movt	r5, #:upper16:.LANCHOR0
 804 005a 6269     		ldr	r2, [r4, #20]
 805 005c 05EB8303 		add	r3, r5, r3, lsl #2
 806 0060 9A42     		cmp	r2, r3
 807 0062 18D0     		beq	.L115
 808              	.LVL90:
 809              	.L108:
1174:Libraries/FreeRTOS/Source/tasks.c **** 				{
 810              		.loc 1 1174 0
 811 0064 8EB9     		cbnz	r6, .L116
 812              	.LVL91:
 813              	.L102:
1189:Libraries/FreeRTOS/Source/tasks.c **** 
 814              		.loc 1 1189 0
 815 0066 BDE8F840 		pop	{r3, r4, r5, r6, r7, lr}
 816              	.LVL92:
1188:Libraries/FreeRTOS/Source/tasks.c **** 	}
 817              		.loc 1 1188 0
 818 006a FFF7FEBF 		b	vPortExitCritical
 819              	.LVL93:
 820              	.L103:
1095:Libraries/FreeRTOS/Source/tasks.c **** 				{
 821              		.loc 1 1095 0
 822 006e 1E68     		ldr	r6, [r3]
 823 0070 A31B     		subs	r3, r4, r6
 824 0072 5E42     		rsbs	r6, r3, #0
 825 0074 5E41     		adcs	r6, r6, r3
 826 0076 DFE7     		b	.L104
 827              	.LVL94:
 828              	.L113:
1038:Libraries/FreeRTOS/Source/tasks.c **** 
 829              		.loc 1 1038 0 discriminator 1
 830 0078 FFF7FEFF 		bl	ulPortSetInterruptMask
 831              	.LVL95:
 832              	.L99:
 833 007c FEE7     		b	.L99
 834              	.L114:
1054:Libraries/FreeRTOS/Source/tasks.c **** 
 835              		.loc 1 1054 0 discriminator 1
 836 007e 40F20003 		movw	r3, #:lower16:.LANCHOR9
 837 0082 C0F20003 		movt	r3, #:upper16:.LANCHOR9
 838 0086 1C68     		ldr	r4, [r3]
 839              	.LVL96:
 840 0088 C3E7     		b	.L100
 841              	.LVL97:
 842              	.L116:
1176:Libraries/FreeRTOS/Source/tasks.c **** 				}
 843              		.loc 1 1176 0
 844 008a FFF7FEFF 		bl	vPortYield
 845              	.LVL98:
1189:Libraries/FreeRTOS/Source/tasks.c **** 
 846              		.loc 1 1189 0
 847 008e BDE8F840 		pop	{r3, r4, r5, r6, r7, lr}
 848              	.LVL99:
1188:Libraries/FreeRTOS/Source/tasks.c **** 	}
 849              		.loc 1 1188 0
 850 0092 FFF7FEBF 		b	vPortExitCritical
 851              	.LVL100:
 852              	.L115:
1156:Libraries/FreeRTOS/Source/tasks.c **** 					{
 853              		.loc 1 1156 0
 854 0096 271D     		adds	r7, r4, #4
 855 0098 3846     		mov	r0, r7
 856 009a FFF7FEFF 		bl	uxListRemove
 857              	.LVL101:
1167:Libraries/FreeRTOS/Source/tasks.c **** 				}
 858              		.loc 1 1167 0
 859 009e 40F20002 		movw	r2, #:lower16:.LANCHOR12
 860 00a2 C0F20002 		movt	r2, #:upper16:.LANCHOR12
 861 00a6 E36A     		ldr	r3, [r4, #44]
 862 00a8 1168     		ldr	r1, [r2]
 863 00aa 03EB8300 		add	r0, r3, r3, lsl #2
 864 00ae 8B42     		cmp	r3, r1
 865 00b0 05EB8000 		add	r0, r5, r0, lsl #2
 866 00b4 3946     		mov	r1, r7
 867 00b6 88BF     		it	hi
 868 00b8 1360     		strhi	r3, [r2]
 869 00ba FFF7FEFF 		bl	vListInsertEnd
 870              	.LVL102:
 871 00be D1E7     		b	.L108
 872              		.cfi_endproc
 873              	.LFE128:
 875              		.section	.text.vTaskSuspend,"ax",%progbits
 876              		.align	2
 877              		.global	vTaskSuspend
 878              		.thumb
 879              		.thumb_func
 881              	vTaskSuspend:
 882              	.LFB129:
1197:Libraries/FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
 883              		.loc 1 1197 0
 884              		.cfi_startproc
 885              		@ args = 0, pretend = 0, frame = 0
 886              		@ frame_needed = 0, uses_anonymous_args = 0
 887              	.LVL103:
 888 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 889              	.LCFI5:
 890              		.cfi_def_cfa_offset 24
 891              		.cfi_offset 3, -24
 892              		.cfi_offset 4, -20
 893              		.cfi_offset 5, -16
 894              		.cfi_offset 6, -12
 895              		.cfi_offset 7, -8
 896              		.cfi_offset 14, -4
1197:Libraries/FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
 897              		.loc 1 1197 0
 898 0002 0446     		mov	r4, r0
1204:Libraries/FreeRTOS/Source/tasks.c **** 
 899              		.loc 1 1204 0
 900 0004 40F20005 		movw	r5, #:lower16:.LANCHOR9
1200:Libraries/FreeRTOS/Source/tasks.c **** 		{
 901              		.loc 1 1200 0
 902 0008 FFF7FEFF 		bl	vPortEnterCritical
 903              	.LVL104:
1204:Libraries/FreeRTOS/Source/tasks.c **** 
 904              		.loc 1 1204 0
 905 000c C0F20005 		movt	r5, #:upper16:.LANCHOR9
 906 0010 002C     		cmp	r4, #0
 907 0012 51D0     		beq	.L149
 908              	.LVL105:
 909              	.L118:
1210:Libraries/FreeRTOS/Source/tasks.c **** 			{
 910              		.loc 1 1210 0 discriminator 3
 911 0014 271D     		adds	r7, r4, #4
 912 0016 3846     		mov	r0, r7
 913 0018 FFF7FEFF 		bl	uxListRemove
 914              	.LVL106:
1220:Libraries/FreeRTOS/Source/tasks.c **** 			{
 915              		.loc 1 1220 0 discriminator 3
 916 001c A36A     		ldr	r3, [r4, #40]
 917 001e 1BB1     		cbz	r3, .L119
1222:Libraries/FreeRTOS/Source/tasks.c **** 			}
 918              		.loc 1 1222 0
 919 0020 04F11800 		add	r0, r4, #24
 920 0024 FFF7FEFF 		bl	uxListRemove
 921              	.LVL107:
 922              	.L119:
1229:Libraries/FreeRTOS/Source/tasks.c **** 		}
 923              		.loc 1 1229 0
 924 0028 40F20006 		movw	r6, #:lower16:.LANCHOR5
 925 002c C0F20006 		movt	r6, #:upper16:.LANCHOR5
 926 0030 3946     		mov	r1, r7
 927 0032 3046     		mov	r0, r6
 928 0034 FFF7FEFF 		bl	vListInsertEnd
 929              	.LVL108:
1231:Libraries/FreeRTOS/Source/tasks.c **** 
 930              		.loc 1 1231 0
 931 0038 FFF7FEFF 		bl	vPortExitCritical
 932              	.LVL109:
1233:Libraries/FreeRTOS/Source/tasks.c **** 		{
 933              		.loc 1 1233 0
 934 003c 2A68     		ldr	r2, [r5]
 935 003e 40F20003 		movw	r3, #:lower16:.LANCHOR9
 936 0042 9442     		cmp	r4, r2
 937 0044 C0F20003 		movt	r3, #:upper16:.LANCHOR9
 938 0048 27D0     		beq	.L151
1262:Libraries/FreeRTOS/Source/tasks.c **** 			{
 939              		.loc 1 1262 0
 940 004a 40F20003 		movw	r3, #:lower16:.LANCHOR10
 941 004e C0F20003 		movt	r3, #:upper16:.LANCHOR10
 942 0052 1B68     		ldr	r3, [r3]
 943 0054 03B9     		cbnz	r3, .L152
 944 0056 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 945              	.LVL110:
 946              	.L152:
1267:Libraries/FreeRTOS/Source/tasks.c **** 				{
 947              		.loc 1 1267 0
 948 0058 FFF7FEFF 		bl	vPortEnterCritical
 949              	.LVL111:
 950              	.LBB57:
 951              	.LBB58:
3108:Libraries/FreeRTOS/Source/tasks.c **** 	{
 952              		.loc 1 3108 0
 953 005c 40F20003 		movw	r3, #:lower16:.LANCHOR6
 954 0060 C0F20003 		movt	r3, #:upper16:.LANCHOR6
 955 0064 1A68     		ldr	r2, [r3]
 956 0066 1268     		ldr	r2, [r2]
 957 0068 52B9     		cbnz	r2, .L153
3115:Libraries/FreeRTOS/Source/tasks.c **** 	}
 958              		.loc 1 3115 0
 959 006a 40F20003 		movw	r3, #:lower16:.LANCHOR15
 960 006e C0F20003 		movt	r3, #:upper16:.LANCHOR15
 961 0072 4FF0FF32 		mov	r2, #-1
 962 0076 1A60     		str	r2, [r3]
 963              	.LBE58:
 964              	.LBE57:
1278:Libraries/FreeRTOS/Source/tasks.c **** 
 965              		.loc 1 1278 0
 966 0078 BDE8F840 		pop	{r3, r4, r5, r6, r7, lr}
 967              	.LVL112:
1271:Libraries/FreeRTOS/Source/tasks.c **** 			}
 968              		.loc 1 1271 0
 969 007c FFF7FEBF 		b	vPortExitCritical
 970              	.LVL113:
 971              	.L153:
 972              	.LBB62:
 973              	.LBB61:
 974              	.LBB59:
 975              	.LBB60:
3123:Libraries/FreeRTOS/Source/tasks.c **** 		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
 976              		.loc 1 3123 0
 977 0080 1B68     		ldr	r3, [r3]
 978              	.LVL114:
 979 0082 DB68     		ldr	r3, [r3, #12]
 980              	.LVL115:
 981              		.loc 1 3124 0
 982 0084 DA68     		ldr	r2, [r3, #12]
 983 0086 40F20003 		movw	r3, #:lower16:.LANCHOR15
 984              	.LVL116:
 985 008a C0F20003 		movt	r3, #:upper16:.LANCHOR15
 986 008e 5268     		ldr	r2, [r2, #4]
 987              	.LVL117:
 988 0090 1A60     		str	r2, [r3]
 989              	.LBE60:
 990              	.LBE59:
 991              	.LBE61:
 992              	.LBE62:
1278:Libraries/FreeRTOS/Source/tasks.c **** 
 993              		.loc 1 1278 0
 994 0092 BDE8F840 		pop	{r3, r4, r5, r6, r7, lr}
 995              	.LVL118:
1271:Libraries/FreeRTOS/Source/tasks.c **** 			}
 996              		.loc 1 1271 0
 997 0096 FFF7FEBF 		b	vPortExitCritical
 998              	.LVL119:
 999              	.L151:
1235:Libraries/FreeRTOS/Source/tasks.c **** 			{
 1000              		.loc 1 1235 0
 1001 009a 40F20002 		movw	r2, #:lower16:.LANCHOR10
 1002 009e C0F20002 		movt	r2, #:upper16:.LANCHOR10
 1003 00a2 1168     		ldr	r1, [r2]
 1004 00a4 51B1     		cbz	r1, .L121
1238:Libraries/FreeRTOS/Source/tasks.c **** 				portYIELD_WITHIN_API();
 1005              		.loc 1 1238 0
 1006 00a6 40F20003 		movw	r3, #:lower16:.LANCHOR14
 1007 00aa C0F20003 		movt	r3, #:upper16:.LANCHOR14
 1008 00ae 1B68     		ldr	r3, [r3]
 1009 00b0 73B1     		cbz	r3, .L122
1238:Libraries/FreeRTOS/Source/tasks.c **** 				portYIELD_WITHIN_API();
 1010              		.loc 1 1238 0 is_stmt 0 discriminator 1
 1011 00b2 FFF7FEFF 		bl	ulPortSetInterruptMask
 1012              	.LVL120:
 1013              	.L123:
 1014 00b6 FEE7     		b	.L123
 1015              	.LVL121:
 1016              	.L149:
1204:Libraries/FreeRTOS/Source/tasks.c **** 
 1017              		.loc 1 1204 0 is_stmt 1 discriminator 1
 1018 00b8 2C68     		ldr	r4, [r5]
 1019              	.LVL122:
 1020 00ba ABE7     		b	.L118
 1021              	.LVL123:
 1022              	.L121:
1246:Libraries/FreeRTOS/Source/tasks.c **** 				{
 1023              		.loc 1 1246 0
 1024 00bc 40F20002 		movw	r2, #:lower16:.LANCHOR8
 1025 00c0 C0F20002 		movt	r2, #:upper16:.LANCHOR8
 1026 00c4 3068     		ldr	r0, [r6]
 1027 00c6 1268     		ldr	r2, [r2]
 1028 00c8 9042     		cmp	r0, r2
 1029 00ca 05D1     		bne	.L124
1252:Libraries/FreeRTOS/Source/tasks.c **** 				}
 1030              		.loc 1 1252 0
 1031 00cc 1960     		str	r1, [r3]
 1032 00ce F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1033              	.LVL124:
 1034              	.L122:
1278:Libraries/FreeRTOS/Source/tasks.c **** 
 1035              		.loc 1 1278 0
 1036 00d0 BDE8F840 		pop	{r3, r4, r5, r6, r7, lr}
 1037              	.LVL125:
1239:Libraries/FreeRTOS/Source/tasks.c **** 			}
 1038              		.loc 1 1239 0
 1039 00d4 FFF7FEBF 		b	vPortYield
 1040              	.LVL126:
 1041              	.L124:
 1042              	.LBB63:
 1043              	.LBB64:
2116:Libraries/FreeRTOS/Source/tasks.c **** 	{
 1044              		.loc 1 2116 0
 1045 00d8 40F20003 		movw	r3, #:lower16:.LANCHOR14
 1046 00dc C0F20003 		movt	r3, #:upper16:.LANCHOR14
 1047 00e0 1968     		ldr	r1, [r3]
 1048 00e2 0029     		cmp	r1, #0
 1049 00e4 33D1     		bne	.L154
2124:Libraries/FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_OUT();
 1050              		.loc 1 2124 0
 1051 00e6 40F20002 		movw	r2, #:lower16:.LANCHOR16
 1052 00ea C0F20002 		movt	r2, #:upper16:.LANCHOR16
2157:Libraries/FreeRTOS/Source/tasks.c **** 
 1053              		.loc 1 2157 0
 1054 00ee 40F20003 		movw	r3, #:lower16:.LANCHOR12
 1055 00f2 C0F20003 		movt	r3, #:upper16:.LANCHOR12
2124:Libraries/FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_OUT();
 1056              		.loc 1 2124 0
 1057 00f6 1160     		str	r1, [r2]
2157:Libraries/FreeRTOS/Source/tasks.c **** 
 1058              		.loc 1 2157 0
 1059 00f8 1968     		ldr	r1, [r3]
 1060 00fa 40F20002 		movw	r2, #:lower16:.LANCHOR0
 1061 00fe 01EB8101 		add	r1, r1, r1, lsl #2
 1062 0102 C0F20002 		movt	r2, #:upper16:.LANCHOR0
 1063 0106 52F82110 		ldr	r1, [r2, r1, lsl #2]
 1064 010a 79B9     		cbnz	r1, .L135
 1065 010c 1968     		ldr	r1, [r3]
 1066 010e 1846     		mov	r0, r3
 1067 0110 11B9     		cbnz	r1, .L133
 1068 0112 23E0     		b	.L132
 1069              	.L134:
 1070 0114 0168     		ldr	r1, [r0]
 1071 0116 09B3     		cbz	r1, .L132
 1072              	.L133:
 1073 0118 1968     		ldr	r1, [r3]
 1074 011a 0139     		subs	r1, r1, #1
 1075 011c 1960     		str	r1, [r3]
 1076 011e 1968     		ldr	r1, [r3]
 1077 0120 01EB8101 		add	r1, r1, r1, lsl #2
 1078 0124 52F82110 		ldr	r1, [r2, r1, lsl #2]
 1079 0128 0029     		cmp	r1, #0
 1080 012a F3D0     		beq	.L134
 1081              	.L135:
 1082              	.LBB65:
 1083 012c 1B68     		ldr	r3, [r3]
 1084 012e 03EB8303 		add	r3, r3, r3, lsl #2
 1085 0132 02EB8302 		add	r2, r2, r3, lsl #2
 1086              	.LVL127:
 1087 0136 02F10801 		add	r1, r2, #8
 1088 013a 5368     		ldr	r3, [r2, #4]
 1089 013c 5B68     		ldr	r3, [r3, #4]
 1090 013e 8B42     		cmp	r3, r1
 1091 0140 5360     		str	r3, [r2, #4]
 1092 0142 01D1     		bne	.L129
 1093 0144 5B68     		ldr	r3, [r3, #4]
 1094 0146 5360     		str	r3, [r2, #4]
 1095              	.L129:
 1096 0148 DB68     		ldr	r3, [r3, #12]
 1097 014a 2B60     		str	r3, [r5]
 1098 014c F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1099              	.LVL128:
 1100              	.L154:
 1101              	.LBE65:
2120:Libraries/FreeRTOS/Source/tasks.c **** 	}
 1102              		.loc 1 2120 0
 1103 014e 40F20003 		movw	r3, #:lower16:.LANCHOR16
 1104 0152 C0F20003 		movt	r3, #:upper16:.LANCHOR16
 1105 0156 0122     		movs	r2, #1
 1106 0158 1A60     		str	r2, [r3]
 1107 015a F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1108              	.LVL129:
 1109              	.L132:
2157:Libraries/FreeRTOS/Source/tasks.c **** 
 1110              		.loc 1 2157 0
 1111 015c FFF7FEFF 		bl	ulPortSetInterruptMask
 1112              	.LVL130:
 1113              	.L131:
 1114 0160 FEE7     		b	.L131
 1115              	.LBE64:
 1116              	.LBE63:
 1117              		.cfi_endproc
 1118              	.LFE129:
 1120 0162 00BF     		.section	.text.vTaskResume,"ax",%progbits
 1121              		.align	2
 1122              		.global	vTaskResume
 1123              		.thumb
 1124              		.thumb_func
 1126              	vTaskResume:
 1127              	.LFB131:
1332:Libraries/FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
 1128              		.loc 1 1332 0
 1129              		.cfi_startproc
 1130              		@ args = 0, pretend = 0, frame = 0
 1131              		@ frame_needed = 0, uses_anonymous_args = 0
 1132              	.LVL131:
 1133 0000 70B5     		push	{r4, r5, r6, lr}
 1134              	.LCFI6:
 1135              		.cfi_def_cfa_offset 16
 1136              		.cfi_offset 4, -16
 1137              		.cfi_offset 5, -12
 1138              		.cfi_offset 6, -8
 1139              		.cfi_offset 14, -4
1336:Libraries/FreeRTOS/Source/tasks.c **** 
 1140              		.loc 1 1336 0
 1141 0002 0446     		mov	r4, r0
 1142 0004 A0B1     		cbz	r0, .L164
1340:Libraries/FreeRTOS/Source/tasks.c **** 		{
 1143              		.loc 1 1340 0 discriminator 1
 1144 0006 40F20005 		movw	r5, #:lower16:.LANCHOR9
 1145 000a C0F20005 		movt	r5, #:upper16:.LANCHOR9
 1146 000e 2B68     		ldr	r3, [r5]
 1147 0010 9842     		cmp	r0, r3
 1148 0012 0CD0     		beq	.L155
1342:Libraries/FreeRTOS/Source/tasks.c **** 			{
 1149              		.loc 1 1342 0
 1150 0014 FFF7FEFF 		bl	vPortEnterCritical
 1151              	.LVL132:
 1152              	.LBB70:
 1153              	.LBB71:
1297:Libraries/FreeRTOS/Source/tasks.c **** 		{
 1154              		.loc 1 1297 0
 1155 0018 40F20003 		movw	r3, #:lower16:.LANCHOR5
 1156 001c 6269     		ldr	r2, [r4, #20]
 1157 001e C0F20003 		movt	r3, #:upper16:.LANCHOR5
 1158 0022 9A42     		cmp	r2, r3
 1159 0024 07D0     		beq	.L165
 1160              	.LVL133:
 1161              	.L160:
 1162              	.LBE71:
 1163              	.LBE70:
1377:Libraries/FreeRTOS/Source/tasks.c **** 
 1164              		.loc 1 1377 0 discriminator 2
 1165 0026 BDE87040 		pop	{r4, r5, r6, lr}
 1166              	.LVL134:
1371:Libraries/FreeRTOS/Source/tasks.c **** 		}
 1167              		.loc 1 1371 0 discriminator 2
 1168 002a FFF7FEBF 		b	vPortExitCritical
 1169              	.LVL135:
 1170              	.L155:
 1171 002e 70BD     		pop	{r4, r5, r6, pc}
 1172              	.L164:
1336:Libraries/FreeRTOS/Source/tasks.c **** 
 1173              		.loc 1 1336 0 discriminator 1
 1174 0030 FFF7FEFF 		bl	ulPortSetInterruptMask
 1175              	.LVL136:
 1176              	.L157:
 1177 0034 FEE7     		b	.L157
 1178              	.LVL137:
 1179              	.L165:
 1180              	.LBB75:
 1181              	.LBB74:
 1182              	.LBB72:
 1183              	.LBB73:
1300:Libraries/FreeRTOS/Source/tasks.c **** 			{
 1184              		.loc 1 1300 0
 1185 0036 40F20003 		movw	r3, #:lower16:.LANCHOR3
 1186 003a A26A     		ldr	r2, [r4, #40]
 1187 003c C0F20003 		movt	r3, #:upper16:.LANCHOR3
 1188 0040 9A42     		cmp	r2, r3
 1189 0042 F0D0     		beq	.L160
 1190              	.LVL138:
 1191              	.LBE73:
 1192              	.LBE72:
 1193              	.LBE74:
 1194              	.LBE75:
1344:Libraries/FreeRTOS/Source/tasks.c **** 				{
 1195              		.loc 1 1344 0
 1196 0044 002A     		cmp	r2, #0
 1197 0046 EED1     		bne	.L160
1350:Libraries/FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1198              		.loc 1 1350 0
 1199 0048 261D     		adds	r6, r4, #4
 1200 004a 3046     		mov	r0, r6
 1201 004c FFF7FEFF 		bl	uxListRemove
 1202              	.LVL139:
1351:Libraries/FreeRTOS/Source/tasks.c **** 
 1203              		.loc 1 1351 0
 1204 0050 40F20002 		movw	r2, #:lower16:.LANCHOR12
 1205 0054 C0F20002 		movt	r2, #:upper16:.LANCHOR12
 1206 0058 E36A     		ldr	r3, [r4, #44]
 1207 005a 1168     		ldr	r1, [r2]
 1208 005c 40F20000 		movw	r0, #:lower16:.LANCHOR0
 1209 0060 8B42     		cmp	r3, r1
 1210 0062 88BF     		it	hi
 1211 0064 1360     		strhi	r3, [r2]
 1212 0066 C0F20000 		movt	r0, #:upper16:.LANCHOR0
 1213 006a 03EB8303 		add	r3, r3, r3, lsl #2
 1214 006e 00EB8300 		add	r0, r0, r3, lsl #2
 1215 0072 3146     		mov	r1, r6
 1216 0074 FFF7FEFF 		bl	vListInsertEnd
 1217              	.LVL140:
1354:Libraries/FreeRTOS/Source/tasks.c **** 					{
 1218              		.loc 1 1354 0
 1219 0078 2B68     		ldr	r3, [r5]
 1220 007a E26A     		ldr	r2, [r4, #44]
 1221 007c DB6A     		ldr	r3, [r3, #44]
 1222 007e 9A42     		cmp	r2, r3
 1223 0080 D1D3     		bcc	.L160
1359:Libraries/FreeRTOS/Source/tasks.c **** 					}
 1224              		.loc 1 1359 0
 1225 0082 FFF7FEFF 		bl	vPortYield
 1226              	.LVL141:
 1227 0086 CEE7     		b	.L160
 1228              		.cfi_endproc
 1229              	.LFE131:
 1231              		.section	.text.xTaskResumeFromISR,"ax",%progbits
 1232              		.align	2
 1233              		.global	xTaskResumeFromISR
 1234              		.thumb
 1235              		.thumb_func
 1237              	xTaskResumeFromISR:
 1238              	.LFB132:
1386:Libraries/FreeRTOS/Source/tasks.c **** 	BaseType_t xYieldRequired = pdFALSE;
 1239              		.loc 1 1386 0
 1240              		.cfi_startproc
 1241              		@ args = 0, pretend = 0, frame = 0
 1242              		@ frame_needed = 0, uses_anonymous_args = 0
 1243              	.LVL142:
 1244 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1245              	.LCFI7:
 1246              		.cfi_def_cfa_offset 24
 1247              		.cfi_offset 3, -24
 1248              		.cfi_offset 4, -20
 1249              		.cfi_offset 5, -16
 1250              		.cfi_offset 6, -12
 1251              		.cfi_offset 7, -8
 1252              		.cfi_offset 14, -4
1391:Libraries/FreeRTOS/Source/tasks.c **** 
 1253              		.loc 1 1391 0
 1254 0002 0446     		mov	r4, r0
 1255 0004 88B1     		cbz	r0, .L177
1409:Libraries/FreeRTOS/Source/tasks.c **** 
 1256              		.loc 1 1409 0
 1257 0006 FFF7FEFF 		bl	vPortValidateInterruptPriority
 1258              	.LVL143:
1411:Libraries/FreeRTOS/Source/tasks.c **** 		{
 1259              		.loc 1 1411 0
 1260 000a FFF7FEFF 		bl	ulPortSetInterruptMask
 1261              	.LVL144:
 1262              	.LBB80:
 1263              	.LBB81:
1297:Libraries/FreeRTOS/Source/tasks.c **** 		{
 1264              		.loc 1 1297 0
 1265 000e 40F20003 		movw	r3, #:lower16:.LANCHOR5
 1266 0012 6269     		ldr	r2, [r4, #20]
 1267 0014 C0F20003 		movt	r3, #:upper16:.LANCHOR5
 1268 0018 9A42     		cmp	r2, r3
 1269              	.LBE81:
 1270              	.LBE80:
1411:Libraries/FreeRTOS/Source/tasks.c **** 		{
 1271              		.loc 1 1411 0
 1272 001a 0646     		mov	r6, r0
 1273              	.LVL145:
 1274              	.LBB86:
 1275              	.LBB84:
1297:Libraries/FreeRTOS/Source/tasks.c **** 		{
 1276              		.loc 1 1297 0
 1277 001c 08D0     		beq	.L169
 1278              	.LVL146:
 1279              	.L176:
 1280              	.LBE84:
 1281              	.LBE86:
1447:Libraries/FreeRTOS/Source/tasks.c **** 
 1282              		.loc 1 1447 0
 1283 001e 3046     		mov	r0, r6
1387:Libraries/FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
 1284              		.loc 1 1387 0
 1285 0020 0025     		movs	r5, #0
 1286              	.LVL147:
1447:Libraries/FreeRTOS/Source/tasks.c **** 
 1287              		.loc 1 1447 0
 1288 0022 FFF7FEFF 		bl	vPortClearInterruptMask
 1289              	.LVL148:
1450:Libraries/FreeRTOS/Source/tasks.c **** 
 1290              		.loc 1 1450 0
 1291 0026 2846     		mov	r0, r5
 1292 0028 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1293              	.LVL149:
 1294              	.L177:
1391:Libraries/FreeRTOS/Source/tasks.c **** 
 1295              		.loc 1 1391 0 discriminator 1
 1296 002a FFF7FEFF 		bl	ulPortSetInterruptMask
 1297              	.LVL150:
 1298              	.L168:
 1299 002e FEE7     		b	.L168
 1300              	.LVL151:
 1301              	.L169:
 1302              	.LBB87:
 1303              	.LBB85:
 1304              	.LBB82:
 1305              	.LBB83:
1300:Libraries/FreeRTOS/Source/tasks.c **** 			{
 1306              		.loc 1 1300 0
 1307 0030 40F20000 		movw	r0, #:lower16:.LANCHOR3
 1308              	.LVL152:
 1309 0034 A56A     		ldr	r5, [r4, #40]
 1310 0036 C0F20000 		movt	r0, #:upper16:.LANCHOR3
 1311 003a 8542     		cmp	r5, r0
 1312 003c EFD0     		beq	.L176
 1313              	.LVL153:
 1314              	.LBE83:
 1315              	.LBE82:
 1316              	.LBE85:
 1317              	.LBE87:
1413:Libraries/FreeRTOS/Source/tasks.c **** 			{
 1318              		.loc 1 1413 0
 1319 003e 002D     		cmp	r5, #0
 1320 0040 EDD1     		bne	.L176
1418:Libraries/FreeRTOS/Source/tasks.c **** 				{
 1321              		.loc 1 1418 0
 1322 0042 40F20002 		movw	r2, #:lower16:.LANCHOR14
 1323 0046 C0F20002 		movt	r2, #:upper16:.LANCHOR14
 1324 004a 1268     		ldr	r2, [r2]
 1325 004c 3ABB     		cbnz	r2, .L171
1422:Libraries/FreeRTOS/Source/tasks.c **** 					{
 1326              		.loc 1 1422 0
 1327 004e 40F20003 		movw	r3, #:lower16:.LANCHOR9
 1328 0052 C0F20003 		movt	r3, #:upper16:.LANCHOR9
 1329 0056 E26A     		ldr	r2, [r4, #44]
 1330 0058 1B68     		ldr	r3, [r3]
 1331 005a DD6A     		ldr	r5, [r3, #44]
 1332              	.LVL154:
1431:Libraries/FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1333              		.loc 1 1431 0
 1334 005c 271D     		adds	r7, r4, #4
1422:Libraries/FreeRTOS/Source/tasks.c **** 					{
 1335              		.loc 1 1422 0
 1336 005e AA42     		cmp	r2, r5
1431:Libraries/FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1337              		.loc 1 1431 0
 1338 0060 3846     		mov	r0, r7
1422:Libraries/FreeRTOS/Source/tasks.c **** 					{
 1339              		.loc 1 1422 0
 1340 0062 34BF     		ite	cc
 1341 0064 0025     		movcc	r5, #0
 1342 0066 0125     		movcs	r5, #1
 1343              	.LVL155:
1431:Libraries/FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1344              		.loc 1 1431 0
 1345 0068 FFF7FEFF 		bl	uxListRemove
 1346              	.LVL156:
1432:Libraries/FreeRTOS/Source/tasks.c **** 				}
 1347              		.loc 1 1432 0
 1348 006c 40F20002 		movw	r2, #:lower16:.LANCHOR12
 1349 0070 C0F20002 		movt	r2, #:upper16:.LANCHOR12
 1350 0074 E36A     		ldr	r3, [r4, #44]
 1351 0076 1168     		ldr	r1, [r2]
 1352 0078 40F20000 		movw	r0, #:lower16:.LANCHOR0
 1353 007c 8B42     		cmp	r3, r1
 1354 007e 88BF     		it	hi
 1355 0080 1360     		strhi	r3, [r2]
 1356 0082 C0F20000 		movt	r0, #:upper16:.LANCHOR0
 1357 0086 03EB8303 		add	r3, r3, r3, lsl #2
 1358 008a 00EB8300 		add	r0, r0, r3, lsl #2
 1359 008e 3946     		mov	r1, r7
 1360 0090 FFF7FEFF 		bl	vListInsertEnd
 1361              	.LVL157:
1447:Libraries/FreeRTOS/Source/tasks.c **** 
 1362              		.loc 1 1447 0
 1363 0094 3046     		mov	r0, r6
 1364 0096 FFF7FEFF 		bl	vPortClearInterruptMask
 1365              	.LVL158:
1450:Libraries/FreeRTOS/Source/tasks.c **** 
 1366              		.loc 1 1450 0
 1367 009a 2846     		mov	r0, r5
 1368 009c F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1369              	.LVL159:
 1370              	.L171:
1439:Libraries/FreeRTOS/Source/tasks.c **** 				}
 1371              		.loc 1 1439 0
 1372 009e 04F11801 		add	r1, r4, #24
 1373 00a2 FFF7FEFF 		bl	vListInsertEnd
 1374              	.LVL160:
1447:Libraries/FreeRTOS/Source/tasks.c **** 
 1375              		.loc 1 1447 0
 1376 00a6 3046     		mov	r0, r6
 1377 00a8 FFF7FEFF 		bl	vPortClearInterruptMask
 1378              	.LVL161:
1450:Libraries/FreeRTOS/Source/tasks.c **** 
 1379              		.loc 1 1450 0
 1380 00ac 2846     		mov	r0, r5
 1381 00ae F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1382              		.cfi_endproc
 1383              	.LFE132:
 1385              		.section	.text.vTaskStartScheduler,"ax",%progbits
 1386              		.align	2
 1387              		.global	vTaskStartScheduler
 1388              		.thumb
 1389              		.thumb_func
 1391              	vTaskStartScheduler:
 1392              	.LFB133:
1456:Libraries/FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
 1393              		.loc 1 1456 0
 1394              		.cfi_startproc
 1395              		@ args = 0, pretend = 0, frame = 0
 1396              		@ frame_needed = 0, uses_anonymous_args = 0
 1397              	.LVL162:
 1398 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1399              	.LCFI8:
 1400              		.cfi_def_cfa_offset 24
 1401              		.cfi_offset 3, -24
 1402              		.cfi_offset 4, -20
 1403              		.cfi_offset 5, -16
 1404              		.cfi_offset 6, -12
 1405              		.cfi_offset 7, -8
 1406              		.cfi_offset 14, -4
 1407              	.LBB95:
 1408              	.LBB96:
 1409              	.LBB97:
 1410              	.LBB98:
2917:Libraries/FreeRTOS/Source/tasks.c **** 
 1411              		.loc 1 2917 0
 1412 0002 4820     		movs	r0, #72
 1413 0004 FFF7FEFF 		bl	pvPortMalloc
 1414              	.LVL163:
2919:Libraries/FreeRTOS/Source/tasks.c **** 	{
 1415              		.loc 1 2919 0
 1416 0008 0446     		mov	r4, r0
 1417 000a 0028     		cmp	r0, #0
 1418 000c 00F08180 		beq	.L178
2924:Libraries/FreeRTOS/Source/tasks.c **** 
 1419              		.loc 1 2924 0
 1420 0010 4FF48060 		mov	r0, #1024
 1421              	.LVL164:
 1422 0014 FFF7FEFF 		bl	pvPortMalloc
 1423              	.LVL165:
 1424 0018 2063     		str	r0, [r4, #48]
2926:Libraries/FreeRTOS/Source/tasks.c **** 		{
 1425              		.loc 1 2926 0
 1426 001a 0028     		cmp	r0, #0
 1427 001c 7DD0     		beq	.L201
 1428              	.LVL166:
 1429              	.LBE98:
 1430              	.LBE97:
 1431              	.LBB101:
 1432              	.LBB102:
 1433              	.LBB103:
2707:Libraries/FreeRTOS/Source/tasks.c **** 
 1434              		.loc 1 2707 0
 1435 001e 4FF0490E 		mov	lr, #73
 1436 0022 0025     		movs	r5, #0
 1437 0024 4421     		movs	r1, #68
 1438 0026 4C22     		movs	r2, #76
 1439 0028 4523     		movs	r3, #69
2744:Libraries/FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 1440              		.loc 1 2744 0
 1441 002a 271D     		adds	r7, r4, #4
2707:Libraries/FreeRTOS/Source/tasks.c **** 
 1442              		.loc 1 2707 0
 1443 002c 84F834E0 		strb	lr, [r4, #52]
 1444 0030 84F83510 		strb	r1, [r4, #53]
 1445 0034 84F83620 		strb	r2, [r4, #54]
 1446 0038 84F83730 		strb	r3, [r4, #55]
 1447              	.LBE103:
 1448              	.LBE102:
 552:Libraries/FreeRTOS/Source/tasks.c **** 			pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINTER_
 1449              		.loc 1 552 0
 1450 003c 00F57F76 		add	r6, r0, #1020
 1451              	.LVL167:
 1452              	.LBB108:
 1453              	.LBB104:
2707:Libraries/FreeRTOS/Source/tasks.c **** 
 1454              		.loc 1 2707 0
 1455 0040 84F83850 		strb	r5, [r4, #56]
2744:Libraries/FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 1456              		.loc 1 2744 0
 1457 0044 3846     		mov	r0, r7
2724:Libraries/FreeRTOS/Source/tasks.c **** 
 1458              		.loc 1 2724 0
 1459 0046 84F84350 		strb	r5, [r4, #67]
2737:Libraries/FreeRTOS/Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 1460              		.loc 1 2737 0
 1461 004a E562     		str	r5, [r4, #44]
2740:Libraries/FreeRTOS/Source/tasks.c **** 	}
 1462              		.loc 1 2740 0
 1463 004c 6564     		str	r5, [r4, #68]
2744:Libraries/FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 1464              		.loc 1 2744 0
 1465 004e FFF7FEFF 		bl	vListInitialiseItem
 1466              	.LVL168:
2745:Libraries/FreeRTOS/Source/tasks.c **** 
 1467              		.loc 1 2745 0
 1468 0052 04F11800 		add	r0, r4, #24
 1469 0056 FFF7FEFF 		bl	vListInitialiseItem
 1470              	.LVL169:
 1471              	.LBE104:
 1472              	.LBE108:
 553:Libraries/FreeRTOS/Source/tasks.c **** 
 1473              		.loc 1 553 0
 1474 005a 26F00706 		bic	r6, r6, #7
 1475              	.LVL170:
 1476              	.LBB109:
 1477              	.LBB105:
2752:Libraries/FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 1478              		.loc 1 2752 0
 1479 005e 0523     		movs	r3, #5
 1480              	.LBE105:
 1481              	.LBE109:
 585:Libraries/FreeRTOS/Source/tasks.c **** 		}
 1482              		.loc 1 585 0
 1483 0060 40F20001 		movw	r1, #:lower16:prvIdleTask
 1484 0064 2A46     		mov	r2, r5
 1485              	.LBB110:
 1486              	.LBB106:
2752:Libraries/FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 1487              		.loc 1 2752 0
 1488 0066 A361     		str	r3, [r4, #24]
 1489              	.LBE106:
 1490              	.LBE110:
 585:Libraries/FreeRTOS/Source/tasks.c **** 		}
 1491              		.loc 1 585 0
 1492 0068 3046     		mov	r0, r6
 1493 006a C0F20001 		movt	r1, #:upper16:prvIdleTask
 1494              	.LBB111:
 1495              	.LBB107:
2749:Libraries/FreeRTOS/Source/tasks.c **** 
 1496              		.loc 1 2749 0
 1497 006e 2461     		str	r4, [r4, #16]
2753:Libraries/FreeRTOS/Source/tasks.c **** 
 1498              		.loc 1 2753 0
 1499 0070 6462     		str	r4, [r4, #36]
 1500              	.LBE107:
 1501              	.LBE111:
 585:Libraries/FreeRTOS/Source/tasks.c **** 		}
 1502              		.loc 1 585 0
 1503 0072 FFF7FEFF 		bl	pxPortInitialiseStack
 1504              	.LVL171:
 1505 0076 2060     		str	r0, [r4]
 603:Libraries/FreeRTOS/Source/tasks.c **** 		{
 1506              		.loc 1 603 0
 1507 0078 FFF7FEFF 		bl	vPortEnterCritical
 1508              	.LVL172:
 605:Libraries/FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB == NULL )
 1509              		.loc 1 605 0
 1510 007c 40F20003 		movw	r3, #:lower16:.LANCHOR8
 1511 0080 C0F20003 		movt	r3, #:upper16:.LANCHOR8
 606:Libraries/FreeRTOS/Source/tasks.c **** 			{
 1512              		.loc 1 606 0
 1513 0084 40F20006 		movw	r6, #:lower16:.LANCHOR9
 1514              	.LVL173:
 605:Libraries/FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB == NULL )
 1515              		.loc 1 605 0
 1516 0088 1A68     		ldr	r2, [r3]
 606:Libraries/FreeRTOS/Source/tasks.c **** 			{
 1517              		.loc 1 606 0
 1518 008a C0F20006 		movt	r6, #:upper16:.LANCHOR9
 605:Libraries/FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB == NULL )
 1519              		.loc 1 605 0
 1520 008e 0132     		adds	r2, r2, #1
 1521 0090 1A60     		str	r2, [r3]
 606:Libraries/FreeRTOS/Source/tasks.c **** 			{
 1522              		.loc 1 606 0
 1523 0092 3268     		ldr	r2, [r6]
 1524 0094 002A     		cmp	r2, #0
 1525 0096 45D0     		beq	.L202
 629:Libraries/FreeRTOS/Source/tasks.c **** 				{
 1526              		.loc 1 629 0
 1527 0098 40F20005 		movw	r5, #:lower16:.LANCHOR10
 1528 009c C0F20005 		movt	r5, #:upper16:.LANCHOR10
 1529 00a0 2B68     		ldr	r3, [r5]
 1530 00a2 1BB9     		cbnz	r3, .L182
 631:Libraries/FreeRTOS/Source/tasks.c **** 					{
 1531              		.loc 1 631 0
 1532 00a4 3368     		ldr	r3, [r6]
 1533 00a6 DB6A     		ldr	r3, [r3, #44]
 1534 00a8 03B9     		cbnz	r3, .L182
 633:Libraries/FreeRTOS/Source/tasks.c **** 					}
 1535              		.loc 1 633 0
 1536 00aa 3460     		str	r4, [r6]
 1537              	.L182:
 646:Libraries/FreeRTOS/Source/tasks.c **** 
 1538              		.loc 1 646 0
 1539 00ac 40F20001 		movw	r1, #:lower16:.LANCHOR11
 1540 00b0 C0F20001 		movt	r1, #:upper16:.LANCHOR11
 656:Libraries/FreeRTOS/Source/tasks.c **** 
 1541              		.loc 1 656 0
 1542 00b4 40F20002 		movw	r2, #:lower16:.LANCHOR12
 1543 00b8 C0F20002 		movt	r2, #:upper16:.LANCHOR12
 646:Libraries/FreeRTOS/Source/tasks.c **** 
 1544              		.loc 1 646 0
 1545 00bc 0868     		ldr	r0, [r1]
 656:Libraries/FreeRTOS/Source/tasks.c **** 
 1546              		.loc 1 656 0
 1547 00be E36A     		ldr	r3, [r4, #44]
 1548 00c0 1468     		ldr	r4, [r2]
 1549              	.LVL174:
 646:Libraries/FreeRTOS/Source/tasks.c **** 
 1550              		.loc 1 646 0
 1551 00c2 0130     		adds	r0, r0, #1
 656:Libraries/FreeRTOS/Source/tasks.c **** 
 1552              		.loc 1 656 0
 1553 00c4 A342     		cmp	r3, r4
 646:Libraries/FreeRTOS/Source/tasks.c **** 
 1554              		.loc 1 646 0
 1555 00c6 0860     		str	r0, [r1]
 656:Libraries/FreeRTOS/Source/tasks.c **** 
 1556              		.loc 1 656 0
 1557 00c8 40F20000 		movw	r0, #:lower16:.LANCHOR0
 1558 00cc 88BF     		it	hi
 1559 00ce 1360     		strhi	r3, [r2]
 1560 00d0 C0F20000 		movt	r0, #:upper16:.LANCHOR0
 1561 00d4 03EB8303 		add	r3, r3, r3, lsl #2
 1562 00d8 00EB8300 		add	r0, r0, r3, lsl #2
 1563 00dc 3946     		mov	r1, r7
 1564 00de FFF7FEFF 		bl	vListInsertEnd
 1565              	.LVL175:
 661:Libraries/FreeRTOS/Source/tasks.c **** 	}
 1566              		.loc 1 661 0
 1567 00e2 FFF7FEFF 		bl	vPortExitCritical
 1568              	.LVL176:
 1569              	.LBE101:
 671:Libraries/FreeRTOS/Source/tasks.c **** 		{
 1570              		.loc 1 671 0
 1571 00e6 2B68     		ldr	r3, [r5]
 1572 00e8 03B1     		cbz	r3, .L185
 675:Libraries/FreeRTOS/Source/tasks.c **** 			{
 1573              		.loc 1 675 0
 1574 00ea 3368     		ldr	r3, [r6]
 1575              	.L185:
 1576              	.LBE96:
 1577              	.LBE95:
1477:Libraries/FreeRTOS/Source/tasks.c **** 		}
 1578              		.loc 1 1477 0
 1579 00ec FFF7FEFF 		bl	xTimerCreateTimerTask
 1580              	.LVL177:
1486:Libraries/FreeRTOS/Source/tasks.c **** 	{
 1581              		.loc 1 1486 0
 1582 00f0 0128     		cmp	r0, #1
1477:Libraries/FreeRTOS/Source/tasks.c **** 		}
 1583              		.loc 1 1477 0
 1584 00f2 0446     		mov	r4, r0
 1585              	.LVL178:
1486:Libraries/FreeRTOS/Source/tasks.c **** 	{
 1586              		.loc 1 1486 0
 1587 00f4 0CD1     		bne	.L203
1493:Libraries/FreeRTOS/Source/tasks.c **** 
 1588              		.loc 1 1493 0
 1589 00f6 FFF7FEFF 		bl	ulPortSetInterruptMask
 1590              	.LVL179:
1504:Libraries/FreeRTOS/Source/tasks.c **** 
 1591              		.loc 1 1504 0
 1592 00fa 40F20003 		movw	r3, #:lower16:.LANCHOR17
 1593 00fe C0F20003 		movt	r3, #:upper16:.LANCHOR17
 1594 0102 0022     		movs	r2, #0
1503:Libraries/FreeRTOS/Source/tasks.c **** 		xTickCount = ( TickType_t ) 0U;
 1595              		.loc 1 1503 0
 1596 0104 2C60     		str	r4, [r5]
1504:Libraries/FreeRTOS/Source/tasks.c **** 
 1597              		.loc 1 1504 0
 1598 0106 1A60     		str	r2, [r3]
1530:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1599              		.loc 1 1530 0
 1600 0108 BDE8F840 		pop	{r3, r4, r5, r6, r7, lr}
 1601              	.LVL180:
1513:Libraries/FreeRTOS/Source/tasks.c **** 		{
 1602              		.loc 1 1513 0
 1603 010c FFF7FEBF 		b	xPortStartScheduler
 1604              	.LVL181:
 1605              	.L203:
1528:Libraries/FreeRTOS/Source/tasks.c **** 	}
 1606              		.loc 1 1528 0
 1607 0110 04B1     		cbz	r4, .L204
 1608              	.LVL182:
 1609              	.L178:
 1610 0112 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1611              	.LVL183:
 1612              	.L204:
1528:Libraries/FreeRTOS/Source/tasks.c **** 	}
 1613              		.loc 1 1528 0 is_stmt 0 discriminator 1
 1614 0114 FFF7FEFF 		bl	ulPortSetInterruptMask
 1615              	.LVL184:
 1616              	.L187:
 1617 0118 FEE7     		b	.L187
 1618              	.LVL185:
 1619              	.L201:
 1620              	.LBB117:
 1621              	.LBB115:
 1622              	.LBB112:
 1623              	.LBB99:
2929:Libraries/FreeRTOS/Source/tasks.c **** 			pxNewTCB = NULL;
 1624              		.loc 1 2929 0 is_stmt 1
 1625 011a 2046     		mov	r0, r4
 1626              	.LBE99:
 1627              	.LBE112:
 1628              	.LBE115:
 1629              	.LBE117:
1530:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1630              		.loc 1 1530 0
 1631 011c BDE8F840 		pop	{r3, r4, r5, r6, r7, lr}
 1632              	.LVL186:
 1633              	.LBB118:
 1634              	.LBB116:
 1635              	.LBB113:
 1636              	.LBB100:
2929:Libraries/FreeRTOS/Source/tasks.c **** 			pxNewTCB = NULL;
 1637              		.loc 1 2929 0
 1638 0120 FFF7FEBF 		b	vPortFree
 1639              	.LVL187:
 1640              	.L202:
 1641              	.LBE100:
 1642              	.LBE113:
 1643              	.LBB114:
 610:Libraries/FreeRTOS/Source/tasks.c **** 
 1644              		.loc 1 610 0
 1645 0124 3460     		str	r4, [r6]
 612:Libraries/FreeRTOS/Source/tasks.c **** 				{
 1646              		.loc 1 612 0
 1647 0126 1B68     		ldr	r3, [r3]
 1648 0128 012B     		cmp	r3, #1
 1649 012a 40F20005 		movw	r5, #:lower16:.LANCHOR10
 1650 012e 01D1     		bne	.L200
 617:Libraries/FreeRTOS/Source/tasks.c **** 				}
 1651              		.loc 1 617 0
 1652 0130 FFF7FEFF 		bl	prvInitialiseTaskLists
 1653              	.LVL188:
 1654              	.L200:
 1655 0134 C0F20005 		movt	r5, #:upper16:.LANCHOR10
 1656 0138 B8E7     		b	.L182
 1657              	.LBE114:
 1658              	.LBE116:
 1659              	.LBE118:
 1660              		.cfi_endproc
 1661              	.LFE133:
 1663 013a 00BF     		.section	.text.vTaskEndScheduler,"ax",%progbits
 1664              		.align	2
 1665              		.global	vTaskEndScheduler
 1666              		.thumb
 1667              		.thumb_func
 1669              	vTaskEndScheduler:
 1670              	.LFB134:
1534:Libraries/FreeRTOS/Source/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
 1671              		.loc 1 1534 0
 1672              		.cfi_startproc
 1673              		@ args = 0, pretend = 0, frame = 0
 1674              		@ frame_needed = 0, uses_anonymous_args = 0
 1675 0000 08B5     		push	{r3, lr}
 1676              	.LCFI9:
 1677              		.cfi_def_cfa_offset 8
 1678              		.cfi_offset 3, -8
 1679              		.cfi_offset 14, -4
1538:Libraries/FreeRTOS/Source/tasks.c **** 	xSchedulerRunning = pdFALSE;
 1680              		.loc 1 1538 0
 1681 0002 FFF7FEFF 		bl	ulPortSetInterruptMask
 1682              	.LVL189:
1539:Libraries/FreeRTOS/Source/tasks.c **** 	vPortEndScheduler();
 1683              		.loc 1 1539 0
 1684 0006 40F20003 		movw	r3, #:lower16:.LANCHOR10
 1685 000a C0F20003 		movt	r3, #:upper16:.LANCHOR10
 1686 000e 0022     		movs	r2, #0
 1687 0010 1A60     		str	r2, [r3]
1541:Libraries/FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
 1688              		.loc 1 1541 0
 1689 0012 BDE80840 		pop	{r3, lr}
1540:Libraries/FreeRTOS/Source/tasks.c **** }
 1690              		.loc 1 1540 0
 1691 0016 FFF7FEBF 		b	vPortEndScheduler
 1692              	.LVL190:
 1693              		.cfi_endproc
 1694              	.LFE134:
 1696 001a 00BF     		.section	.text.vTaskSuspendAll,"ax",%progbits
 1697              		.align	2
 1698              		.global	vTaskSuspendAll
 1699              		.thumb
 1700              		.thumb_func
 1702              	vTaskSuspendAll:
 1703              	.LFB135:
1545:Libraries/FreeRTOS/Source/tasks.c **** 	/* A critical section is not required as the variable is of type
 1704              		.loc 1 1545 0
 1705              		.cfi_startproc
 1706              		@ args = 0, pretend = 0, frame = 0
 1707              		@ frame_needed = 0, uses_anonymous_args = 0
 1708              		@ link register save eliminated.
1550:Libraries/FreeRTOS/Source/tasks.c **** }
 1709              		.loc 1 1550 0
 1710 0000 40F20003 		movw	r3, #:lower16:.LANCHOR14
 1711 0004 C0F20003 		movt	r3, #:upper16:.LANCHOR14
 1712 0008 1A68     		ldr	r2, [r3]
 1713 000a 0132     		adds	r2, r2, #1
 1714 000c 1A60     		str	r2, [r3]
 1715 000e 7047     		bx	lr
 1716              		.cfi_endproc
 1717              	.LFE135:
 1719              		.section	.text.xTaskGetTickCount,"ax",%progbits
 1720              		.align	2
 1721              		.global	xTaskGetTickCount
 1722              		.thumb
 1723              		.thumb_func
 1725              	xTaskGetTickCount:
 1726              	.LFB137:
1676:Libraries/FreeRTOS/Source/tasks.c **** TickType_t xTicks;
 1727              		.loc 1 1676 0
 1728              		.cfi_startproc
 1729              		@ args = 0, pretend = 0, frame = 0
 1730              		@ frame_needed = 0, uses_anonymous_args = 0
 1731 0000 10B5     		push	{r4, lr}
 1732              	.LCFI10:
 1733              		.cfi_def_cfa_offset 8
 1734              		.cfi_offset 4, -8
 1735              		.cfi_offset 14, -4
1680:Libraries/FreeRTOS/Source/tasks.c **** 	{
 1736              		.loc 1 1680 0
 1737 0002 FFF7FEFF 		bl	vPortEnterCritical
 1738              	.LVL191:
1682:Libraries/FreeRTOS/Source/tasks.c **** 	}
 1739              		.loc 1 1682 0
 1740 0006 40F20003 		movw	r3, #:lower16:.LANCHOR17
 1741 000a C0F20003 		movt	r3, #:upper16:.LANCHOR17
 1742 000e 1C68     		ldr	r4, [r3]
 1743              	.LVL192:
1684:Libraries/FreeRTOS/Source/tasks.c **** 
 1744              		.loc 1 1684 0
 1745 0010 FFF7FEFF 		bl	vPortExitCritical
 1746              	.LVL193:
1687:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1747              		.loc 1 1687 0
 1748 0014 2046     		mov	r0, r4
 1749 0016 10BD     		pop	{r4, pc}
 1750              		.cfi_endproc
 1751              	.LFE137:
 1753              		.section	.text.xTaskGetTickCountFromISR,"ax",%progbits
 1754              		.align	2
 1755              		.global	xTaskGetTickCountFromISR
 1756              		.thumb
 1757              		.thumb_func
 1759              	xTaskGetTickCountFromISR:
 1760              	.LFB138:
1691:Libraries/FreeRTOS/Source/tasks.c **** TickType_t xReturn;
 1761              		.loc 1 1691 0
 1762              		.cfi_startproc
 1763              		@ args = 0, pretend = 0, frame = 0
 1764              		@ frame_needed = 0, uses_anonymous_args = 0
 1765 0000 10B5     		push	{r4, lr}
 1766              	.LCFI11:
 1767              		.cfi_def_cfa_offset 8
 1768              		.cfi_offset 4, -8
 1769              		.cfi_offset 14, -4
1709:Libraries/FreeRTOS/Source/tasks.c **** 
 1770              		.loc 1 1709 0
 1771 0002 FFF7FEFF 		bl	vPortValidateInterruptPriority
 1772              	.LVL194:
1711:Libraries/FreeRTOS/Source/tasks.c **** 	{
 1773              		.loc 1 1711 0
 1774 0006 FFF7FEFF 		bl	ulPortSetInterruptMask
 1775              	.LVL195:
1713:Libraries/FreeRTOS/Source/tasks.c **** 	}
 1776              		.loc 1 1713 0
 1777 000a 40F20003 		movw	r3, #:lower16:.LANCHOR17
 1778 000e C0F20003 		movt	r3, #:upper16:.LANCHOR17
 1779 0012 1C68     		ldr	r4, [r3]
 1780              	.LVL196:
1715:Libraries/FreeRTOS/Source/tasks.c **** 
 1781              		.loc 1 1715 0
 1782 0014 FFF7FEFF 		bl	vPortClearInterruptMask
 1783              	.LVL197:
1718:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1784              		.loc 1 1718 0
 1785 0018 2046     		mov	r0, r4
 1786 001a 10BD     		pop	{r4, pc}
 1787              		.cfi_endproc
 1788              	.LFE138:
 1790              		.section	.text.uxTaskGetNumberOfTasks,"ax",%progbits
 1791              		.align	2
 1792              		.global	uxTaskGetNumberOfTasks
 1793              		.thumb
 1794              		.thumb_func
 1796              	uxTaskGetNumberOfTasks:
 1797              	.LFB139:
1722:Libraries/FreeRTOS/Source/tasks.c **** 	/* A critical section is not required because the variables are of type
 1798              		.loc 1 1722 0
 1799              		.cfi_startproc
 1800              		@ args = 0, pretend = 0, frame = 0
 1801              		@ frame_needed = 0, uses_anonymous_args = 0
 1802              		@ link register save eliminated.
1725:Libraries/FreeRTOS/Source/tasks.c **** }
 1803              		.loc 1 1725 0
 1804 0000 40F20003 		movw	r3, #:lower16:.LANCHOR8
 1805 0004 C0F20003 		movt	r3, #:upper16:.LANCHOR8
 1806 0008 1868     		ldr	r0, [r3]
1726:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1807              		.loc 1 1726 0
 1808 000a 7047     		bx	lr
 1809              		.cfi_endproc
 1810              	.LFE139:
 1812              		.section	.text.xTaskIncrementTick,"ax",%progbits
 1813              		.align	2
 1814              		.global	xTaskIncrementTick
 1815              		.thumb
 1816              		.thumb_func
 1818              	xTaskIncrementTick:
 1819              	.LFB140:
1851:Libraries/FreeRTOS/Source/tasks.c **** TCB_t * pxTCB;
 1820              		.loc 1 1851 0
 1821              		.cfi_startproc
 1822              		@ args = 0, pretend = 0, frame = 8
 1823              		@ frame_needed = 0, uses_anonymous_args = 0
 1824              	.LVL198:
 1825 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 1826              	.LCFI12:
 1827              		.cfi_def_cfa_offset 36
 1828              		.cfi_offset 4, -36
 1829              		.cfi_offset 5, -32
 1830              		.cfi_offset 6, -28
 1831              		.cfi_offset 7, -24
 1832              		.cfi_offset 8, -20
 1833              		.cfi_offset 9, -16
 1834              		.cfi_offset 10, -12
 1835              		.cfi_offset 11, -8
 1836              		.cfi_offset 14, -4
1860:Libraries/FreeRTOS/Source/tasks.c **** 	{
 1837              		.loc 1 1860 0
 1838 0004 40F20003 		movw	r3, #:lower16:.LANCHOR14
 1839 0008 C0F20003 		movt	r3, #:upper16:.LANCHOR14
1851:Libraries/FreeRTOS/Source/tasks.c **** TCB_t * pxTCB;
 1840              		.loc 1 1851 0
 1841 000c 83B0     		sub	sp, sp, #12
 1842              	.LCFI13:
 1843              		.cfi_def_cfa_offset 48
1860:Libraries/FreeRTOS/Source/tasks.c **** 	{
 1844              		.loc 1 1860 0
 1845 000e 1B68     		ldr	r3, [r3]
 1846 0010 002B     		cmp	r3, #0
 1847 0012 65D1     		bne	.L211
1864:Libraries/FreeRTOS/Source/tasks.c **** 
 1848              		.loc 1 1864 0
 1849 0014 40F20003 		movw	r3, #:lower16:.LANCHOR17
 1850 0018 C0F20003 		movt	r3, #:upper16:.LANCHOR17
 1851 001c 40F20004 		movw	r4, #:lower16:.LANCHOR15
 1852 0020 1A68     		ldr	r2, [r3]
 1853 0022 0132     		adds	r2, r2, #1
 1854 0024 1A60     		str	r2, [r3]
 1855              	.LBB125:
1869:Libraries/FreeRTOS/Source/tasks.c **** 
 1856              		.loc 1 1869 0
 1857 0026 D3F80090 		ldr	r9, [r3]
 1858              	.LVL199:
 1859 002a C0F20004 		movt	r4, #:upper16:.LANCHOR15
1871:Libraries/FreeRTOS/Source/tasks.c **** 			{
 1860              		.loc 1 1871 0
 1861 002e B9F1000F 		cmp	r9, #0
 1862 0032 69D0     		beq	.L242
 1863              	.L212:
1884:Libraries/FreeRTOS/Source/tasks.c **** 			{
 1864              		.loc 1 1884 0
 1865 0034 2368     		ldr	r3, [r4]
 1866 0036 9945     		cmp	r9, r3
 1867 0038 70D3     		bcc	.L229
 1868 003a 40F20008 		movw	r8, #:lower16:.LANCHOR6
 1869 003e 40F20006 		movw	r6, #:lower16:.LANCHOR0
 1870 0042 40F2000B 		movw	fp, #:lower16:.LANCHOR9
1938:Libraries/FreeRTOS/Source/tasks.c **** 
 1871              		.loc 1 1938 0
 1872 0046 40F20007 		movw	r7, #:lower16:.LANCHOR12
 1873 004a C0F20008 		movt	r8, #:upper16:.LANCHOR6
 1874 004e C0F20006 		movt	r6, #:upper16:.LANCHOR0
 1875 0052 C0F2000B 		movt	fp, #:upper16:.LANCHOR9
 1876 0056 C0F20007 		movt	r7, #:upper16:.LANCHOR12
1884:Libraries/FreeRTOS/Source/tasks.c **** 			{
 1877              		.loc 1 1884 0
 1878 005a 0025     		movs	r5, #0
 1879 005c 2DE0     		b	.L218
 1880              	.LVL200:
 1881              	.L239:
1904:Libraries/FreeRTOS/Source/tasks.c **** 						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 1882              		.loc 1 1904 0
 1883 005e 40F20003 		movw	r3, #:lower16:.LANCHOR6
 1884 0062 C0F20003 		movt	r3, #:upper16:.LANCHOR6
 1885 0066 1A68     		ldr	r2, [r3]
 1886 0068 D268     		ldr	r2, [r2, #12]
 1887 006a D2F80CA0 		ldr	r10, [r2, #12]
 1888              	.LVL201:
1905:Libraries/FreeRTOS/Source/tasks.c **** 
 1889              		.loc 1 1905 0
 1890 006e DAF80410 		ldr	r1, [r10, #4]
 1891              	.LVL202:
1923:Libraries/FreeRTOS/Source/tasks.c **** 
 1892              		.loc 1 1923 0
 1893 0072 0AF10403 		add	r3, r10, #4
1907:Libraries/FreeRTOS/Source/tasks.c **** 						{
 1894              		.loc 1 1907 0
 1895 0076 8945     		cmp	r9, r1
1923:Libraries/FreeRTOS/Source/tasks.c **** 
 1896              		.loc 1 1923 0
 1897 0078 0193     		str	r3, [sp, #4]
 1898 007a 1846     		mov	r0, r3
1907:Libraries/FreeRTOS/Source/tasks.c **** 						{
 1899              		.loc 1 1907 0
 1900 007c 74D3     		bcc	.L243
1923:Libraries/FreeRTOS/Source/tasks.c **** 
 1901              		.loc 1 1923 0
 1902 007e FFF7FEFF 		bl	uxListRemove
 1903              	.LVL203:
1927:Libraries/FreeRTOS/Source/tasks.c **** 						{
 1904              		.loc 1 1927 0
 1905 0082 DAF82810 		ldr	r1, [r10, #40]
1929:Libraries/FreeRTOS/Source/tasks.c **** 						}
 1906              		.loc 1 1929 0
 1907 0086 0AF11800 		add	r0, r10, #24
1927:Libraries/FreeRTOS/Source/tasks.c **** 						{
 1908              		.loc 1 1927 0
 1909 008a 09B1     		cbz	r1, .L221
1929:Libraries/FreeRTOS/Source/tasks.c **** 						}
 1910              		.loc 1 1929 0
 1911 008c FFF7FEFF 		bl	uxListRemove
 1912              	.LVL204:
 1913              	.L221:
1938:Libraries/FreeRTOS/Source/tasks.c **** 
 1914              		.loc 1 1938 0
 1915 0090 DAF82C30 		ldr	r3, [r10, #44]
 1916 0094 3A68     		ldr	r2, [r7]
 1917 0096 0199     		ldr	r1, [sp, #4]
 1918 0098 03EB8300 		add	r0, r3, r3, lsl #2
 1919 009c 9342     		cmp	r3, r2
 1920 009e 06EB8000 		add	r0, r6, r0, lsl #2
 1921 00a2 88BF     		it	hi
 1922 00a4 3B60     		strhi	r3, [r7]
 1923 00a6 FFF7FEFF 		bl	vListInsertEnd
 1924              	.LVL205:
1948:Libraries/FreeRTOS/Source/tasks.c **** 							{
 1925              		.loc 1 1948 0
 1926 00aa DBF80000 		ldr	r0, [fp]
 1927 00ae DAF82C10 		ldr	r1, [r10, #44]
 1928 00b2 C26A     		ldr	r2, [r0, #44]
1950:Libraries/FreeRTOS/Source/tasks.c **** 							}
 1929              		.loc 1 1950 0
 1930 00b4 9142     		cmp	r1, r2
 1931 00b6 28BF     		it	cs
 1932 00b8 0125     		movcs	r5, #1
 1933              	.LVL206:
 1934              	.L218:
1888:Libraries/FreeRTOS/Source/tasks.c **** 					{
 1935              		.loc 1 1888 0
 1936 00ba D8F80020 		ldr	r2, [r8]
 1937 00be 1268     		ldr	r2, [r2]
 1938 00c0 002A     		cmp	r2, #0
 1939 00c2 CCD1     		bne	.L239
1895:Libraries/FreeRTOS/Source/tasks.c **** 						break;
 1940              		.loc 1 1895 0
 1941 00c4 4FF0FF32 		mov	r2, #-1
 1942 00c8 2260     		str	r2, [r4]
 1943              	.LVL207:
 1944              	.L217:
 1945              	.LBE125:
1968:Libraries/FreeRTOS/Source/tasks.c **** 			{
 1946              		.loc 1 1968 0
 1947 00ca DBF80030 		ldr	r3, [fp]
 1948 00ce DB6A     		ldr	r3, [r3, #44]
 1949 00d0 03EB8303 		add	r3, r3, r3, lsl #2
 1950 00d4 56F82330 		ldr	r3, [r6, r3, lsl #2]
1970:Libraries/FreeRTOS/Source/tasks.c **** 			}
 1951              		.loc 1 1970 0
 1952 00d8 012B     		cmp	r3, #1
 1953 00da 88BF     		it	hi
 1954 00dc 0125     		movhi	r5, #1
 1955              	.LVL208:
 1956 00de 07E0     		b	.L225
 1957              	.LVL209:
 1958              	.L211:
1996:Libraries/FreeRTOS/Source/tasks.c **** 
 1959              		.loc 1 1996 0
 1960 00e0 40F20003 		movw	r3, #:lower16:.LANCHOR19
 1961 00e4 C0F20003 		movt	r3, #:upper16:.LANCHOR19
1854:Libraries/FreeRTOS/Source/tasks.c **** 
 1962              		.loc 1 1854 0
 1963 00e8 0025     		movs	r5, #0
1996:Libraries/FreeRTOS/Source/tasks.c **** 
 1964              		.loc 1 1996 0
 1965 00ea 1A68     		ldr	r2, [r3]
 1966 00ec 0132     		adds	r2, r2, #1
 1967 00ee 1A60     		str	r2, [r3]
 1968              	.LVL210:
 1969              	.L225:
2009:Libraries/FreeRTOS/Source/tasks.c **** 		{
 1970              		.loc 1 2009 0
 1971 00f0 40F20003 		movw	r3, #:lower16:.LANCHOR16
 1972 00f4 C0F20003 		movt	r3, #:upper16:.LANCHOR16
 1973 00f8 1B68     		ldr	r3, [r3]
2011:Libraries/FreeRTOS/Source/tasks.c **** 		}
 1974              		.loc 1 2011 0
 1975 00fa 002B     		cmp	r3, #0
 1976 00fc 18BF     		it	ne
 1977 00fe 0125     		movne	r5, #1
 1978              	.LVL211:
2021:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1979              		.loc 1 2021 0
 1980 0100 2846     		mov	r0, r5
 1981 0102 03B0     		add	sp, sp, #12
 1982              		@ sp needed
 1983 0104 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1984              	.LVL212:
 1985              	.L242:
 1986              	.LBB135:
 1987              	.LBB126:
1873:Libraries/FreeRTOS/Source/tasks.c **** 			}
 1988              		.loc 1 1873 0
 1989 0108 40F20003 		movw	r3, #:lower16:.LANCHOR6
 1990 010c C0F20003 		movt	r3, #:upper16:.LANCHOR6
 1991 0110 1A68     		ldr	r2, [r3]
 1992 0112 1268     		ldr	r2, [r2]
 1993 0114 62B1     		cbz	r2, .L213
1873:Libraries/FreeRTOS/Source/tasks.c **** 			}
 1994              		.loc 1 1873 0 is_stmt 0 discriminator 1
 1995 0116 FFF7FEFF 		bl	ulPortSetInterruptMask
 1996              	.LVL213:
 1997              	.L214:
 1998 011a FEE7     		b	.L214
 1999              	.L229:
 2000 011c 40F20006 		movw	r6, #:lower16:.LANCHOR0
 2001 0120 40F2000B 		movw	fp, #:lower16:.LANCHOR9
 2002 0124 C0F20006 		movt	r6, #:upper16:.LANCHOR0
 2003 0128 C0F2000B 		movt	fp, #:upper16:.LANCHOR9
 2004              	.LBE126:
 2005              	.LBE135:
1854:Libraries/FreeRTOS/Source/tasks.c **** 
 2006              		.loc 1 1854 0 is_stmt 1
 2007 012c 0025     		movs	r5, #0
 2008 012e CCE7     		b	.L217
 2009              	.L213:
 2010              	.LBB136:
 2011              	.LBB133:
1873:Libraries/FreeRTOS/Source/tasks.c **** 			}
 2012              		.loc 1 1873 0 discriminator 2
 2013 0130 40F20001 		movw	r1, #:lower16:.LANCHOR7
 2014 0134 C0F20001 		movt	r1, #:upper16:.LANCHOR7
 2015 0138 1868     		ldr	r0, [r3]
 2016              	.LVL214:
 2017 013a 0C68     		ldr	r4, [r1]
 2018 013c 40F20002 		movw	r2, #:lower16:.LANCHOR18
 2019 0140 C0F20002 		movt	r2, #:upper16:.LANCHOR18
 2020 0144 1C60     		str	r4, [r3]
 2021 0146 0860     		str	r0, [r1]
 2022 0148 1168     		ldr	r1, [r2]
 2023 014a 0131     		adds	r1, r1, #1
 2024 014c 1160     		str	r1, [r2]
 2025              	.LBB127:
 2026              	.LBB128:
3108:Libraries/FreeRTOS/Source/tasks.c **** 	{
 2027              		.loc 1 3108 0 discriminator 2
 2028 014e 1A68     		ldr	r2, [r3]
 2029 0150 1268     		ldr	r2, [r2]
 2030 0152 5AB1     		cbz	r2, .L215
 2031              	.LBB129:
 2032              	.LBB130:
3123:Libraries/FreeRTOS/Source/tasks.c **** 		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
 2033              		.loc 1 3123 0
 2034 0154 1B68     		ldr	r3, [r3]
 2035              	.LVL215:
 2036 0156 DB68     		ldr	r3, [r3, #12]
 2037              	.LVL216:
 2038              		.loc 1 3124 0
 2039 0158 DB68     		ldr	r3, [r3, #12]
 2040              	.LVL217:
 2041 015a 40F20004 		movw	r4, #:lower16:.LANCHOR15
 2042 015e 5B68     		ldr	r3, [r3, #4]
 2043              	.LVL218:
 2044 0160 C0F20004 		movt	r4, #:upper16:.LANCHOR15
 2045 0164 2360     		str	r3, [r4]
 2046 0166 65E7     		b	.L212
 2047              	.LVL219:
 2048              	.L243:
 2049              	.LBE130:
 2050              	.LBE129:
 2051              	.LBE128:
 2052              	.LBE127:
 2053              	.LBE133:
1914:Libraries/FreeRTOS/Source/tasks.c **** 							break;
 2054              		.loc 1 1914 0
 2055 0168 2160     		str	r1, [r4]
1915:Libraries/FreeRTOS/Source/tasks.c **** 						}
 2056              		.loc 1 1915 0
 2057 016a AEE7     		b	.L217
 2058              	.LVL220:
 2059              	.L215:
 2060              	.LBB134:
 2061              	.LBB132:
 2062              	.LBB131:
3115:Libraries/FreeRTOS/Source/tasks.c **** 	}
 2063              		.loc 1 3115 0
 2064 016c 40F20004 		movw	r4, #:lower16:.LANCHOR15
 2065 0170 C0F20004 		movt	r4, #:upper16:.LANCHOR15
 2066 0174 4FF0FF33 		mov	r3, #-1
 2067 0178 2360     		str	r3, [r4]
 2068 017a 5BE7     		b	.L212
 2069              	.LBE131:
 2070              	.LBE132:
 2071              	.LBE134:
 2072              	.LBE136:
 2073              		.cfi_endproc
 2074              	.LFE140:
 2076              		.section	.text.xTaskResumeAll,"ax",%progbits
 2077              		.align	2
 2078              		.global	xTaskResumeAll
 2079              		.thumb
 2080              		.thumb_func
 2082              	xTaskResumeAll:
 2083              	.LFB136:
1583:Libraries/FreeRTOS/Source/tasks.c **** TCB_t *pxTCB;
 2084              		.loc 1 1583 0
 2085              		.cfi_startproc
 2086              		@ args = 0, pretend = 0, frame = 0
 2087              		@ frame_needed = 0, uses_anonymous_args = 0
 2088              	.LVL221:
 2089 0000 2DE9F84F 		push	{r3, r4, r5, r6, r7, r8, r9, r10, fp, lr}
 2090              	.LCFI14:
 2091              		.cfi_def_cfa_offset 40
 2092              		.cfi_offset 3, -40
 2093              		.cfi_offset 4, -36
 2094              		.cfi_offset 5, -32
 2095              		.cfi_offset 6, -28
 2096              		.cfi_offset 7, -24
 2097              		.cfi_offset 8, -20
 2098              		.cfi_offset 9, -16
 2099              		.cfi_offset 10, -12
 2100              		.cfi_offset 11, -8
 2101              		.cfi_offset 14, -4
1589:Libraries/FreeRTOS/Source/tasks.c **** 
 2102              		.loc 1 1589 0
 2103 0004 40F20004 		movw	r4, #:lower16:.LANCHOR14
 2104 0008 C0F20004 		movt	r4, #:upper16:.LANCHOR14
 2105 000c 2368     		ldr	r3, [r4]
 2106 000e 13B9     		cbnz	r3, .L245
1589:Libraries/FreeRTOS/Source/tasks.c **** 
 2107              		.loc 1 1589 0 is_stmt 0 discriminator 1
 2108 0010 FFF7FEFF 		bl	ulPortSetInterruptMask
 2109              	.LVL222:
 2110              	.L246:
 2111 0014 FEE7     		b	.L246
 2112              	.L245:
1596:Libraries/FreeRTOS/Source/tasks.c **** 	{
 2113              		.loc 1 1596 0 is_stmt 1
 2114 0016 FFF7FEFF 		bl	vPortEnterCritical
 2115              	.LVL223:
1598:Libraries/FreeRTOS/Source/tasks.c **** 
 2116              		.loc 1 1598 0
 2117 001a 2368     		ldr	r3, [r4]
 2118 001c 013B     		subs	r3, r3, #1
 2119 001e 2360     		str	r3, [r4]
1600:Libraries/FreeRTOS/Source/tasks.c **** 		{
 2120              		.loc 1 1600 0
 2121 0020 2368     		ldr	r3, [r4]
 2122 0022 002B     		cmp	r3, #0
 2123 0024 48D1     		bne	.L249
1602:Libraries/FreeRTOS/Source/tasks.c **** 			{
 2124              		.loc 1 1602 0
 2125 0026 40F20003 		movw	r3, #:lower16:.LANCHOR8
 2126 002a C0F20003 		movt	r3, #:upper16:.LANCHOR8
 2127 002e 1B68     		ldr	r3, [r3]
 2128 0030 002B     		cmp	r3, #0
 2129 0032 41D0     		beq	.L249
 2130 0034 40F20006 		movw	r6, #:lower16:.LANCHOR3
 2131 0038 C0F20006 		movt	r6, #:upper16:.LANCHOR3
 2132 003c 40F20005 		movw	r5, #:lower16:.LANCHOR16
1611:Libraries/FreeRTOS/Source/tasks.c **** 
 2133              		.loc 1 1611 0
 2134 0040 40F20004 		movw	r4, #:lower16:.LANCHOR12
 2135 0044 40F20009 		movw	r9, #:lower16:.LANCHOR0
1615:Libraries/FreeRTOS/Source/tasks.c **** 					{
 2136              		.loc 1 1615 0
 2137 0048 40F20008 		movw	r8, #:lower16:.LANCHOR9
1606:Libraries/FreeRTOS/Source/tasks.c **** 				{
 2138              		.loc 1 1606 0
 2139 004c B246     		mov	r10, r6
 2140 004e C0F20005 		movt	r5, #:upper16:.LANCHOR16
1611:Libraries/FreeRTOS/Source/tasks.c **** 
 2141              		.loc 1 1611 0
 2142 0052 C0F20004 		movt	r4, #:upper16:.LANCHOR12
 2143 0056 C0F20009 		movt	r9, #:upper16:.LANCHOR0
1615:Libraries/FreeRTOS/Source/tasks.c **** 					{
 2144              		.loc 1 1615 0
 2145 005a C0F20008 		movt	r8, #:upper16:.LANCHOR9
 2146 005e 1FE0     		b	.L253
 2147              	.L254:
1608:Libraries/FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 2148              		.loc 1 1608 0
 2149 0060 DAF80C30 		ldr	r3, [r10, #12]
 2150 0064 DF68     		ldr	r7, [r3, #12]
 2151              	.LVL224:
1610:Libraries/FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 2152              		.loc 1 1610 0
 2153 0066 07F1040B 		add	fp, r7, #4
1609:Libraries/FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 2154              		.loc 1 1609 0
 2155 006a 07F11800 		add	r0, r7, #24
 2156 006e FFF7FEFF 		bl	uxListRemove
 2157              	.LVL225:
1610:Libraries/FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 2158              		.loc 1 1610 0
 2159 0072 5846     		mov	r0, fp
 2160 0074 FFF7FEFF 		bl	uxListRemove
 2161              	.LVL226:
1611:Libraries/FreeRTOS/Source/tasks.c **** 
 2162              		.loc 1 1611 0
 2163 0078 FB6A     		ldr	r3, [r7, #44]
 2164 007a 2268     		ldr	r2, [r4]
 2165 007c 03EB8300 		add	r0, r3, r3, lsl #2
 2166 0080 9342     		cmp	r3, r2
 2167 0082 5946     		mov	r1, fp
 2168 0084 09EB8000 		add	r0, r9, r0, lsl #2
 2169 0088 88BF     		it	hi
 2170 008a 2360     		strhi	r3, [r4]
 2171 008c FFF7FEFF 		bl	vListInsertEnd
 2172              	.LVL227:
1615:Libraries/FreeRTOS/Source/tasks.c **** 					{
 2173              		.loc 1 1615 0
 2174 0090 D8F80030 		ldr	r3, [r8]
 2175 0094 F96A     		ldr	r1, [r7, #44]
 2176 0096 DB6A     		ldr	r3, [r3, #44]
 2177 0098 9942     		cmp	r1, r3
1617:Libraries/FreeRTOS/Source/tasks.c **** 					}
 2178              		.loc 1 1617 0
 2179 009a 24BF     		itt	cs
 2180 009c 0123     		movcs	r3, #1
 2181 009e 2B60     		strcs	r3, [r5]
 2182              	.LVL228:
 2183              	.L253:
1606:Libraries/FreeRTOS/Source/tasks.c **** 				{
 2184              		.loc 1 1606 0 discriminator 1
 2185 00a0 3368     		ldr	r3, [r6]
 2186 00a2 002B     		cmp	r3, #0
 2187 00a4 DCD1     		bne	.L254
1629:Libraries/FreeRTOS/Source/tasks.c **** 				{
 2188              		.loc 1 1629 0
 2189 00a6 40F20004 		movw	r4, #:lower16:.LANCHOR19
 2190 00aa C0F20004 		movt	r4, #:upper16:.LANCHOR19
 2191 00ae 2368     		ldr	r3, [r4]
 2192 00b0 43B9     		cbnz	r3, .L255
 2193              	.L257:
1649:Libraries/FreeRTOS/Source/tasks.c **** 				{
 2194              		.loc 1 1649 0
 2195 00b2 2C68     		ldr	r4, [r5]
 2196 00b4 012C     		cmp	r4, #1
 2197 00b6 14D0     		beq	.L272
 2198              	.L249:
1585:Libraries/FreeRTOS/Source/tasks.c **** 
 2199              		.loc 1 1585 0
 2200 00b8 0024     		movs	r4, #0
 2201              	.LVL229:
1669:Libraries/FreeRTOS/Source/tasks.c **** 
 2202              		.loc 1 1669 0
 2203 00ba FFF7FEFF 		bl	vPortExitCritical
 2204              	.LVL230:
1672:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 2205              		.loc 1 1672 0
 2206 00be 2046     		mov	r0, r4
 2207 00c0 BDE8F88F 		pop	{r3, r4, r5, r6, r7, r8, r9, r10, fp, pc}
 2208              	.LVL231:
 2209              	.L255:
1631:Libraries/FreeRTOS/Source/tasks.c **** 					{
 2210              		.loc 1 1631 0 discriminator 1
 2211 00c4 2368     		ldr	r3, [r4]
 2212 00c6 002B     		cmp	r3, #0
 2213 00c8 F3D0     		beq	.L257
1635:Libraries/FreeRTOS/Source/tasks.c **** 						}
 2214              		.loc 1 1635 0
 2215 00ca 0126     		movs	r6, #1
 2216              	.L259:
1633:Libraries/FreeRTOS/Source/tasks.c **** 						{
 2217              		.loc 1 1633 0
 2218 00cc FFF7FEFF 		bl	xTaskIncrementTick
 2219              	.LVL232:
 2220 00d0 00B1     		cbz	r0, .L258
1635:Libraries/FreeRTOS/Source/tasks.c **** 						}
 2221              		.loc 1 1635 0
 2222 00d2 2E60     		str	r6, [r5]
 2223              	.L258:
1641:Libraries/FreeRTOS/Source/tasks.c **** 					}
 2224              		.loc 1 1641 0
 2225 00d4 2368     		ldr	r3, [r4]
 2226 00d6 013B     		subs	r3, r3, #1
 2227 00d8 2360     		str	r3, [r4]
1631:Libraries/FreeRTOS/Source/tasks.c **** 					{
 2228              		.loc 1 1631 0
 2229 00da 2368     		ldr	r3, [r4]
 2230 00dc 002B     		cmp	r3, #0
 2231 00de F5D1     		bne	.L259
 2232 00e0 E7E7     		b	.L257
 2233              	.L272:
 2234              	.LVL233:
1656:Libraries/FreeRTOS/Source/tasks.c **** 				}
 2235              		.loc 1 1656 0
 2236 00e2 FFF7FEFF 		bl	vPortYield
 2237              	.LVL234:
1669:Libraries/FreeRTOS/Source/tasks.c **** 
 2238              		.loc 1 1669 0
 2239 00e6 FFF7FEFF 		bl	vPortExitCritical
 2240              	.LVL235:
1672:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 2241              		.loc 1 1672 0
 2242 00ea 2046     		mov	r0, r4
 2243 00ec BDE8F88F 		pop	{r3, r4, r5, r6, r7, r8, r9, r10, fp, pc}
 2244              		.cfi_endproc
 2245              	.LFE136:
 2247              		.section	.text.vTaskDelayUntil,"ax",%progbits
 2248              		.align	2
 2249              		.global	vTaskDelayUntil
 2250              		.thumb
 2251              		.thumb_func
 2253              	vTaskDelayUntil:
 2254              	.LFB125:
 779:Libraries/FreeRTOS/Source/tasks.c **** 	TickType_t xTimeToWake;
 2255              		.loc 1 779 0
 2256              		.cfi_startproc
 2257              		@ args = 0, pretend = 0, frame = 0
 2258              		@ frame_needed = 0, uses_anonymous_args = 0
 2259              	.LVL236:
 2260 0000 70B5     		push	{r4, r5, r6, lr}
 2261              	.LCFI15:
 2262              		.cfi_def_cfa_offset 16
 2263              		.cfi_offset 4, -16
 2264              		.cfi_offset 5, -12
 2265              		.cfi_offset 6, -8
 2266              		.cfi_offset 14, -4
 783:Libraries/FreeRTOS/Source/tasks.c **** 		configASSERT( ( xTimeIncrement > 0U ) );
 2267              		.loc 1 783 0
 2268 0002 0028     		cmp	r0, #0
 2269 0004 4DD0     		beq	.L290
 784:Libraries/FreeRTOS/Source/tasks.c **** 		configASSERT( uxSchedulerSuspended == 0 );
 2270              		.loc 1 784 0
 2271 0006 0029     		cmp	r1, #0
 2272 0008 48D0     		beq	.L291
 785:Libraries/FreeRTOS/Source/tasks.c **** 
 2273              		.loc 1 785 0
 2274 000a 40F20003 		movw	r3, #:lower16:.LANCHOR14
 2275 000e C0F20003 		movt	r3, #:upper16:.LANCHOR14
 2276 0012 1A68     		ldr	r2, [r3]
 2277 0014 002A     		cmp	r2, #0
 2278 0016 3ED1     		bne	.L292
 2279              	.LBB144:
 2280              	.LBB145:
1550:Libraries/FreeRTOS/Source/tasks.c **** }
 2281              		.loc 1 1550 0
 2282 0018 1C68     		ldr	r4, [r3]
 2283              	.LBE145:
 2284              	.LBE144:
 2285              	.LBB148:
 794:Libraries/FreeRTOS/Source/tasks.c **** 
 2286              		.loc 1 794 0
 2287 001a 0268     		ldr	r2, [r0]
 791:Libraries/FreeRTOS/Source/tasks.c **** 
 2288              		.loc 1 791 0
 2289 001c 40F20006 		movw	r6, #:lower16:.LANCHOR17
 2290              	.LBE148:
 2291              	.LBB155:
 2292              	.LBB146:
1550:Libraries/FreeRTOS/Source/tasks.c **** }
 2293              		.loc 1 1550 0
 2294 0020 0134     		adds	r4, r4, #1
 2295              	.LBE146:
 2296              	.LBE155:
 2297              	.LBB156:
 791:Libraries/FreeRTOS/Source/tasks.c **** 
 2298              		.loc 1 791 0
 2299 0022 C0F20006 		movt	r6, #:upper16:.LANCHOR17
 2300              	.LBE156:
 2301              	.LBB157:
 2302              	.LBB147:
1550:Libraries/FreeRTOS/Source/tasks.c **** }
 2303              		.loc 1 1550 0
 2304 0026 1C60     		str	r4, [r3]
 2305              	.LBE147:
 2306              	.LBE157:
 2307              	.LBB158:
 791:Libraries/FreeRTOS/Source/tasks.c **** 
 2308              		.loc 1 791 0
 2309 0028 3368     		ldr	r3, [r6]
 2310              	.LVL237:
 796:Libraries/FreeRTOS/Source/tasks.c **** 			{
 2311              		.loc 1 796 0
 2312 002a 9342     		cmp	r3, r2
 794:Libraries/FreeRTOS/Source/tasks.c **** 
 2313              		.loc 1 794 0
 2314 002c 02EB0104 		add	r4, r2, r1
 2315              	.LVL238:
 796:Libraries/FreeRTOS/Source/tasks.c **** 			{
 2316              		.loc 1 796 0
 2317 0030 26D3     		bcc	.L293
 817:Libraries/FreeRTOS/Source/tasks.c **** 				{
 2318              		.loc 1 817 0
 2319 0032 A242     		cmp	r2, r4
 2320 0034 01D8     		bhi	.L282
 2321              	.L289:
 817:Libraries/FreeRTOS/Source/tasks.c **** 				{
 2322              		.loc 1 817 0 is_stmt 0 discriminator 1
 2323 0036 A342     		cmp	r3, r4
 2324 0038 24D2     		bcs	.L281
 2325              	.L282:
 2326              	.LVL239:
 836:Libraries/FreeRTOS/Source/tasks.c **** 				{
 2327              		.loc 1 836 0 is_stmt 1
 2328 003a 40F20005 		movw	r5, #:lower16:.LANCHOR9
 2329 003e C0F20005 		movt	r5, #:upper16:.LANCHOR9
 828:Libraries/FreeRTOS/Source/tasks.c **** 
 2330              		.loc 1 828 0
 2331 0042 0460     		str	r4, [r0]
 836:Libraries/FreeRTOS/Source/tasks.c **** 				{
 2332              		.loc 1 836 0
 2333 0044 2868     		ldr	r0, [r5]
 2334              	.LVL240:
 2335 0046 0430     		adds	r0, r0, #4
 2336 0048 FFF7FEFF 		bl	uxListRemove
 2337              	.LVL241:
 2338              	.LBB149:
 2339              	.LBB150:
2884:Libraries/FreeRTOS/Source/tasks.c **** 
 2340              		.loc 1 2884 0
 2341 004c 2A68     		ldr	r2, [r5]
2886:Libraries/FreeRTOS/Source/tasks.c **** 	{
 2342              		.loc 1 2886 0
 2343 004e 3368     		ldr	r3, [r6]
2884:Libraries/FreeRTOS/Source/tasks.c **** 
 2344              		.loc 1 2884 0
 2345 0050 5460     		str	r4, [r2, #4]
2886:Libraries/FreeRTOS/Source/tasks.c **** 	{
 2346              		.loc 1 2886 0
 2347 0052 9C42     		cmp	r4, r3
 2348 0054 28D3     		bcc	.L294
2894:Libraries/FreeRTOS/Source/tasks.c **** 
 2349              		.loc 1 2894 0
 2350 0056 40F20003 		movw	r3, #:lower16:.LANCHOR6
 2351 005a C0F20003 		movt	r3, #:upper16:.LANCHOR6
 2352 005e 1868     		ldr	r0, [r3]
 2353 0060 2968     		ldr	r1, [r5]
 2354 0062 0431     		adds	r1, r1, #4
 2355 0064 FFF7FEFF 		bl	vListInsert
 2356              	.LVL242:
2899:Libraries/FreeRTOS/Source/tasks.c **** 		{
 2357              		.loc 1 2899 0
 2358 0068 40F20003 		movw	r3, #:lower16:.LANCHOR15
 2359 006c C0F20003 		movt	r3, #:upper16:.LANCHOR15
 2360 0070 1A68     		ldr	r2, [r3]
 2361 0072 9442     		cmp	r4, r2
2901:Libraries/FreeRTOS/Source/tasks.c **** 		}
 2362              		.loc 1 2901 0
 2363 0074 38BF     		it	cc
 2364 0076 1C60     		strcc	r4, [r3]
 2365              	.L283:
 2366              	.LBE150:
 2367              	.LBE149:
 2368              	.LBE158:
 855:Libraries/FreeRTOS/Source/tasks.c **** 
 2369              		.loc 1 855 0
 2370 0078 FFF7FEFF 		bl	xTaskResumeAll
 2371              	.LVL243:
 859:Libraries/FreeRTOS/Source/tasks.c **** 		{
 2372              		.loc 1 859 0
 2373 007c 38B1     		cbz	r0, .L295
 2374              	.LVL244:
 2375              	.L273:
 2376 007e 70BD     		pop	{r4, r5, r6, pc}
 2377              	.LVL245:
 2378              	.L293:
 2379              	.LBB159:
 803:Libraries/FreeRTOS/Source/tasks.c **** 				{
 2380              		.loc 1 803 0
 2381 0080 A242     		cmp	r2, r4
 2382 0082 D8D8     		bhi	.L289
 2383              	.L281:
 828:Libraries/FreeRTOS/Source/tasks.c **** 
 2384              		.loc 1 828 0
 2385 0084 0460     		str	r4, [r0]
 2386              	.LBE159:
 855:Libraries/FreeRTOS/Source/tasks.c **** 
 2387              		.loc 1 855 0
 2388 0086 FFF7FEFF 		bl	xTaskResumeAll
 2389              	.LVL246:
 859:Libraries/FreeRTOS/Source/tasks.c **** 		{
 2390              		.loc 1 859 0
 2391 008a 0028     		cmp	r0, #0
 2392 008c F7D1     		bne	.L273
 2393              	.LVL247:
 2394              	.L295:
 867:Libraries/FreeRTOS/Source/tasks.c **** 
 2395              		.loc 1 867 0
 2396 008e BDE87040 		pop	{r4, r5, r6, lr}
 2397              	.LVL248:
 861:Libraries/FreeRTOS/Source/tasks.c **** 		}
 2398              		.loc 1 861 0
 2399 0092 FFF7FEBF 		b	vPortYield
 2400              	.LVL249:
 2401              	.L292:
 785:Libraries/FreeRTOS/Source/tasks.c **** 
 2402              		.loc 1 785 0 discriminator 1
 2403 0096 FFF7FEFF 		bl	ulPortSetInterruptMask
 2404              	.LVL250:
 2405              	.L279:
 2406 009a FEE7     		b	.L279
 2407              	.LVL251:
 2408              	.L291:
 784:Libraries/FreeRTOS/Source/tasks.c **** 		configASSERT( uxSchedulerSuspended == 0 );
 2409              		.loc 1 784 0 discriminator 1
 2410 009c FFF7FEFF 		bl	ulPortSetInterruptMask
 2411              	.LVL252:
 2412              	.L277:
 2413 00a0 FEE7     		b	.L277
 2414              	.LVL253:
 2415              	.L290:
 783:Libraries/FreeRTOS/Source/tasks.c **** 		configASSERT( ( xTimeIncrement > 0U ) );
 2416              		.loc 1 783 0 discriminator 1
 2417 00a2 FFF7FEFF 		bl	ulPortSetInterruptMask
 2418              	.LVL254:
 2419              	.L275:
 2420 00a6 FEE7     		b	.L275
 2421              	.LVL255:
 2422              	.L294:
 2423              	.LBB160:
 2424              	.LBB154:
 2425              	.LBB153:
 2426              	.LBB151:
 2427              	.LBB152:
2889:Libraries/FreeRTOS/Source/tasks.c **** 	}
 2428              		.loc 1 2889 0
 2429 00a8 40F20003 		movw	r3, #:lower16:.LANCHOR7
 2430 00ac C0F20003 		movt	r3, #:upper16:.LANCHOR7
 2431 00b0 1868     		ldr	r0, [r3]
 2432 00b2 2968     		ldr	r1, [r5]
 2433 00b4 0431     		adds	r1, r1, #4
 2434 00b6 FFF7FEFF 		bl	vListInsert
 2435              	.LVL256:
 2436 00ba DDE7     		b	.L283
 2437              	.LBE152:
 2438              	.LBE151:
 2439              	.LBE153:
 2440              	.LBE154:
 2441              	.LBE160:
 2442              		.cfi_endproc
 2443              	.LFE125:
 2445              		.section	.text.vTaskDelay,"ax",%progbits
 2446              		.align	2
 2447              		.global	vTaskDelay
 2448              		.thumb
 2449              		.thumb_func
 2451              	vTaskDelay:
 2452              	.LFB126:
 875:Libraries/FreeRTOS/Source/tasks.c **** 	TickType_t xTimeToWake;
 2453              		.loc 1 875 0
 2454              		.cfi_startproc
 2455              		@ args = 0, pretend = 0, frame = 0
 2456              		@ frame_needed = 0, uses_anonymous_args = 0
 2457              	.LVL257:
 2458 0000 70B5     		push	{r4, r5, r6, lr}
 2459              	.LCFI16:
 2460              		.cfi_def_cfa_offset 16
 2461              		.cfi_offset 4, -16
 2462              		.cfi_offset 5, -12
 2463              		.cfi_offset 6, -8
 2464              		.cfi_offset 14, -4
 881:Libraries/FreeRTOS/Source/tasks.c **** 		{
 2465              		.loc 1 881 0
 2466 0002 0246     		mov	r2, r0
 2467 0004 18B9     		cbnz	r0, .L297
 2468              	.LVL258:
 2469              	.L302:
 933:Libraries/FreeRTOS/Source/tasks.c **** 
 2470              		.loc 1 933 0
 2471 0006 BDE87040 		pop	{r4, r5, r6, lr}
 927:Libraries/FreeRTOS/Source/tasks.c **** 		}
 2472              		.loc 1 927 0
 2473 000a FFF7FEBF 		b	vPortYield
 2474              	.LVL259:
 2475              	.L297:
 883:Libraries/FreeRTOS/Source/tasks.c **** 			vTaskSuspendAll();
 2476              		.loc 1 883 0
 2477 000e 40F20003 		movw	r3, #:lower16:.LANCHOR14
 2478 0012 C0F20003 		movt	r3, #:upper16:.LANCHOR14
 2479 0016 1968     		ldr	r1, [r3]
 2480 0018 59BB     		cbnz	r1, .L306
 2481              	.LBB167:
 2482              	.LBB168:
1550:Libraries/FreeRTOS/Source/tasks.c **** }
 2483              		.loc 1 1550 0
 2484 001a 1968     		ldr	r1, [r3]
 2485              	.LBE168:
 2486              	.LBE167:
 898:Libraries/FreeRTOS/Source/tasks.c **** 
 2487              		.loc 1 898 0
 2488 001c 40F20006 		movw	r6, #:lower16:.LANCHOR17
 903:Libraries/FreeRTOS/Source/tasks.c **** 				{
 2489              		.loc 1 903 0
 2490 0020 40F20004 		movw	r4, #:lower16:.LANCHOR9
 2491              	.LBB171:
 2492              	.LBB169:
1550:Libraries/FreeRTOS/Source/tasks.c **** }
 2493              		.loc 1 1550 0
 2494 0024 0131     		adds	r1, r1, #1
 2495              	.LBE169:
 2496              	.LBE171:
 898:Libraries/FreeRTOS/Source/tasks.c **** 
 2497              		.loc 1 898 0
 2498 0026 C0F20006 		movt	r6, #:upper16:.LANCHOR17
 903:Libraries/FreeRTOS/Source/tasks.c **** 				{
 2499              		.loc 1 903 0
 2500 002a C0F20004 		movt	r4, #:upper16:.LANCHOR9
 2501              	.LBB172:
 2502              	.LBB170:
1550:Libraries/FreeRTOS/Source/tasks.c **** }
 2503              		.loc 1 1550 0
 2504 002e 1960     		str	r1, [r3]
 2505              	.LBE170:
 2506              	.LBE172:
 898:Libraries/FreeRTOS/Source/tasks.c **** 
 2507              		.loc 1 898 0
 2508 0030 3568     		ldr	r5, [r6]
 903:Libraries/FreeRTOS/Source/tasks.c **** 				{
 2509              		.loc 1 903 0
 2510 0032 2068     		ldr	r0, [r4]
 2511              	.LVL260:
 2512 0034 0430     		adds	r0, r0, #4
 898:Libraries/FreeRTOS/Source/tasks.c **** 
 2513              		.loc 1 898 0
 2514 0036 1544     		add	r5, r5, r2
 2515              	.LVL261:
 903:Libraries/FreeRTOS/Source/tasks.c **** 				{
 2516              		.loc 1 903 0
 2517 0038 FFF7FEFF 		bl	uxListRemove
 2518              	.LVL262:
 2519              	.LBB173:
 2520              	.LBB174:
2884:Libraries/FreeRTOS/Source/tasks.c **** 
 2521              		.loc 1 2884 0
 2522 003c 2268     		ldr	r2, [r4]
2886:Libraries/FreeRTOS/Source/tasks.c **** 	{
 2523              		.loc 1 2886 0
 2524 003e 3368     		ldr	r3, [r6]
2884:Libraries/FreeRTOS/Source/tasks.c **** 
 2525              		.loc 1 2884 0
 2526 0040 5560     		str	r5, [r2, #4]
2886:Libraries/FreeRTOS/Source/tasks.c **** 	{
 2527              		.loc 1 2886 0
 2528 0042 9D42     		cmp	r5, r3
 2529 0044 18D3     		bcc	.L307
2894:Libraries/FreeRTOS/Source/tasks.c **** 
 2530              		.loc 1 2894 0
 2531 0046 40F20003 		movw	r3, #:lower16:.LANCHOR6
 2532 004a C0F20003 		movt	r3, #:upper16:.LANCHOR6
 2533 004e 1868     		ldr	r0, [r3]
 2534 0050 2168     		ldr	r1, [r4]
 2535 0052 0431     		adds	r1, r1, #4
 2536 0054 FFF7FEFF 		bl	vListInsert
 2537              	.LVL263:
2899:Libraries/FreeRTOS/Source/tasks.c **** 		{
 2538              		.loc 1 2899 0
 2539 0058 40F20003 		movw	r3, #:lower16:.LANCHOR15
 2540 005c C0F20003 		movt	r3, #:upper16:.LANCHOR15
 2541 0060 1A68     		ldr	r2, [r3]
 2542 0062 9542     		cmp	r5, r2
2901:Libraries/FreeRTOS/Source/tasks.c **** 		}
 2543              		.loc 1 2901 0
 2544 0064 38BF     		it	cc
 2545 0066 1D60     		strcc	r5, [r3]
 2546              	.L301:
 2547              	.LBE174:
 2548              	.LBE173:
 916:Libraries/FreeRTOS/Source/tasks.c **** 		}
 2549              		.loc 1 916 0
 2550 0068 FFF7FEFF 		bl	xTaskResumeAll
 2551              	.LVL264:
 925:Libraries/FreeRTOS/Source/tasks.c **** 		{
 2552              		.loc 1 925 0
 2553 006c 0028     		cmp	r0, #0
 2554 006e CAD0     		beq	.L302
 933:Libraries/FreeRTOS/Source/tasks.c **** 
 2555              		.loc 1 933 0
 2556 0070 70BD     		pop	{r4, r5, r6, pc}
 2557              	.LVL265:
 2558              	.L306:
 883:Libraries/FreeRTOS/Source/tasks.c **** 			vTaskSuspendAll();
 2559              		.loc 1 883 0 discriminator 1
 2560 0072 FFF7FEFF 		bl	ulPortSetInterruptMask
 2561              	.LVL266:
 2562              	.L299:
 2563 0076 FEE7     		b	.L299
 2564              	.LVL267:
 2565              	.L307:
 2566              	.LBB178:
 2567              	.LBB177:
 2568              	.LBB175:
 2569              	.LBB176:
2889:Libraries/FreeRTOS/Source/tasks.c **** 	}
 2570              		.loc 1 2889 0
 2571 0078 40F20003 		movw	r3, #:lower16:.LANCHOR7
 2572 007c C0F20003 		movt	r3, #:upper16:.LANCHOR7
 2573 0080 1868     		ldr	r0, [r3]
 2574 0082 2168     		ldr	r1, [r4]
 2575 0084 0431     		adds	r1, r1, #4
 2576 0086 FFF7FEFF 		bl	vListInsert
 2577              	.LVL268:
 2578 008a EDE7     		b	.L301
 2579              	.LBE176:
 2580              	.LBE175:
 2581              	.LBE177:
 2582              	.LBE178:
 2583              		.cfi_endproc
 2584              	.LFE126:
 2586              		.section	.text.prvIdleTask,"ax",%progbits
 2587              		.align	2
 2588              		.thumb
 2589              		.thumb_func
 2591              	prvIdleTask:
 2592              	.LFB150:
2554:Libraries/FreeRTOS/Source/tasks.c **** 	/* Stop warnings. */
 2593              		.loc 1 2554 0
 2594              		.cfi_startproc
 2595              		@ Volatile: function does not return.
 2596              		@ args = 0, pretend = 0, frame = 8
 2597              		@ frame_needed = 0, uses_anonymous_args = 0
 2598              	.LVL269:
 2599 0000 2DE98048 		push	{r7, fp, lr}
 2600              	.LCFI17:
 2601              		.cfi_def_cfa_offset 12
 2602              		.cfi_offset 7, -12
 2603              		.cfi_offset 11, -8
 2604              		.cfi_offset 14, -4
 2605 0004 40F20006 		movw	r6, #:lower16:.LANCHOR4
 2606 0008 83B0     		sub	sp, sp, #12
 2607              	.LCFI18:
 2608              		.cfi_def_cfa_offset 24
 2609 000a 40F20005 		movw	r5, #:lower16:.LANCHOR13
 2610 000e 40F20002 		movw	r2, #:lower16:.LANCHOR8
 2611 0012 C0F20006 		movt	r6, #:upper16:.LANCHOR4
 2612 0016 C0F20005 		movt	r5, #:upper16:.LANCHOR13
 2613 001a 40F20004 		movw	r4, #:lower16:.LANCHOR14
 2614 001e 40F20009 		movw	r9, #:lower16:.LANCHOR0
 2615 0022 C0F20002 		movt	r2, #:upper16:.LANCHOR8
 2616              	.LBB187:
 2617              	.LBB188:
2852:Libraries/FreeRTOS/Source/tasks.c **** 			}
 2618              		.loc 1 2852 0
 2619 0026 B246     		mov	r10, r6
2848:Libraries/FreeRTOS/Source/tasks.c **** 		{
 2620              		.loc 1 2848 0
 2621 0028 A846     		mov	r8, r5
 2622 002a C0F20004 		movt	r4, #:upper16:.LANCHOR14
 2623 002e 0192     		str	r2, [sp, #4]
 2624 0030 C0F20009 		movt	r9, #:upper16:.LANCHOR0
 2625 0034 06E0     		b	.L309
 2626              	.LVL270:
 2627              	.L312:
 2628              	.LBB189:
 2629              	.LBB190:
1550:Libraries/FreeRTOS/Source/tasks.c **** }
 2630              		.loc 1 1550 0
 2631 0036 2368     		ldr	r3, [r4]
 2632              	.LBE190:
 2633              	.LBE189:
2852:Libraries/FreeRTOS/Source/tasks.c **** 			}
 2634              		.loc 1 2852 0
 2635 0038 3768     		ldr	r7, [r6]
 2636              	.LVL271:
 2637              	.LBB192:
 2638              	.LBB191:
1550:Libraries/FreeRTOS/Source/tasks.c **** }
 2639              		.loc 1 1550 0
 2640 003a 0133     		adds	r3, r3, #1
 2641 003c 2360     		str	r3, [r4]
 2642              	.LBE191:
 2643              	.LBE192:
2854:Libraries/FreeRTOS/Source/tasks.c **** 
 2644              		.loc 1 2854 0
 2645 003e FFF7FEFF 		bl	xTaskResumeAll
 2646              	.LVL272:
2856:Libraries/FreeRTOS/Source/tasks.c **** 			{
 2647              		.loc 1 2856 0
 2648 0042 4FB9     		cbnz	r7, .L314
 2649              	.LVL273:
 2650              	.L309:
2848:Libraries/FreeRTOS/Source/tasks.c **** 		{
 2651              		.loc 1 2848 0
 2652 0044 2B68     		ldr	r3, [r5]
 2653 0046 002B     		cmp	r3, #0
 2654 0048 F5D1     		bne	.L312
 2655              	.LBE188:
 2656              	.LBE187:
2584:Libraries/FreeRTOS/Source/tasks.c **** 			{
 2657              		.loc 1 2584 0
 2658 004a D9F80030 		ldr	r3, [r9]
 2659 004e 012B     		cmp	r3, #1
 2660 0050 F8D9     		bls	.L309
2586:Libraries/FreeRTOS/Source/tasks.c **** 			}
 2661              		.loc 1 2586 0
 2662 0052 FFF7FEFF 		bl	vPortYield
 2663              	.LVL274:
 2664 0056 F5E7     		b	.L309
 2665              	.LVL275:
 2666              	.L314:
 2667              	.LBB197:
 2668              	.LBB196:
 2669              	.LBB193:
2860:Libraries/FreeRTOS/Source/tasks.c **** 				{
 2670              		.loc 1 2860 0
 2671 0058 FFF7FEFF 		bl	vPortEnterCritical
 2672              	.LVL276:
2862:Libraries/FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 2673              		.loc 1 2862 0
 2674 005c DAF80C30 		ldr	r3, [r10, #12]
 2675 0060 D3F80CB0 		ldr	fp, [r3, #12]
 2676              	.LVL277:
2863:Libraries/FreeRTOS/Source/tasks.c **** 					--uxCurrentNumberOfTasks;
 2677              		.loc 1 2863 0
 2678 0064 0BF10400 		add	r0, fp, #4
 2679 0068 FFF7FEFF 		bl	uxListRemove
 2680              	.LVL278:
2864:Libraries/FreeRTOS/Source/tasks.c **** 					--uxTasksDeleted;
 2681              		.loc 1 2864 0
 2682 006c 019A     		ldr	r2, [sp, #4]
 2683 006e 1368     		ldr	r3, [r2]
 2684 0070 013B     		subs	r3, r3, #1
 2685 0072 1360     		str	r3, [r2]
2865:Libraries/FreeRTOS/Source/tasks.c **** 				}
 2686              		.loc 1 2865 0
 2687 0074 D8F80030 		ldr	r3, [r8]
 2688 0078 013B     		subs	r3, r3, #1
 2689 007a C8F80030 		str	r3, [r8]
2867:Libraries/FreeRTOS/Source/tasks.c **** 
 2690              		.loc 1 2867 0
 2691 007e FFF7FEFF 		bl	vPortExitCritical
 2692              	.LVL279:
 2693              	.LBB194:
 2694              	.LBB195:
3097:Libraries/FreeRTOS/Source/tasks.c **** 		vPortFree( pxTCB );
 2695              		.loc 1 3097 0
 2696 0082 DBF83000 		ldr	r0, [fp, #48]
 2697 0086 FFF7FEFF 		bl	vPortFree
 2698              	.LVL280:
3098:Libraries/FreeRTOS/Source/tasks.c **** 	}
 2699              		.loc 1 3098 0
 2700 008a 5846     		mov	r0, fp
 2701 008c FFF7FEFF 		bl	vPortFree
 2702              	.LVL281:
 2703 0090 D8E7     		b	.L309
 2704              	.LBE195:
 2705              	.LBE194:
 2706              	.LBE193:
 2707              	.LBE196:
 2708              	.LBE197:
 2709              		.cfi_endproc
 2710              	.LFE150:
 2712 0092 00BF     		.section	.text.vTaskSwitchContext,"ax",%progbits
 2713              		.align	2
 2714              		.global	vTaskSwitchContext
 2715              		.thumb
 2716              		.thumb_func
 2718              	vTaskSwitchContext:
 2719              	.LFB141:
2115:Libraries/FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 2720              		.loc 1 2115 0
 2721              		.cfi_startproc
 2722              		@ args = 0, pretend = 0, frame = 0
 2723              		@ frame_needed = 0, uses_anonymous_args = 0
 2724 0000 08B5     		push	{r3, lr}
 2725              	.LCFI19:
 2726              		.cfi_def_cfa_offset 8
 2727              		.cfi_offset 3, -8
 2728              		.cfi_offset 14, -4
2116:Libraries/FreeRTOS/Source/tasks.c **** 	{
 2729              		.loc 1 2116 0
 2730 0002 40F20003 		movw	r3, #:lower16:.LANCHOR14
 2731 0006 C0F20003 		movt	r3, #:upper16:.LANCHOR14
 2732 000a 1968     		ldr	r1, [r3]
 2733 000c 0029     		cmp	r1, #0
 2734 000e 35D1     		bne	.L330
2124:Libraries/FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_OUT();
 2735              		.loc 1 2124 0
 2736 0010 40F20002 		movw	r2, #:lower16:.LANCHOR16
 2737 0014 C0F20002 		movt	r2, #:upper16:.LANCHOR16
2157:Libraries/FreeRTOS/Source/tasks.c **** 
 2738              		.loc 1 2157 0
 2739 0018 40F20003 		movw	r3, #:lower16:.LANCHOR12
 2740 001c C0F20003 		movt	r3, #:upper16:.LANCHOR12
2124:Libraries/FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_OUT();
 2741              		.loc 1 2124 0
 2742 0020 1160     		str	r1, [r2]
2157:Libraries/FreeRTOS/Source/tasks.c **** 
 2743              		.loc 1 2157 0
 2744 0022 1968     		ldr	r1, [r3]
 2745 0024 40F20002 		movw	r2, #:lower16:.LANCHOR0
 2746 0028 01EB8101 		add	r1, r1, r1, lsl #2
 2747 002c C0F20002 		movt	r2, #:upper16:.LANCHOR0
 2748 0030 52F82110 		ldr	r1, [r2, r1, lsl #2]
 2749 0034 79B9     		cbnz	r1, .L326
 2750 0036 1968     		ldr	r1, [r3]
 2751 0038 1846     		mov	r0, r3
 2752 003a 11B9     		cbnz	r1, .L324
 2753 003c 25E0     		b	.L323
 2754              	.L325:
2157:Libraries/FreeRTOS/Source/tasks.c **** 
 2755              		.loc 1 2157 0 is_stmt 0 discriminator 2
 2756 003e 0168     		ldr	r1, [r0]
 2757 0040 19B3     		cbz	r1, .L323
 2758              	.L324:
 2759 0042 1968     		ldr	r1, [r3]
 2760 0044 0139     		subs	r1, r1, #1
 2761 0046 1960     		str	r1, [r3]
 2762 0048 1968     		ldr	r1, [r3]
 2763 004a 01EB8101 		add	r1, r1, r1, lsl #2
 2764 004e 52F82110 		ldr	r1, [r2, r1, lsl #2]
 2765 0052 0029     		cmp	r1, #0
 2766 0054 F3D0     		beq	.L325
 2767              	.L326:
 2768              	.LBB198:
2157:Libraries/FreeRTOS/Source/tasks.c **** 
 2769              		.loc 1 2157 0
 2770 0056 1B68     		ldr	r3, [r3]
 2771 0058 03EB8303 		add	r3, r3, r3, lsl #2
 2772 005c 02EB8302 		add	r2, r2, r3, lsl #2
 2773              	.LVL282:
 2774 0060 02F10801 		add	r1, r2, #8
 2775 0064 5368     		ldr	r3, [r2, #4]
 2776 0066 5B68     		ldr	r3, [r3, #4]
 2777 0068 8B42     		cmp	r3, r1
 2778 006a 5360     		str	r3, [r2, #4]
 2779 006c 10D0     		beq	.L319
 2780              	.L320:
2157:Libraries/FreeRTOS/Source/tasks.c **** 
 2781              		.loc 1 2157 0 discriminator 2
 2782 006e 40F20002 		movw	r2, #:lower16:.LANCHOR9
 2783              	.LVL283:
 2784 0072 DB68     		ldr	r3, [r3, #12]
 2785 0074 C0F20002 		movt	r2, #:upper16:.LANCHOR9
 2786 0078 1360     		str	r3, [r2]
 2787 007a 08BD     		pop	{r3, pc}
 2788              	.LVL284:
 2789              	.L330:
 2790              	.LBE198:
2120:Libraries/FreeRTOS/Source/tasks.c **** 	}
 2791              		.loc 1 2120 0 is_stmt 1
 2792 007c 40F20003 		movw	r3, #:lower16:.LANCHOR16
 2793 0080 C0F20003 		movt	r3, #:upper16:.LANCHOR16
 2794 0084 0122     		movs	r2, #1
 2795 0086 1A60     		str	r2, [r3]
 2796 0088 08BD     		pop	{r3, pc}
 2797              	.L323:
2157:Libraries/FreeRTOS/Source/tasks.c **** 
 2798              		.loc 1 2157 0
 2799 008a FFF7FEFF 		bl	ulPortSetInterruptMask
 2800              	.LVL285:
 2801              	.L322:
 2802 008e FEE7     		b	.L322
 2803              	.LVL286:
 2804              	.L319:
 2805              	.LBB199:
2157:Libraries/FreeRTOS/Source/tasks.c **** 
 2806              		.loc 1 2157 0 is_stmt 0 discriminator 1
 2807 0090 5B68     		ldr	r3, [r3, #4]
 2808 0092 5360     		str	r3, [r2, #4]
 2809 0094 EBE7     		b	.L320
 2810              	.LBE199:
 2811              		.cfi_endproc
 2812              	.LFE141:
 2814 0096 00BF     		.section	.text.vTaskPlaceOnEventList,"ax",%progbits
 2815              		.align	2
 2816              		.global	vTaskPlaceOnEventList
 2817              		.thumb
 2818              		.thumb_func
 2820              	vTaskPlaceOnEventList:
 2821              	.LFB142:
2173:Libraries/FreeRTOS/Source/tasks.c **** TickType_t xTimeToWake;
 2822              		.loc 1 2173 0 is_stmt 1
 2823              		.cfi_startproc
 2824              		@ args = 0, pretend = 0, frame = 0
 2825              		@ frame_needed = 0, uses_anonymous_args = 0
 2826              	.LVL287:
 2827 0000 38B5     		push	{r3, r4, r5, lr}
 2828              	.LCFI20:
 2829              		.cfi_def_cfa_offset 16
 2830              		.cfi_offset 3, -16
 2831              		.cfi_offset 4, -12
 2832              		.cfi_offset 5, -8
 2833              		.cfi_offset 14, -4
2173:Libraries/FreeRTOS/Source/tasks.c **** TickType_t xTimeToWake;
 2834              		.loc 1 2173 0
 2835 0002 0D46     		mov	r5, r1
2176:Libraries/FreeRTOS/Source/tasks.c **** 
 2836              		.loc 1 2176 0
 2837 0004 0028     		cmp	r0, #0
 2838 0006 3FD0     		beq	.L337
2185:Libraries/FreeRTOS/Source/tasks.c **** 
 2839              		.loc 1 2185 0
 2840 0008 40F20004 		movw	r4, #:lower16:.LANCHOR9
 2841 000c C0F20004 		movt	r4, #:upper16:.LANCHOR9
 2842 0010 2168     		ldr	r1, [r4]
 2843              	.LVL288:
 2844 0012 1831     		adds	r1, r1, #24
 2845 0014 FFF7FEFF 		bl	vListInsert
 2846              	.LVL289:
2190:Libraries/FreeRTOS/Source/tasks.c **** 	{
 2847              		.loc 1 2190 0
 2848 0018 2068     		ldr	r0, [r4]
 2849 001a 0430     		adds	r0, r0, #4
 2850 001c FFF7FEFF 		bl	uxListRemove
 2851              	.LVL290:
2203:Libraries/FreeRTOS/Source/tasks.c **** 		{
 2852              		.loc 1 2203 0
 2853 0020 6B1C     		adds	r3, r5, #1
 2854 0022 27D0     		beq	.L338
2215:Libraries/FreeRTOS/Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
 2855              		.loc 1 2215 0
 2856 0024 40F20003 		movw	r3, #:lower16:.LANCHOR17
 2857 0028 C0F20003 		movt	r3, #:upper16:.LANCHOR17
 2858 002c 1968     		ldr	r1, [r3]
 2859              	.LBB204:
 2860              	.LBB205:
2884:Libraries/FreeRTOS/Source/tasks.c **** 
 2861              		.loc 1 2884 0
 2862 002e 2268     		ldr	r2, [r4]
2886:Libraries/FreeRTOS/Source/tasks.c **** 	{
 2863              		.loc 1 2886 0
 2864 0030 1B68     		ldr	r3, [r3]
 2865              	.LBE205:
 2866              	.LBE204:
2215:Libraries/FreeRTOS/Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
 2867              		.loc 1 2215 0
 2868 0032 0D44     		add	r5, r5, r1
 2869              	.LVL291:
 2870              	.LBB212:
 2871              	.LBB210:
2886:Libraries/FreeRTOS/Source/tasks.c **** 	{
 2872              		.loc 1 2886 0
 2873 0034 9D42     		cmp	r5, r3
2884:Libraries/FreeRTOS/Source/tasks.c **** 
 2874              		.loc 1 2884 0
 2875 0036 5560     		str	r5, [r2, #4]
2886:Libraries/FreeRTOS/Source/tasks.c **** 	{
 2876              		.loc 1 2886 0
 2877 0038 11D3     		bcc	.L339
2894:Libraries/FreeRTOS/Source/tasks.c **** 
 2878              		.loc 1 2894 0
 2879 003a 40F20003 		movw	r3, #:lower16:.LANCHOR6
 2880 003e C0F20003 		movt	r3, #:upper16:.LANCHOR6
 2881 0042 1868     		ldr	r0, [r3]
 2882 0044 2168     		ldr	r1, [r4]
 2883 0046 0431     		adds	r1, r1, #4
 2884 0048 FFF7FEFF 		bl	vListInsert
 2885              	.LVL292:
2899:Libraries/FreeRTOS/Source/tasks.c **** 		{
 2886              		.loc 1 2899 0
 2887 004c 40F20003 		movw	r3, #:lower16:.LANCHOR15
 2888 0050 C0F20003 		movt	r3, #:upper16:.LANCHOR15
 2889 0054 1A68     		ldr	r2, [r3]
 2890 0056 9542     		cmp	r5, r2
2901:Libraries/FreeRTOS/Source/tasks.c **** 		}
 2891              		.loc 1 2901 0
 2892 0058 38BF     		it	cc
 2893 005a 1D60     		strcc	r5, [r3]
 2894 005c 38BD     		pop	{r3, r4, r5, pc}
 2895              	.LVL293:
 2896              	.L339:
 2897              	.LBB206:
 2898              	.LBB207:
2889:Libraries/FreeRTOS/Source/tasks.c **** 	}
 2899              		.loc 1 2889 0
 2900 005e 40F20003 		movw	r3, #:lower16:.LANCHOR7
 2901 0062 C0F20003 		movt	r3, #:upper16:.LANCHOR7
 2902 0066 1868     		ldr	r0, [r3]
 2903 0068 2168     		ldr	r1, [r4]
 2904              	.LBE207:
 2905              	.LBE206:
 2906              	.LBE210:
 2907              	.LBE212:
2228:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 2908              		.loc 1 2228 0
 2909 006a BDE83840 		pop	{r3, r4, r5, lr}
 2910              	.LVL294:
 2911              	.LBB213:
 2912              	.LBB211:
 2913              	.LBB209:
 2914              	.LBB208:
2889:Libraries/FreeRTOS/Source/tasks.c **** 	}
 2915              		.loc 1 2889 0
 2916 006e 0431     		adds	r1, r1, #4
 2917 0070 FFF7FEBF 		b	vListInsert
 2918              	.LVL295:
 2919              	.L338:
 2920              	.LBE208:
 2921              	.LBE209:
 2922              	.LBE211:
 2923              	.LBE213:
2208:Libraries/FreeRTOS/Source/tasks.c **** 		}
 2924              		.loc 1 2208 0
 2925 0074 2168     		ldr	r1, [r4]
 2926 0076 40F20000 		movw	r0, #:lower16:.LANCHOR5
 2927 007a 0431     		adds	r1, r1, #4
 2928 007c C0F20000 		movt	r0, #:upper16:.LANCHOR5
2228:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 2929              		.loc 1 2228 0
 2930 0080 BDE83840 		pop	{r3, r4, r5, lr}
 2931              	.LVL296:
2208:Libraries/FreeRTOS/Source/tasks.c **** 		}
 2932              		.loc 1 2208 0
 2933 0084 FFF7FEBF 		b	vListInsertEnd
 2934              	.LVL297:
 2935              	.L337:
2176:Libraries/FreeRTOS/Source/tasks.c **** 
 2936              		.loc 1 2176 0 discriminator 1
 2937 0088 FFF7FEFF 		bl	ulPortSetInterruptMask
 2938              	.LVL298:
 2939              	.L333:
 2940 008c FEE7     		b	.L333
 2941              		.cfi_endproc
 2942              	.LFE142:
 2944 008e 00BF     		.section	.text.vTaskPlaceOnUnorderedEventList,"ax",%progbits
 2945              		.align	2
 2946              		.global	vTaskPlaceOnUnorderedEventList
 2947              		.thumb
 2948              		.thumb_func
 2950              	vTaskPlaceOnUnorderedEventList:
 2951              	.LFB143:
2232:Libraries/FreeRTOS/Source/tasks.c **** TickType_t xTimeToWake;
 2952              		.loc 1 2232 0
 2953              		.cfi_startproc
 2954              		@ args = 0, pretend = 0, frame = 0
 2955              		@ frame_needed = 0, uses_anonymous_args = 0
 2956              	.LVL299:
 2957 0000 38B5     		push	{r3, r4, r5, lr}
 2958              	.LCFI21:
 2959              		.cfi_def_cfa_offset 16
 2960              		.cfi_offset 3, -16
 2961              		.cfi_offset 4, -12
 2962              		.cfi_offset 5, -8
 2963              		.cfi_offset 14, -4
2232:Libraries/FreeRTOS/Source/tasks.c **** TickType_t xTimeToWake;
 2964              		.loc 1 2232 0
 2965 0002 1546     		mov	r5, r2
2235:Libraries/FreeRTOS/Source/tasks.c **** 
 2966              		.loc 1 2235 0
 2967 0004 0028     		cmp	r0, #0
 2968 0006 38D0     		beq	.L348
2239:Libraries/FreeRTOS/Source/tasks.c **** 
 2969              		.loc 1 2239 0
 2970 0008 40F20003 		movw	r3, #:lower16:.LANCHOR14
 2971 000c C0F20003 		movt	r3, #:upper16:.LANCHOR14
 2972 0010 1B68     		ldr	r3, [r3]
 2973 0012 13B9     		cbnz	r3, .L343
2239:Libraries/FreeRTOS/Source/tasks.c **** 
 2974              		.loc 1 2239 0 is_stmt 0 discriminator 1
 2975 0014 FFF7FEFF 		bl	ulPortSetInterruptMask
 2976              	.LVL300:
 2977              	.L344:
 2978 0018 FEE7     		b	.L344
 2979              	.LVL301:
 2980              	.L343:
2244:Libraries/FreeRTOS/Source/tasks.c **** 
 2981              		.loc 1 2244 0 is_stmt 1
 2982 001a 40F20004 		movw	r4, #:lower16:.LANCHOR9
 2983 001e C0F20004 		movt	r4, #:upper16:.LANCHOR9
 2984 0022 41F00041 		orr	r1, r1, #-2147483648
 2985              	.LVL302:
 2986 0026 2268     		ldr	r2, [r4]
 2987              	.LVL303:
2251:Libraries/FreeRTOS/Source/tasks.c **** 
 2988              		.loc 1 2251 0
 2989 0028 2368     		ldr	r3, [r4]
2244:Libraries/FreeRTOS/Source/tasks.c **** 
 2990              		.loc 1 2244 0
 2991 002a 9161     		str	r1, [r2, #24]
2251:Libraries/FreeRTOS/Source/tasks.c **** 
 2992              		.loc 1 2251 0
 2993 002c 03F11801 		add	r1, r3, #24
 2994 0030 FFF7FEFF 		bl	vListInsertEnd
 2995              	.LVL304:
2256:Libraries/FreeRTOS/Source/tasks.c **** 	{
 2996              		.loc 1 2256 0
 2997 0034 2068     		ldr	r0, [r4]
 2998 0036 0430     		adds	r0, r0, #4
 2999 0038 FFF7FEFF 		bl	uxListRemove
 3000              	.LVL305:
2269:Libraries/FreeRTOS/Source/tasks.c **** 		{
 3001              		.loc 1 2269 0
 3002 003c 6B1C     		adds	r3, r5, #1
 3003 003e 2AD0     		beq	.L349
2281:Libraries/FreeRTOS/Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
 3004              		.loc 1 2281 0
 3005 0040 40F20003 		movw	r3, #:lower16:.LANCHOR17
 3006 0044 C0F20003 		movt	r3, #:upper16:.LANCHOR17
 3007 0048 1968     		ldr	r1, [r3]
 3008              	.LBB218:
 3009              	.LBB219:
2884:Libraries/FreeRTOS/Source/tasks.c **** 
 3010              		.loc 1 2884 0
 3011 004a 2268     		ldr	r2, [r4]
2886:Libraries/FreeRTOS/Source/tasks.c **** 	{
 3012              		.loc 1 2886 0
 3013 004c 1B68     		ldr	r3, [r3]
 3014              	.LBE219:
 3015              	.LBE218:
2281:Libraries/FreeRTOS/Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
 3016              		.loc 1 2281 0
 3017 004e 0D44     		add	r5, r5, r1
 3018              	.LVL306:
 3019              	.LBB227:
 3020              	.LBB224:
2886:Libraries/FreeRTOS/Source/tasks.c **** 	{
 3021              		.loc 1 2886 0
 3022 0050 9D42     		cmp	r5, r3
2884:Libraries/FreeRTOS/Source/tasks.c **** 
 3023              		.loc 1 2884 0
 3024 0052 5560     		str	r5, [r2, #4]
2886:Libraries/FreeRTOS/Source/tasks.c **** 	{
 3025              		.loc 1 2886 0
 3026 0054 14D3     		bcc	.L350
2894:Libraries/FreeRTOS/Source/tasks.c **** 
 3027              		.loc 1 2894 0
 3028 0056 40F20003 		movw	r3, #:lower16:.LANCHOR6
 3029 005a C0F20003 		movt	r3, #:upper16:.LANCHOR6
 3030 005e 1868     		ldr	r0, [r3]
 3031 0060 2168     		ldr	r1, [r4]
 3032 0062 0431     		adds	r1, r1, #4
 3033 0064 FFF7FEFF 		bl	vListInsert
 3034              	.LVL307:
2899:Libraries/FreeRTOS/Source/tasks.c **** 		{
 3035              		.loc 1 2899 0
 3036 0068 40F20003 		movw	r3, #:lower16:.LANCHOR15
 3037 006c C0F20003 		movt	r3, #:upper16:.LANCHOR15
 3038 0070 1A68     		ldr	r2, [r3]
 3039 0072 9542     		cmp	r5, r2
2901:Libraries/FreeRTOS/Source/tasks.c **** 		}
 3040              		.loc 1 2901 0
 3041 0074 38BF     		it	cc
 3042 0076 1D60     		strcc	r5, [r3]
 3043 0078 38BD     		pop	{r3, r4, r5, pc}
 3044              	.LVL308:
 3045              	.L348:
 3046              	.LBE224:
 3047              	.LBE227:
2235:Libraries/FreeRTOS/Source/tasks.c **** 
 3048              		.loc 1 2235 0 discriminator 1
 3049 007a FFF7FEFF 		bl	ulPortSetInterruptMask
 3050              	.LVL309:
 3051              	.L342:
 3052 007e FEE7     		b	.L342
 3053              	.LVL310:
 3054              	.L350:
 3055              	.LBB228:
 3056              	.LBB225:
 3057              	.LBB220:
 3058              	.LBB221:
2889:Libraries/FreeRTOS/Source/tasks.c **** 	}
 3059              		.loc 1 2889 0
 3060 0080 40F20003 		movw	r3, #:lower16:.LANCHOR7
 3061 0084 C0F20003 		movt	r3, #:upper16:.LANCHOR7
 3062 0088 1868     		ldr	r0, [r3]
 3063 008a 2168     		ldr	r1, [r4]
 3064              	.LBE221:
 3065              	.LBE220:
 3066              	.LBE225:
 3067              	.LBE228:
2294:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 3068              		.loc 1 2294 0
 3069 008c BDE83840 		pop	{r3, r4, r5, lr}
 3070              	.LVL311:
 3071              	.LBB229:
 3072              	.LBB226:
 3073              	.LBB223:
 3074              	.LBB222:
2889:Libraries/FreeRTOS/Source/tasks.c **** 	}
 3075              		.loc 1 2889 0
 3076 0090 0431     		adds	r1, r1, #4
 3077 0092 FFF7FEBF 		b	vListInsert
 3078              	.LVL312:
 3079              	.L349:
 3080              	.LBE222:
 3081              	.LBE223:
 3082              	.LBE226:
 3083              	.LBE229:
2274:Libraries/FreeRTOS/Source/tasks.c **** 		}
 3084              		.loc 1 2274 0
 3085 0096 2168     		ldr	r1, [r4]
 3086 0098 40F20000 		movw	r0, #:lower16:.LANCHOR5
 3087 009c 0431     		adds	r1, r1, #4
 3088 009e C0F20000 		movt	r0, #:upper16:.LANCHOR5
2294:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 3089              		.loc 1 2294 0
 3090 00a2 BDE83840 		pop	{r3, r4, r5, lr}
 3091              	.LVL313:
2274:Libraries/FreeRTOS/Source/tasks.c **** 		}
 3092              		.loc 1 2274 0
 3093 00a6 FFF7FEBF 		b	vListInsertEnd
 3094              	.LVL314:
 3095              		.cfi_endproc
 3096              	.LFE143:
 3098 00aa 00BF     		.section	.text.vTaskPlaceOnEventListRestricted,"ax",%progbits
 3099              		.align	2
 3100              		.global	vTaskPlaceOnEventListRestricted
 3101              		.thumb
 3102              		.thumb_func
 3104              	vTaskPlaceOnEventListRestricted:
 3105              	.LFB144:
2300:Libraries/FreeRTOS/Source/tasks.c **** 	TickType_t xTimeToWake;
 3106              		.loc 1 2300 0
 3107              		.cfi_startproc
 3108              		@ args = 0, pretend = 0, frame = 0
 3109              		@ frame_needed = 0, uses_anonymous_args = 0
 3110              	.LVL315:
 3111 0000 38B5     		push	{r3, r4, r5, lr}
 3112              	.LCFI22:
 3113              		.cfi_def_cfa_offset 16
 3114              		.cfi_offset 3, -16
 3115              		.cfi_offset 4, -12
 3116              		.cfi_offset 5, -8
 3117              		.cfi_offset 14, -4
2300:Libraries/FreeRTOS/Source/tasks.c **** 	TickType_t xTimeToWake;
 3118              		.loc 1 2300 0
 3119 0002 0D46     		mov	r5, r1
2303:Libraries/FreeRTOS/Source/tasks.c **** 
 3120              		.loc 1 2303 0
 3121 0004 40B3     		cbz	r0, .L356
2315:Libraries/FreeRTOS/Source/tasks.c **** 
 3122              		.loc 1 2315 0
 3123 0006 40F20004 		movw	r4, #:lower16:.LANCHOR9
 3124 000a C0F20004 		movt	r4, #:upper16:.LANCHOR9
 3125 000e 2168     		ldr	r1, [r4]
 3126              	.LVL316:
 3127 0010 1831     		adds	r1, r1, #24
 3128 0012 FFF7FEFF 		bl	vListInsertEnd
 3129              	.LVL317:
2320:Libraries/FreeRTOS/Source/tasks.c **** 		{
 3130              		.loc 1 2320 0
 3131 0016 2068     		ldr	r0, [r4]
 3132 0018 0430     		adds	r0, r0, #4
 3133 001a FFF7FEFF 		bl	uxListRemove
 3134              	.LVL318:
2333:Libraries/FreeRTOS/Source/tasks.c **** 
 3135              		.loc 1 2333 0
 3136 001e 40F20003 		movw	r3, #:lower16:.LANCHOR17
 3137 0022 C0F20003 		movt	r3, #:upper16:.LANCHOR17
 3138 0026 1968     		ldr	r1, [r3]
 3139              	.LBB234:
 3140              	.LBB235:
2884:Libraries/FreeRTOS/Source/tasks.c **** 
 3141              		.loc 1 2884 0
 3142 0028 2268     		ldr	r2, [r4]
2886:Libraries/FreeRTOS/Source/tasks.c **** 	{
 3143              		.loc 1 2886 0
 3144 002a 1B68     		ldr	r3, [r3]
 3145              	.LBE235:
 3146              	.LBE234:
2333:Libraries/FreeRTOS/Source/tasks.c **** 
 3147              		.loc 1 2333 0
 3148 002c 0D44     		add	r5, r5, r1
 3149              	.LVL319:
 3150              	.LBB243:
 3151              	.LBB240:
2886:Libraries/FreeRTOS/Source/tasks.c **** 	{
 3152              		.loc 1 2886 0
 3153 002e 9D42     		cmp	r5, r3
2884:Libraries/FreeRTOS/Source/tasks.c **** 
 3154              		.loc 1 2884 0
 3155 0030 5560     		str	r5, [r2, #4]
2886:Libraries/FreeRTOS/Source/tasks.c **** 	{
 3156              		.loc 1 2886 0
 3157 0032 14D3     		bcc	.L357
2894:Libraries/FreeRTOS/Source/tasks.c **** 
 3158              		.loc 1 2894 0
 3159 0034 40F20003 		movw	r3, #:lower16:.LANCHOR6
 3160 0038 C0F20003 		movt	r3, #:upper16:.LANCHOR6
 3161 003c 1868     		ldr	r0, [r3]
 3162 003e 2168     		ldr	r1, [r4]
 3163 0040 0431     		adds	r1, r1, #4
 3164 0042 FFF7FEFF 		bl	vListInsert
 3165              	.LVL320:
2899:Libraries/FreeRTOS/Source/tasks.c **** 		{
 3166              		.loc 1 2899 0
 3167 0046 40F20003 		movw	r3, #:lower16:.LANCHOR15
 3168 004a C0F20003 		movt	r3, #:upper16:.LANCHOR15
 3169 004e 1A68     		ldr	r2, [r3]
 3170 0050 9542     		cmp	r5, r2
2901:Libraries/FreeRTOS/Source/tasks.c **** 		}
 3171              		.loc 1 2901 0
 3172 0052 38BF     		it	cc
 3173 0054 1D60     		strcc	r5, [r3]
 3174 0056 38BD     		pop	{r3, r4, r5, pc}
 3175              	.LVL321:
 3176              	.L356:
 3177              	.LBE240:
 3178              	.LBE243:
2303:Libraries/FreeRTOS/Source/tasks.c **** 
 3179              		.loc 1 2303 0 discriminator 1
 3180 0058 FFF7FEFF 		bl	ulPortSetInterruptMask
 3181              	.LVL322:
 3182              	.L353:
 3183 005c FEE7     		b	.L353
 3184              	.LVL323:
 3185              	.L357:
 3186              	.LBB244:
 3187              	.LBB241:
 3188              	.LBB236:
 3189              	.LBB237:
2889:Libraries/FreeRTOS/Source/tasks.c **** 	}
 3190              		.loc 1 2889 0
 3191 005e 40F20003 		movw	r3, #:lower16:.LANCHOR7
 3192 0062 C0F20003 		movt	r3, #:upper16:.LANCHOR7
 3193 0066 1868     		ldr	r0, [r3]
 3194 0068 2168     		ldr	r1, [r4]
 3195              	.LBE237:
 3196              	.LBE236:
 3197              	.LBE241:
 3198              	.LBE244:
2337:Libraries/FreeRTOS/Source/tasks.c **** 
 3199              		.loc 1 2337 0
 3200 006a BDE83840 		pop	{r3, r4, r5, lr}
 3201              	.LVL324:
 3202              	.LBB245:
 3203              	.LBB242:
 3204              	.LBB239:
 3205              	.LBB238:
2889:Libraries/FreeRTOS/Source/tasks.c **** 	}
 3206              		.loc 1 2889 0
 3207 006e 0431     		adds	r1, r1, #4
 3208 0070 FFF7FEBF 		b	vListInsert
 3209              	.LVL325:
 3210              	.LBE238:
 3211              	.LBE239:
 3212              	.LBE242:
 3213              	.LBE245:
 3214              		.cfi_endproc
 3215              	.LFE144:
 3217              		.section	.text.xTaskRemoveFromEventList,"ax",%progbits
 3218              		.align	2
 3219              		.global	xTaskRemoveFromEventList
 3220              		.thumb
 3221              		.thumb_func
 3223              	xTaskRemoveFromEventList:
 3224              	.LFB145:
2343:Libraries/FreeRTOS/Source/tasks.c **** TCB_t *pxUnblockedTCB;
 3225              		.loc 1 2343 0
 3226              		.cfi_startproc
 3227              		@ args = 0, pretend = 0, frame = 0
 3228              		@ frame_needed = 0, uses_anonymous_args = 0
 3229              	.LVL326:
 3230 0000 38B5     		push	{r3, r4, r5, lr}
 3231              	.LCFI23:
 3232              		.cfi_def_cfa_offset 16
 3233              		.cfi_offset 3, -16
 3234              		.cfi_offset 4, -12
 3235              		.cfi_offset 5, -8
 3236              		.cfi_offset 14, -4
2360:Libraries/FreeRTOS/Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
 3237              		.loc 1 2360 0
 3238 0002 C368     		ldr	r3, [r0, #12]
 3239 0004 DC68     		ldr	r4, [r3, #12]
 3240              	.LVL327:
2361:Libraries/FreeRTOS/Source/tasks.c **** 	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 3241              		.loc 1 2361 0
 3242 0006 002C     		cmp	r4, #0
 3243 0008 3CD0     		beq	.L366
2362:Libraries/FreeRTOS/Source/tasks.c **** 
 3244              		.loc 1 2362 0
 3245 000a 04F11805 		add	r5, r4, #24
 3246 000e 2846     		mov	r0, r5
 3247              	.LVL328:
 3248 0010 FFF7FEFF 		bl	uxListRemove
 3249              	.LVL329:
2364:Libraries/FreeRTOS/Source/tasks.c **** 	{
 3250              		.loc 1 2364 0
 3251 0014 40F20003 		movw	r3, #:lower16:.LANCHOR14
 3252 0018 C0F20003 		movt	r3, #:upper16:.LANCHOR14
 3253 001c 1B68     		ldr	r3, [r3]
 3254 001e 4BBB     		cbnz	r3, .L361
2366:Libraries/FreeRTOS/Source/tasks.c **** 		prvAddTaskToReadyList( pxUnblockedTCB );
 3255              		.loc 1 2366 0
 3256 0020 251D     		adds	r5, r4, #4
 3257 0022 2846     		mov	r0, r5
 3258 0024 FFF7FEFF 		bl	uxListRemove
 3259              	.LVL330:
2367:Libraries/FreeRTOS/Source/tasks.c **** 	}
 3260              		.loc 1 2367 0
 3261 0028 40F20002 		movw	r2, #:lower16:.LANCHOR12
 3262 002c C0F20002 		movt	r2, #:upper16:.LANCHOR12
 3263 0030 E36A     		ldr	r3, [r4, #44]
 3264 0032 1168     		ldr	r1, [r2]
 3265 0034 40F20000 		movw	r0, #:lower16:.LANCHOR0
 3266 0038 8B42     		cmp	r3, r1
 3267 003a 88BF     		it	hi
 3268 003c 1360     		strhi	r3, [r2]
 3269 003e C0F20000 		movt	r0, #:upper16:.LANCHOR0
 3270 0042 03EB8303 		add	r3, r3, r3, lsl #2
 3271 0046 2946     		mov	r1, r5
 3272 0048 00EB8300 		add	r0, r0, r3, lsl #2
 3273 004c FFF7FEFF 		bl	vListInsertEnd
 3274              	.LVL331:
 3275              	.L363:
2376:Libraries/FreeRTOS/Source/tasks.c **** 	{
 3276              		.loc 1 2376 0
 3277 0050 40F20003 		movw	r3, #:lower16:.LANCHOR9
 3278 0054 C0F20003 		movt	r3, #:upper16:.LANCHOR9
 3279 0058 E26A     		ldr	r2, [r4, #44]
 3280 005a 1B68     		ldr	r3, [r3]
 3281 005c DB6A     		ldr	r3, [r3, #44]
 3282 005e 9A42     		cmp	r2, r3
 3283              	.LVL332:
2385:Libraries/FreeRTOS/Source/tasks.c **** 	}
 3284              		.loc 1 2385 0
 3285 0060 81BF     		itttt	hi
 3286 0062 40F20003 		movwhi	r3, #:lower16:.LANCHOR16
 3287 0066 C0F20003 		movthi	r3, #:upper16:.LANCHOR16
 3288 006a 0120     		movhi	r0, #1
 3289 006c 1860     		strhi	r0, [r3]
2389:Libraries/FreeRTOS/Source/tasks.c **** 	}
 3290              		.loc 1 2389 0
 3291 006e 98BF     		it	ls
 3292 0070 0020     		movls	r0, #0
 3293              	.LVL333:
2393:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 3294              		.loc 1 2393 0
 3295 0072 38BD     		pop	{r3, r4, r5, pc}
 3296              	.LVL334:
 3297              	.L361:
2373:Libraries/FreeRTOS/Source/tasks.c **** 	}
 3298              		.loc 1 2373 0
 3299 0074 40F20000 		movw	r0, #:lower16:.LANCHOR3
 3300 0078 2946     		mov	r1, r5
 3301 007a C0F20000 		movt	r0, #:upper16:.LANCHOR3
 3302 007e FFF7FEFF 		bl	vListInsertEnd
 3303              	.LVL335:
 3304 0082 E5E7     		b	.L363
 3305              	.LVL336:
 3306              	.L366:
2361:Libraries/FreeRTOS/Source/tasks.c **** 	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 3307              		.loc 1 2361 0 discriminator 1
 3308 0084 FFF7FEFF 		bl	ulPortSetInterruptMask
 3309              	.LVL337:
 3310              	.L360:
 3311 0088 FEE7     		b	.L360
 3312              		.cfi_endproc
 3313              	.LFE145:
 3315 008a 00BF     		.section	.text.xTaskRemoveFromUnorderedEventList,"ax",%progbits
 3316              		.align	2
 3317              		.global	xTaskRemoveFromUnorderedEventList
 3318              		.thumb
 3319              		.thumb_func
 3321              	xTaskRemoveFromUnorderedEventList:
 3322              	.LFB146:
2397:Libraries/FreeRTOS/Source/tasks.c **** TCB_t *pxUnblockedTCB;
 3323              		.loc 1 2397 0
 3324              		.cfi_startproc
 3325              		@ args = 0, pretend = 0, frame = 0
 3326              		@ frame_needed = 0, uses_anonymous_args = 0
 3327              	.LVL338:
 3328 0000 38B5     		push	{r3, r4, r5, lr}
 3329              	.LCFI24:
 3330              		.cfi_def_cfa_offset 16
 3331              		.cfi_offset 3, -16
 3332              		.cfi_offset 4, -12
 3333              		.cfi_offset 5, -8
 3334              		.cfi_offset 14, -4
2403:Libraries/FreeRTOS/Source/tasks.c **** 
 3335              		.loc 1 2403 0
 3336 0002 40F20003 		movw	r3, #:lower16:.LANCHOR14
 3337 0006 C0F20003 		movt	r3, #:upper16:.LANCHOR14
 3338 000a 1A68     		ldr	r2, [r3]
 3339 000c 002A     		cmp	r2, #0
 3340 000e 30D0     		beq	.L375
2410:Libraries/FreeRTOS/Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
 3341              		.loc 1 2410 0
 3342 0010 C468     		ldr	r4, [r0, #12]
 3343              	.LVL339:
2406:Libraries/FreeRTOS/Source/tasks.c **** 
 3344              		.loc 1 2406 0
 3345 0012 41F00042 		orr	r2, r1, #-2147483648
 3346 0016 0260     		str	r2, [r0]
2411:Libraries/FreeRTOS/Source/tasks.c **** 	( void ) uxListRemove( pxEventListItem );
 3347              		.loc 1 2411 0
 3348 0018 74B3     		cbz	r4, .L376
2417:Libraries/FreeRTOS/Source/tasks.c **** 	prvAddTaskToReadyList( pxUnblockedTCB );
 3349              		.loc 1 2417 0
 3350 001a 251D     		adds	r5, r4, #4
2412:Libraries/FreeRTOS/Source/tasks.c **** 
 3351              		.loc 1 2412 0
 3352 001c FFF7FEFF 		bl	uxListRemove
 3353              	.LVL340:
2417:Libraries/FreeRTOS/Source/tasks.c **** 	prvAddTaskToReadyList( pxUnblockedTCB );
 3354              		.loc 1 2417 0
 3355 0020 2846     		mov	r0, r5
 3356 0022 FFF7FEFF 		bl	uxListRemove
 3357              	.LVL341:
2418:Libraries/FreeRTOS/Source/tasks.c **** 
 3358              		.loc 1 2418 0
 3359 0026 40F20002 		movw	r2, #:lower16:.LANCHOR12
 3360 002a C0F20002 		movt	r2, #:upper16:.LANCHOR12
 3361 002e E36A     		ldr	r3, [r4, #44]
 3362 0030 1168     		ldr	r1, [r2]
 3363 0032 40F20000 		movw	r0, #:lower16:.LANCHOR0
 3364 0036 8B42     		cmp	r3, r1
 3365 0038 88BF     		it	hi
 3366 003a 1360     		strhi	r3, [r2]
 3367 003c C0F20000 		movt	r0, #:upper16:.LANCHOR0
 3368 0040 03EB8303 		add	r3, r3, r3, lsl #2
 3369 0044 00EB8300 		add	r0, r0, r3, lsl #2
 3370 0048 2946     		mov	r1, r5
 3371 004a FFF7FEFF 		bl	vListInsertEnd
 3372              	.LVL342:
2420:Libraries/FreeRTOS/Source/tasks.c **** 	{
 3373              		.loc 1 2420 0
 3374 004e 40F20003 		movw	r3, #:lower16:.LANCHOR9
 3375 0052 C0F20003 		movt	r3, #:upper16:.LANCHOR9
 3376 0056 E26A     		ldr	r2, [r4, #44]
 3377 0058 1B68     		ldr	r3, [r3]
 3378 005a DB6A     		ldr	r3, [r3, #44]
 3379 005c 9A42     		cmp	r2, r3
 3380              	.LVL343:
2430:Libraries/FreeRTOS/Source/tasks.c **** 	}
 3381              		.loc 1 2430 0
 3382 005e 81BF     		itttt	hi
 3383 0060 40F20003 		movwhi	r3, #:lower16:.LANCHOR16
 3384 0064 C0F20003 		movthi	r3, #:upper16:.LANCHOR16
 3385 0068 0120     		movhi	r0, #1
 3386 006a 1860     		strhi	r0, [r3]
2434:Libraries/FreeRTOS/Source/tasks.c **** 	}
 3387              		.loc 1 2434 0
 3388 006c 98BF     		it	ls
 3389 006e 0020     		movls	r0, #0
 3390              	.LVL344:
2438:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 3391              		.loc 1 2438 0
 3392 0070 38BD     		pop	{r3, r4, r5, pc}
 3393              	.LVL345:
 3394              	.L375:
2403:Libraries/FreeRTOS/Source/tasks.c **** 
 3395              		.loc 1 2403 0 discriminator 1
 3396 0072 FFF7FEFF 		bl	ulPortSetInterruptMask
 3397              	.LVL346:
 3398              	.L369:
 3399 0076 FEE7     		b	.L369
 3400              	.LVL347:
 3401              	.L376:
2411:Libraries/FreeRTOS/Source/tasks.c **** 	( void ) uxListRemove( pxEventListItem );
 3402              		.loc 1 2411 0 discriminator 1
 3403 0078 FFF7FEFF 		bl	ulPortSetInterruptMask
 3404              	.LVL348:
 3405              	.L371:
 3406 007c FEE7     		b	.L371
 3407              		.cfi_endproc
 3408              	.LFE146:
 3410 007e 00BF     		.section	.text.vTaskSetTimeOutState,"ax",%progbits
 3411              		.align	2
 3412              		.global	vTaskSetTimeOutState
 3413              		.thumb
 3414              		.thumb_func
 3416              	vTaskSetTimeOutState:
 3417              	.LFB147:
2442:Libraries/FreeRTOS/Source/tasks.c **** 	configASSERT( pxTimeOut );
 3418              		.loc 1 2442 0
 3419              		.cfi_startproc
 3420              		@ args = 0, pretend = 0, frame = 0
 3421              		@ frame_needed = 0, uses_anonymous_args = 0
 3422              	.LVL349:
 3423 0000 08B5     		push	{r3, lr}
 3424              	.LCFI25:
 3425              		.cfi_def_cfa_offset 8
 3426              		.cfi_offset 3, -8
 3427              		.cfi_offset 14, -4
2443:Libraries/FreeRTOS/Source/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
 3428              		.loc 1 2443 0
 3429 0002 60B1     		cbz	r0, .L380
2444:Libraries/FreeRTOS/Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 3430              		.loc 1 2444 0
 3431 0004 40F20002 		movw	r2, #:lower16:.LANCHOR18
2445:Libraries/FreeRTOS/Source/tasks.c **** }
 3432              		.loc 1 2445 0
 3433 0008 40F20003 		movw	r3, #:lower16:.LANCHOR17
2444:Libraries/FreeRTOS/Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 3434              		.loc 1 2444 0
 3435 000c C0F20002 		movt	r2, #:upper16:.LANCHOR18
2445:Libraries/FreeRTOS/Source/tasks.c **** }
 3436              		.loc 1 2445 0
 3437 0010 C0F20003 		movt	r3, #:upper16:.LANCHOR17
2444:Libraries/FreeRTOS/Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 3438              		.loc 1 2444 0
 3439 0014 1268     		ldr	r2, [r2]
2445:Libraries/FreeRTOS/Source/tasks.c **** }
 3440              		.loc 1 2445 0
 3441 0016 1B68     		ldr	r3, [r3]
 3442 0018 80E80C00 		stmia	r0, {r2, r3}
 3443 001c 08BD     		pop	{r3, pc}
 3444              	.L380:
2443:Libraries/FreeRTOS/Source/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
 3445              		.loc 1 2443 0 discriminator 1
 3446 001e FFF7FEFF 		bl	ulPortSetInterruptMask
 3447              	.LVL350:
 3448              	.L379:
 3449 0022 FEE7     		b	.L379
 3450              		.cfi_endproc
 3451              	.LFE147:
 3453              		.section	.text.xTaskCheckForTimeOut,"ax",%progbits
 3454              		.align	2
 3455              		.global	xTaskCheckForTimeOut
 3456              		.thumb
 3457              		.thumb_func
 3459              	xTaskCheckForTimeOut:
 3460              	.LFB148:
2450:Libraries/FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
 3461              		.loc 1 2450 0
 3462              		.cfi_startproc
 3463              		@ args = 0, pretend = 0, frame = 0
 3464              		@ frame_needed = 0, uses_anonymous_args = 0
 3465              	.LVL351:
 3466 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 3467              	.LCFI26:
 3468              		.cfi_def_cfa_offset 24
 3469              		.cfi_offset 3, -24
 3470              		.cfi_offset 4, -20
 3471              		.cfi_offset 5, -16
 3472              		.cfi_offset 6, -12
 3473              		.cfi_offset 7, -8
 3474              		.cfi_offset 14, -4
2453:Libraries/FreeRTOS/Source/tasks.c **** 	configASSERT( pxTicksToWait );
 3475              		.loc 1 2453 0
 3476 0002 0446     		mov	r4, r0
2450:Libraries/FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
 3477              		.loc 1 2450 0
 3478 0004 0D46     		mov	r5, r1
2453:Libraries/FreeRTOS/Source/tasks.c **** 	configASSERT( pxTicksToWait );
 3479              		.loc 1 2453 0
 3480 0006 0028     		cmp	r0, #0
 3481 0008 31D0     		beq	.L392
2454:Libraries/FreeRTOS/Source/tasks.c **** 
 3482              		.loc 1 2454 0
 3483 000a 69B3     		cbz	r1, .L393
2456:Libraries/FreeRTOS/Source/tasks.c **** 	{
 3484              		.loc 1 2456 0
 3485 000c FFF7FEFF 		bl	vPortEnterCritical
 3486              	.LVL352:
 3487              	.LBB246:
2459:Libraries/FreeRTOS/Source/tasks.c **** 
 3488              		.loc 1 2459 0
 3489 0010 40F20003 		movw	r3, #:lower16:.LANCHOR17
2465:Libraries/FreeRTOS/Source/tasks.c **** 			{
 3490              		.loc 1 2465 0
 3491 0014 2E68     		ldr	r6, [r5]
2459:Libraries/FreeRTOS/Source/tasks.c **** 
 3492              		.loc 1 2459 0
 3493 0016 C0F20003 		movt	r3, #:upper16:.LANCHOR17
2465:Libraries/FreeRTOS/Source/tasks.c **** 			{
 3494              		.loc 1 2465 0
 3495 001a 721C     		adds	r2, r6, #1
2459:Libraries/FreeRTOS/Source/tasks.c **** 
 3496              		.loc 1 2459 0
 3497 001c 1868     		ldr	r0, [r3]
 3498              	.LVL353:
2465:Libraries/FreeRTOS/Source/tasks.c **** 			{
 3499              		.loc 1 2465 0
 3500 001e 1ED0     		beq	.L389
2472:Libraries/FreeRTOS/Source/tasks.c **** 		{
 3501              		.loc 1 2472 0
 3502 0020 40F20002 		movw	r2, #:lower16:.LANCHOR18
 3503 0024 C0F20002 		movt	r2, #:upper16:.LANCHOR18
 3504 0028 2168     		ldr	r1, [r4]
 3505 002a 1768     		ldr	r7, [r2]
 3506 002c B942     		cmp	r1, r7
 3507 002e 6168     		ldr	r1, [r4, #4]
 3508 0030 01D0     		beq	.L388
2472:Libraries/FreeRTOS/Source/tasks.c **** 		{
 3509              		.loc 1 2472 0 is_stmt 0 discriminator 1
 3510 0032 8842     		cmp	r0, r1
 3511 0034 0ED2     		bcs	.L391
 3512              	.L388:
2480:Libraries/FreeRTOS/Source/tasks.c **** 		{
 3513              		.loc 1 2480 0 is_stmt 1
 3514 0036 471A     		subs	r7, r0, r1
 3515 0038 BE42     		cmp	r6, r7
 3516 003a 0BD9     		bls	.L391
2483:Libraries/FreeRTOS/Source/tasks.c **** 			vTaskSetTimeOutState( pxTimeOut );
 3517              		.loc 1 2483 0
 3518 003c 301A     		subs	r0, r6, r0
 3519              	.LVL354:
 3520              	.LBB247:
 3521              	.LBB248:
2444:Libraries/FreeRTOS/Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 3522              		.loc 1 2444 0
 3523 003e 1268     		ldr	r2, [r2]
2445:Libraries/FreeRTOS/Source/tasks.c **** }
 3524              		.loc 1 2445 0
 3525 0040 1B68     		ldr	r3, [r3]
 3526              	.LBE248:
 3527              	.LBE247:
2483:Libraries/FreeRTOS/Source/tasks.c **** 			vTaskSetTimeOutState( pxTimeOut );
 3528              		.loc 1 2483 0
 3529 0042 0144     		add	r1, r1, r0
 3530 0044 2960     		str	r1, [r5]
 3531              	.LVL355:
2485:Libraries/FreeRTOS/Source/tasks.c **** 		}
 3532              		.loc 1 2485 0
 3533 0046 0025     		movs	r5, #0
 3534              	.LVL356:
 3535              	.LBB250:
 3536              	.LBB249:
2445:Libraries/FreeRTOS/Source/tasks.c **** }
 3537              		.loc 1 2445 0
 3538 0048 84E80C00 		stmia	r4, {r2, r3}
 3539              	.LVL357:
 3540              	.LBE249:
 3541              	.LBE250:
 3542              	.LBE246:
2492:Libraries/FreeRTOS/Source/tasks.c **** 
 3543              		.loc 1 2492 0
 3544 004c FFF7FEFF 		bl	vPortExitCritical
 3545              	.LVL358:
2495:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 3546              		.loc 1 2495 0
 3547 0050 2846     		mov	r0, r5
 3548 0052 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 3549              	.LVL359:
 3550              	.L391:
 3551              	.LBB251:
2478:Libraries/FreeRTOS/Source/tasks.c **** 		}
 3552              		.loc 1 2478 0
 3553 0054 0125     		movs	r5, #1
 3554              	.LVL360:
 3555              	.LBE251:
2492:Libraries/FreeRTOS/Source/tasks.c **** 
 3556              		.loc 1 2492 0
 3557 0056 FFF7FEFF 		bl	vPortExitCritical
 3558              	.LVL361:
2495:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 3559              		.loc 1 2495 0
 3560 005a 2846     		mov	r0, r5
 3561 005c F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 3562              	.LVL362:
 3563              	.L389:
 3564              	.LBB252:
2467:Libraries/FreeRTOS/Source/tasks.c **** 			}
 3565              		.loc 1 2467 0
 3566 005e 0025     		movs	r5, #0
 3567              	.LVL363:
 3568              	.LBE252:
2492:Libraries/FreeRTOS/Source/tasks.c **** 
 3569              		.loc 1 2492 0
 3570 0060 FFF7FEFF 		bl	vPortExitCritical
 3571              	.LVL364:
2495:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 3572              		.loc 1 2495 0
 3573 0064 2846     		mov	r0, r5
 3574 0066 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 3575              	.LVL365:
 3576              	.L393:
2454:Libraries/FreeRTOS/Source/tasks.c **** 
 3577              		.loc 1 2454 0 discriminator 1
 3578 0068 FFF7FEFF 		bl	ulPortSetInterruptMask
 3579              	.LVL366:
 3580              	.L385:
 3581 006c FEE7     		b	.L385
 3582              	.LVL367:
 3583              	.L392:
2453:Libraries/FreeRTOS/Source/tasks.c **** 	configASSERT( pxTicksToWait );
 3584              		.loc 1 2453 0 discriminator 1
 3585 006e FFF7FEFF 		bl	ulPortSetInterruptMask
 3586              	.LVL368:
 3587              	.L383:
 3588 0072 FEE7     		b	.L383
 3589              		.cfi_endproc
 3590              	.LFE148:
 3592              		.section	.text.vTaskMissedYield,"ax",%progbits
 3593              		.align	2
 3594              		.global	vTaskMissedYield
 3595              		.thumb
 3596              		.thumb_func
 3598              	vTaskMissedYield:
 3599              	.LFB149:
2499:Libraries/FreeRTOS/Source/tasks.c **** 	xYieldPending = pdTRUE;
 3600              		.loc 1 2499 0
 3601              		.cfi_startproc
 3602              		@ args = 0, pretend = 0, frame = 0
 3603              		@ frame_needed = 0, uses_anonymous_args = 0
 3604              		@ link register save eliminated.
2500:Libraries/FreeRTOS/Source/tasks.c **** }
 3605              		.loc 1 2500 0
 3606 0000 40F20003 		movw	r3, #:lower16:.LANCHOR16
 3607 0004 C0F20003 		movt	r3, #:upper16:.LANCHOR16
 3608 0008 0122     		movs	r2, #1
 3609 000a 1A60     		str	r2, [r3]
 3610 000c 7047     		bx	lr
 3611              		.cfi_endproc
 3612              	.LFE149:
 3614 000e 00BF     		.section	.text.xTaskGetCurrentTaskHandle,"ax",%progbits
 3615              		.align	2
 3616              		.global	xTaskGetCurrentTaskHandle
 3617              		.thumb
 3618              		.thumb_func
 3620              	xTaskGetCurrentTaskHandle:
 3621              	.LFB158:
3125:Libraries/FreeRTOS/Source/tasks.c **** 	}
3126:Libraries/FreeRTOS/Source/tasks.c **** }
3127:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3128:Libraries/FreeRTOS/Source/tasks.c **** 
3129:Libraries/FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
3130:Libraries/FreeRTOS/Source/tasks.c **** 
3131:Libraries/FreeRTOS/Source/tasks.c **** 	TaskHandle_t xTaskGetCurrentTaskHandle( void )
3132:Libraries/FreeRTOS/Source/tasks.c **** 	{
 3622              		.loc 1 3132 0
 3623              		.cfi_startproc
 3624              		@ args = 0, pretend = 0, frame = 0
 3625              		@ frame_needed = 0, uses_anonymous_args = 0
 3626              		@ link register save eliminated.
3133:Libraries/FreeRTOS/Source/tasks.c **** 	TaskHandle_t xReturn;
3134:Libraries/FreeRTOS/Source/tasks.c **** 
3135:Libraries/FreeRTOS/Source/tasks.c **** 		/* A critical section is not required as this is not called from
3136:Libraries/FreeRTOS/Source/tasks.c **** 		an interrupt and the current TCB will always be the same for any
3137:Libraries/FreeRTOS/Source/tasks.c **** 		individual execution thread. */
3138:Libraries/FreeRTOS/Source/tasks.c **** 		xReturn = pxCurrentTCB;
 3627              		.loc 1 3138 0
 3628 0000 40F20003 		movw	r3, #:lower16:.LANCHOR9
 3629 0004 C0F20003 		movt	r3, #:upper16:.LANCHOR9
 3630 0008 1868     		ldr	r0, [r3]
 3631              	.LVL369:
3139:Libraries/FreeRTOS/Source/tasks.c **** 
3140:Libraries/FreeRTOS/Source/tasks.c **** 		return xReturn;
3141:Libraries/FreeRTOS/Source/tasks.c **** 	}
 3632              		.loc 1 3141 0
 3633 000a 7047     		bx	lr
 3634              		.cfi_endproc
 3635              	.LFE158:
 3637              		.section	.text.xTaskGetSchedulerState,"ax",%progbits
 3638              		.align	2
 3639              		.global	xTaskGetSchedulerState
 3640              		.thumb
 3641              		.thumb_func
 3643              	xTaskGetSchedulerState:
 3644              	.LFB159:
3142:Libraries/FreeRTOS/Source/tasks.c **** 
3143:Libraries/FreeRTOS/Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
3144:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3145:Libraries/FreeRTOS/Source/tasks.c **** 
3146:Libraries/FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
3147:Libraries/FreeRTOS/Source/tasks.c **** 
3148:Libraries/FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskGetSchedulerState( void )
3149:Libraries/FreeRTOS/Source/tasks.c **** 	{
 3645              		.loc 1 3149 0
 3646              		.cfi_startproc
 3647              		@ args = 0, pretend = 0, frame = 0
 3648              		@ frame_needed = 0, uses_anonymous_args = 0
 3649              		@ link register save eliminated.
3150:Libraries/FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn;
3151:Libraries/FreeRTOS/Source/tasks.c **** 
3152:Libraries/FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning == pdFALSE )
 3650              		.loc 1 3152 0
 3651 0000 40F20003 		movw	r3, #:lower16:.LANCHOR10
 3652 0004 C0F20003 		movt	r3, #:upper16:.LANCHOR10
 3653 0008 1B68     		ldr	r3, [r3]
 3654 000a 4BB1     		cbz	r3, .L398
3153:Libraries/FreeRTOS/Source/tasks.c **** 		{
3154:Libraries/FreeRTOS/Source/tasks.c **** 			xReturn = taskSCHEDULER_NOT_STARTED;
3155:Libraries/FreeRTOS/Source/tasks.c **** 		}
3156:Libraries/FreeRTOS/Source/tasks.c **** 		else
3157:Libraries/FreeRTOS/Source/tasks.c **** 		{
3158:Libraries/FreeRTOS/Source/tasks.c **** 			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 3655              		.loc 1 3158 0
 3656 000c 40F20003 		movw	r3, #:lower16:.LANCHOR14
 3657 0010 C0F20003 		movt	r3, #:upper16:.LANCHOR14
 3658 0014 1868     		ldr	r0, [r3]
3159:Libraries/FreeRTOS/Source/tasks.c **** 			{
3160:Libraries/FreeRTOS/Source/tasks.c **** 				xReturn = taskSCHEDULER_RUNNING;
 3659              		.loc 1 3160 0
 3660 0016 0028     		cmp	r0, #0
 3661 0018 0CBF     		ite	eq
 3662 001a 0220     		moveq	r0, #2
 3663 001c 0020     		movne	r0, #0
 3664 001e 7047     		bx	lr
 3665              	.L398:
3154:Libraries/FreeRTOS/Source/tasks.c **** 		}
 3666              		.loc 1 3154 0
 3667 0020 0120     		movs	r0, #1
 3668              	.LVL370:
3161:Libraries/FreeRTOS/Source/tasks.c **** 			}
3162:Libraries/FreeRTOS/Source/tasks.c **** 			else
3163:Libraries/FreeRTOS/Source/tasks.c **** 			{
3164:Libraries/FreeRTOS/Source/tasks.c **** 				xReturn = taskSCHEDULER_SUSPENDED;
3165:Libraries/FreeRTOS/Source/tasks.c **** 			}
3166:Libraries/FreeRTOS/Source/tasks.c **** 		}
3167:Libraries/FreeRTOS/Source/tasks.c **** 
3168:Libraries/FreeRTOS/Source/tasks.c **** 		return xReturn;
3169:Libraries/FreeRTOS/Source/tasks.c **** 	}
 3669              		.loc 1 3169 0
 3670 0022 7047     		bx	lr
 3671              		.cfi_endproc
 3672              	.LFE159:
 3674              		.section	.text.vTaskPriorityInherit,"ax",%progbits
 3675              		.align	2
 3676              		.global	vTaskPriorityInherit
 3677              		.thumb
 3678              		.thumb_func
 3680              	vTaskPriorityInherit:
 3681              	.LFB160:
3170:Libraries/FreeRTOS/Source/tasks.c **** 
3171:Libraries/FreeRTOS/Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
3172:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3173:Libraries/FreeRTOS/Source/tasks.c **** 
3174:Libraries/FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
3175:Libraries/FreeRTOS/Source/tasks.c **** 
3176:Libraries/FreeRTOS/Source/tasks.c **** 	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
3177:Libraries/FreeRTOS/Source/tasks.c **** 	{
 3682              		.loc 1 3177 0
 3683              		.cfi_startproc
 3684              		@ args = 0, pretend = 0, frame = 0
 3685              		@ frame_needed = 0, uses_anonymous_args = 0
 3686              	.LVL371:
 3687 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 3688              	.LCFI27:
 3689              		.cfi_def_cfa_offset 24
 3690              		.cfi_offset 3, -24
 3691              		.cfi_offset 4, -20
 3692              		.cfi_offset 5, -16
 3693              		.cfi_offset 6, -12
 3694              		.cfi_offset 7, -8
 3695              		.cfi_offset 14, -4
3178:Libraries/FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
3179:Libraries/FreeRTOS/Source/tasks.c **** 
3180:Libraries/FreeRTOS/Source/tasks.c **** 		/* If the mutex was given back by an interrupt while the queue was
3181:Libraries/FreeRTOS/Source/tasks.c **** 		locked then the mutex holder might now be NULL. */
3182:Libraries/FreeRTOS/Source/tasks.c **** 		if( pxMutexHolder != NULL )
 3696              		.loc 1 3182 0
 3697 0002 0446     		mov	r4, r0
 3698 0004 F8B1     		cbz	r0, .L400
3183:Libraries/FreeRTOS/Source/tasks.c **** 		{
3184:Libraries/FreeRTOS/Source/tasks.c **** 			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 3699              		.loc 1 3184 0
 3700 0006 40F20005 		movw	r5, #:lower16:.LANCHOR9
 3701 000a C0F20005 		movt	r5, #:upper16:.LANCHOR9
 3702 000e C36A     		ldr	r3, [r0, #44]
 3703 0010 2A68     		ldr	r2, [r5]
 3704 0012 D26A     		ldr	r2, [r2, #44]
 3705 0014 9342     		cmp	r3, r2
 3706 0016 16D2     		bcs	.L400
3185:Libraries/FreeRTOS/Source/tasks.c **** 			{
3186:Libraries/FreeRTOS/Source/tasks.c **** 				/* Adjust the mutex holder state to account for its new
3187:Libraries/FreeRTOS/Source/tasks.c **** 				priority.  Only reset the event list item value if the value is
3188:Libraries/FreeRTOS/Source/tasks.c **** 				not	being used for anything else. */
3189:Libraries/FreeRTOS/Source/tasks.c **** 				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE 
 3707              		.loc 1 3189 0
 3708 0018 8269     		ldr	r2, [r0, #24]
 3709 001a 002A     		cmp	r2, #0
3190:Libraries/FreeRTOS/Source/tasks.c **** 				{
3191:Libraries/FreeRTOS/Source/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( T
 3710              		.loc 1 3191 0
 3711 001c A4BF     		itt	ge
 3712 001e 2A68     		ldrge	r2, [r5]
 3713 0020 D26A     		ldrge	r2, [r2, #44]
3192:Libraries/FreeRTOS/Source/tasks.c **** 				}
3193:Libraries/FreeRTOS/Source/tasks.c **** 				else
3194:Libraries/FreeRTOS/Source/tasks.c **** 				{
3195:Libraries/FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
3196:Libraries/FreeRTOS/Source/tasks.c **** 				}
3197:Libraries/FreeRTOS/Source/tasks.c **** 
3198:Libraries/FreeRTOS/Source/tasks.c **** 				/* If the task being modified is in the ready state it will need to
3199:Libraries/FreeRTOS/Source/tasks.c **** 				be moved into a new list. */
3200:Libraries/FreeRTOS/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericLis
 3714              		.loc 1 3200 0
 3715 0022 40F20006 		movw	r6, #:lower16:.LANCHOR0
3191:Libraries/FreeRTOS/Source/tasks.c **** 				}
 3716              		.loc 1 3191 0
 3717 0026 A4BF     		itt	ge
 3718 0028 C2F10502 		rsbge	r2, r2, #5
 3719 002c 8261     		strge	r2, [r0, #24]
 3720              		.loc 1 3200 0
 3721 002e 03EB8303 		add	r3, r3, r3, lsl #2
 3722 0032 C0F20006 		movt	r6, #:upper16:.LANCHOR0
 3723 0036 4269     		ldr	r2, [r0, #20]
 3724 0038 06EB8303 		add	r3, r6, r3, lsl #2
 3725 003c 9A42     		cmp	r2, r3
 3726 003e 03D0     		beq	.L411
3201:Libraries/FreeRTOS/Source/tasks.c **** 				{
3202:Libraries/FreeRTOS/Source/tasks.c **** 					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
3203:Libraries/FreeRTOS/Source/tasks.c **** 					{
3204:Libraries/FreeRTOS/Source/tasks.c **** 						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
3205:Libraries/FreeRTOS/Source/tasks.c **** 					}
3206:Libraries/FreeRTOS/Source/tasks.c **** 					else
3207:Libraries/FreeRTOS/Source/tasks.c **** 					{
3208:Libraries/FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
3209:Libraries/FreeRTOS/Source/tasks.c **** 					}
3210:Libraries/FreeRTOS/Source/tasks.c **** 
3211:Libraries/FreeRTOS/Source/tasks.c **** 					/* Inherit the priority before being moved into the new list. */
3212:Libraries/FreeRTOS/Source/tasks.c **** 					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
3213:Libraries/FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
3214:Libraries/FreeRTOS/Source/tasks.c **** 				}
3215:Libraries/FreeRTOS/Source/tasks.c **** 				else
3216:Libraries/FreeRTOS/Source/tasks.c **** 				{
3217:Libraries/FreeRTOS/Source/tasks.c **** 					/* Just inherit the priority. */
3218:Libraries/FreeRTOS/Source/tasks.c **** 					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 3727              		.loc 1 3218 0
 3728 0040 2B68     		ldr	r3, [r5]
 3729 0042 DB6A     		ldr	r3, [r3, #44]
 3730 0044 C362     		str	r3, [r0, #44]
 3731              	.L400:
 3732 0046 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 3733              	.L411:
3202:Libraries/FreeRTOS/Source/tasks.c **** 					{
 3734              		.loc 1 3202 0
 3735 0048 071D     		adds	r7, r0, #4
 3736 004a 3846     		mov	r0, r7
 3737              	.LVL372:
 3738 004c FFF7FEFF 		bl	uxListRemove
 3739              	.LVL373:
3213:Libraries/FreeRTOS/Source/tasks.c **** 				}
 3740              		.loc 1 3213 0
 3741 0050 40F20002 		movw	r2, #:lower16:.LANCHOR12
3212:Libraries/FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 3742              		.loc 1 3212 0
 3743 0054 2B68     		ldr	r3, [r5]
3213:Libraries/FreeRTOS/Source/tasks.c **** 				}
 3744              		.loc 1 3213 0
 3745 0056 C0F20002 		movt	r2, #:upper16:.LANCHOR12
3212:Libraries/FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 3746              		.loc 1 3212 0
 3747 005a DB6A     		ldr	r3, [r3, #44]
3213:Libraries/FreeRTOS/Source/tasks.c **** 				}
 3748              		.loc 1 3213 0
 3749 005c 1168     		ldr	r1, [r2]
3212:Libraries/FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 3750              		.loc 1 3212 0
 3751 005e E362     		str	r3, [r4, #44]
3213:Libraries/FreeRTOS/Source/tasks.c **** 				}
 3752              		.loc 1 3213 0
 3753 0060 8B42     		cmp	r3, r1
 3754 0062 03EB8300 		add	r0, r3, r3, lsl #2
 3755 0066 88BF     		it	hi
 3756 0068 1360     		strhi	r3, [r2]
 3757 006a 06EB8000 		add	r0, r6, r0, lsl #2
 3758 006e 3946     		mov	r1, r7
3219:Libraries/FreeRTOS/Source/tasks.c **** 				}
3220:Libraries/FreeRTOS/Source/tasks.c **** 
3221:Libraries/FreeRTOS/Source/tasks.c **** 				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
3222:Libraries/FreeRTOS/Source/tasks.c **** 			}
3223:Libraries/FreeRTOS/Source/tasks.c **** 			else
3224:Libraries/FreeRTOS/Source/tasks.c **** 			{
3225:Libraries/FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3226:Libraries/FreeRTOS/Source/tasks.c **** 			}
3227:Libraries/FreeRTOS/Source/tasks.c **** 		}
3228:Libraries/FreeRTOS/Source/tasks.c **** 		else
3229:Libraries/FreeRTOS/Source/tasks.c **** 		{
3230:Libraries/FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3231:Libraries/FreeRTOS/Source/tasks.c **** 		}
3232:Libraries/FreeRTOS/Source/tasks.c **** 	}
 3759              		.loc 1 3232 0
 3760 0070 BDE8F840 		pop	{r3, r4, r5, r6, r7, lr}
 3761              	.LVL374:
3213:Libraries/FreeRTOS/Source/tasks.c **** 				}
 3762              		.loc 1 3213 0
 3763 0074 FFF7FEBF 		b	vListInsertEnd
 3764              	.LVL375:
 3765              		.cfi_endproc
 3766              	.LFE160:
 3768              		.section	.text.vTaskPriorityDisinherit,"ax",%progbits
 3769              		.align	2
 3770              		.global	vTaskPriorityDisinherit
 3771              		.thumb
 3772              		.thumb_func
 3774              	vTaskPriorityDisinherit:
 3775              	.LFB161:
3233:Libraries/FreeRTOS/Source/tasks.c **** 
3234:Libraries/FreeRTOS/Source/tasks.c **** #endif /* configUSE_MUTEXES */
3235:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3236:Libraries/FreeRTOS/Source/tasks.c **** 
3237:Libraries/FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
3238:Libraries/FreeRTOS/Source/tasks.c **** 
3239:Libraries/FreeRTOS/Source/tasks.c **** 	void vTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
3240:Libraries/FreeRTOS/Source/tasks.c **** 	{
 3776              		.loc 1 3240 0
 3777              		.cfi_startproc
 3778              		@ args = 0, pretend = 0, frame = 0
 3779              		@ frame_needed = 0, uses_anonymous_args = 0
 3780              	.LVL376:
 3781 0000 38B5     		push	{r3, r4, r5, lr}
 3782              	.LCFI28:
 3783              		.cfi_def_cfa_offset 16
 3784              		.cfi_offset 3, -16
 3785              		.cfi_offset 4, -12
 3786              		.cfi_offset 5, -8
 3787              		.cfi_offset 14, -4
3241:Libraries/FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
3242:Libraries/FreeRTOS/Source/tasks.c **** 
3243:Libraries/FreeRTOS/Source/tasks.c **** 		if( pxMutexHolder != NULL )
 3788              		.loc 1 3243 0
 3789 0002 0446     		mov	r4, r0
 3790 0004 20B3     		cbz	r0, .L412
3244:Libraries/FreeRTOS/Source/tasks.c **** 		{
3245:Libraries/FreeRTOS/Source/tasks.c **** 			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 3791              		.loc 1 3245 0
 3792 0006 C26A     		ldr	r2, [r0, #44]
 3793 0008 436C     		ldr	r3, [r0, #68]
 3794 000a 9A42     		cmp	r2, r3
 3795 000c 20D0     		beq	.L412
3246:Libraries/FreeRTOS/Source/tasks.c **** 			{
3247:Libraries/FreeRTOS/Source/tasks.c **** 				/* We must be the running task to be able to give the mutex back.
3248:Libraries/FreeRTOS/Source/tasks.c **** 				Remove ourselves from the ready list we currently appear in. */
3249:Libraries/FreeRTOS/Source/tasks.c **** 				if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 3796              		.loc 1 3249 0
 3797 000e 051D     		adds	r5, r0, #4
 3798 0010 2846     		mov	r0, r5
 3799              	.LVL377:
 3800 0012 FFF7FEFF 		bl	uxListRemove
 3801              	.LVL378:
3250:Libraries/FreeRTOS/Source/tasks.c **** 				{
3251:Libraries/FreeRTOS/Source/tasks.c **** 					taskRESET_READY_PRIORITY( pxTCB->uxPriority );
3252:Libraries/FreeRTOS/Source/tasks.c **** 				}
3253:Libraries/FreeRTOS/Source/tasks.c **** 				else
3254:Libraries/FreeRTOS/Source/tasks.c **** 				{
3255:Libraries/FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
3256:Libraries/FreeRTOS/Source/tasks.c **** 				}
3257:Libraries/FreeRTOS/Source/tasks.c **** 
3258:Libraries/FreeRTOS/Source/tasks.c **** 				/* Disinherit the priority before adding the task into the new
3259:Libraries/FreeRTOS/Source/tasks.c **** 				ready list. */
3260:Libraries/FreeRTOS/Source/tasks.c **** 				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
3261:Libraries/FreeRTOS/Source/tasks.c **** 				pxTCB->uxPriority = pxTCB->uxBasePriority;
3262:Libraries/FreeRTOS/Source/tasks.c **** 
3263:Libraries/FreeRTOS/Source/tasks.c **** 				/* Only reset the event list item value if the value is not
3264:Libraries/FreeRTOS/Source/tasks.c **** 				being used for anything else. */
3265:Libraries/FreeRTOS/Source/tasks.c **** 				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE 
 3802              		.loc 1 3265 0
 3803 0016 A269     		ldr	r2, [r4, #24]
3261:Libraries/FreeRTOS/Source/tasks.c **** 
 3804              		.loc 1 3261 0
 3805 0018 636C     		ldr	r3, [r4, #68]
 3806              		.loc 1 3265 0
 3807 001a 002A     		cmp	r2, #0
3266:Libraries/FreeRTOS/Source/tasks.c **** 				{
3267:Libraries/FreeRTOS/Source/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( T
 3808              		.loc 1 3267 0
 3809 001c A4BF     		itt	ge
 3810 001e C3F10502 		rsbge	r2, r3, #5
 3811 0022 A261     		strge	r2, [r4, #24]
3268:Libraries/FreeRTOS/Source/tasks.c **** 				}
3269:Libraries/FreeRTOS/Source/tasks.c **** 				else
3270:Libraries/FreeRTOS/Source/tasks.c **** 				{
3271:Libraries/FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
3272:Libraries/FreeRTOS/Source/tasks.c **** 				}
3273:Libraries/FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyList( pxTCB );
 3812              		.loc 1 3273 0
 3813 0024 40F20002 		movw	r2, #:lower16:.LANCHOR12
 3814 0028 C0F20002 		movt	r2, #:upper16:.LANCHOR12
 3815 002c 40F20000 		movw	r0, #:lower16:.LANCHOR0
 3816 0030 1168     		ldr	r1, [r2]
3261:Libraries/FreeRTOS/Source/tasks.c **** 
 3817              		.loc 1 3261 0
 3818 0032 E362     		str	r3, [r4, #44]
 3819              		.loc 1 3273 0
 3820 0034 8B42     		cmp	r3, r1
 3821 0036 88BF     		it	hi
 3822 0038 1360     		strhi	r3, [r2]
 3823 003a C0F20000 		movt	r0, #:upper16:.LANCHOR0
 3824 003e 03EB8303 		add	r3, r3, r3, lsl #2
 3825 0042 2946     		mov	r1, r5
 3826 0044 00EB8300 		add	r0, r0, r3, lsl #2
3274:Libraries/FreeRTOS/Source/tasks.c **** 			}
3275:Libraries/FreeRTOS/Source/tasks.c **** 			else
3276:Libraries/FreeRTOS/Source/tasks.c **** 			{
3277:Libraries/FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3278:Libraries/FreeRTOS/Source/tasks.c **** 			}
3279:Libraries/FreeRTOS/Source/tasks.c **** 		}
3280:Libraries/FreeRTOS/Source/tasks.c **** 		else
3281:Libraries/FreeRTOS/Source/tasks.c **** 		{
3282:Libraries/FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3283:Libraries/FreeRTOS/Source/tasks.c **** 		}
3284:Libraries/FreeRTOS/Source/tasks.c **** 	}
 3827              		.loc 1 3284 0
 3828 0048 BDE83840 		pop	{r3, r4, r5, lr}
 3829              	.LVL379:
3273:Libraries/FreeRTOS/Source/tasks.c **** 			}
 3830              		.loc 1 3273 0
 3831 004c FFF7FEBF 		b	vListInsertEnd
 3832              	.LVL380:
 3833              	.L412:
 3834 0050 38BD     		pop	{r3, r4, r5, pc}
 3835              		.cfi_endproc
 3836              	.LFE161:
 3838 0052 00BF     		.section	.text.uxTaskResetEventItemValue,"ax",%progbits
 3839              		.align	2
 3840              		.global	uxTaskResetEventItemValue
 3841              		.thumb
 3842              		.thumb_func
 3844              	uxTaskResetEventItemValue:
 3845              	.LFB162:
3285:Libraries/FreeRTOS/Source/tasks.c **** 
3286:Libraries/FreeRTOS/Source/tasks.c **** #endif /* configUSE_MUTEXES */
3287:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3288:Libraries/FreeRTOS/Source/tasks.c **** 
3289:Libraries/FreeRTOS/Source/tasks.c **** #if ( portCRITICAL_NESTING_IN_TCB == 1 )
3290:Libraries/FreeRTOS/Source/tasks.c **** 
3291:Libraries/FreeRTOS/Source/tasks.c **** 	void vTaskEnterCritical( void )
3292:Libraries/FreeRTOS/Source/tasks.c **** 	{
3293:Libraries/FreeRTOS/Source/tasks.c **** 		portDISABLE_INTERRUPTS();
3294:Libraries/FreeRTOS/Source/tasks.c **** 
3295:Libraries/FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
3296:Libraries/FreeRTOS/Source/tasks.c **** 		{
3297:Libraries/FreeRTOS/Source/tasks.c **** 			( pxCurrentTCB->uxCriticalNesting )++;
3298:Libraries/FreeRTOS/Source/tasks.c **** 		}
3299:Libraries/FreeRTOS/Source/tasks.c **** 		else
3300:Libraries/FreeRTOS/Source/tasks.c **** 		{
3301:Libraries/FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3302:Libraries/FreeRTOS/Source/tasks.c **** 		}
3303:Libraries/FreeRTOS/Source/tasks.c **** 	}
3304:Libraries/FreeRTOS/Source/tasks.c **** 
3305:Libraries/FreeRTOS/Source/tasks.c **** #endif /* portCRITICAL_NESTING_IN_TCB */
3306:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3307:Libraries/FreeRTOS/Source/tasks.c **** 
3308:Libraries/FreeRTOS/Source/tasks.c **** #if ( portCRITICAL_NESTING_IN_TCB == 1 )
3309:Libraries/FreeRTOS/Source/tasks.c **** 
3310:Libraries/FreeRTOS/Source/tasks.c **** 	void vTaskExitCritical( void )
3311:Libraries/FreeRTOS/Source/tasks.c **** 	{
3312:Libraries/FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
3313:Libraries/FreeRTOS/Source/tasks.c **** 		{
3314:Libraries/FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->uxCriticalNesting > 0U )
3315:Libraries/FreeRTOS/Source/tasks.c **** 			{
3316:Libraries/FreeRTOS/Source/tasks.c **** 				( pxCurrentTCB->uxCriticalNesting )--;
3317:Libraries/FreeRTOS/Source/tasks.c **** 
3318:Libraries/FreeRTOS/Source/tasks.c **** 				if( pxCurrentTCB->uxCriticalNesting == 0U )
3319:Libraries/FreeRTOS/Source/tasks.c **** 				{
3320:Libraries/FreeRTOS/Source/tasks.c **** 					portENABLE_INTERRUPTS();
3321:Libraries/FreeRTOS/Source/tasks.c **** 				}
3322:Libraries/FreeRTOS/Source/tasks.c **** 				else
3323:Libraries/FreeRTOS/Source/tasks.c **** 				{
3324:Libraries/FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
3325:Libraries/FreeRTOS/Source/tasks.c **** 				}
3326:Libraries/FreeRTOS/Source/tasks.c **** 			}
3327:Libraries/FreeRTOS/Source/tasks.c **** 			else
3328:Libraries/FreeRTOS/Source/tasks.c **** 			{
3329:Libraries/FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3330:Libraries/FreeRTOS/Source/tasks.c **** 			}
3331:Libraries/FreeRTOS/Source/tasks.c **** 		}
3332:Libraries/FreeRTOS/Source/tasks.c **** 		else
3333:Libraries/FreeRTOS/Source/tasks.c **** 		{
3334:Libraries/FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3335:Libraries/FreeRTOS/Source/tasks.c **** 		}
3336:Libraries/FreeRTOS/Source/tasks.c **** 	}
3337:Libraries/FreeRTOS/Source/tasks.c **** 
3338:Libraries/FreeRTOS/Source/tasks.c **** #endif /* portCRITICAL_NESTING_IN_TCB */
3339:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3340:Libraries/FreeRTOS/Source/tasks.c **** 
3341:Libraries/FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) )
3342:Libraries/FreeRTOS/Source/tasks.c **** 
3343:Libraries/FreeRTOS/Source/tasks.c **** 	void vTaskList( char * pcWriteBuffer )
3344:Libraries/FreeRTOS/Source/tasks.c **** 	{
3345:Libraries/FreeRTOS/Source/tasks.c **** 	TaskStatus_t *pxTaskStatusArray;
3346:Libraries/FreeRTOS/Source/tasks.c **** 	volatile UBaseType_t uxArraySize, x;
3347:Libraries/FreeRTOS/Source/tasks.c **** 	char cStatus;
3348:Libraries/FreeRTOS/Source/tasks.c **** 
3349:Libraries/FreeRTOS/Source/tasks.c **** 		/*
3350:Libraries/FreeRTOS/Source/tasks.c **** 		 * PLEASE NOTE:
3351:Libraries/FreeRTOS/Source/tasks.c **** 		 *
3352:Libraries/FreeRTOS/Source/tasks.c **** 		 * This function is provided for convenience only, and is used by many
3353:Libraries/FreeRTOS/Source/tasks.c **** 		 * of the demo applications.  Do not consider it to be part of the
3354:Libraries/FreeRTOS/Source/tasks.c **** 		 * scheduler.
3355:Libraries/FreeRTOS/Source/tasks.c **** 		 *
3356:Libraries/FreeRTOS/Source/tasks.c **** 		 * vTaskList() calls uxTaskGetSystemState(), then formats part of the
3357:Libraries/FreeRTOS/Source/tasks.c **** 		 * uxTaskGetSystemState() output into a human readable table that
3358:Libraries/FreeRTOS/Source/tasks.c **** 		 * displays task names, states and stack usage.
3359:Libraries/FreeRTOS/Source/tasks.c **** 		 *
3360:Libraries/FreeRTOS/Source/tasks.c **** 		 * vTaskList() has a dependency on the sprintf() C library function that
3361:Libraries/FreeRTOS/Source/tasks.c **** 		 * might bloat the code size, use a lot of stack, and provide different
3362:Libraries/FreeRTOS/Source/tasks.c **** 		 * results on different platforms.  An alternative, tiny, third party,
3363:Libraries/FreeRTOS/Source/tasks.c **** 		 * and limited functionality implementation of sprintf() is provided in
3364:Libraries/FreeRTOS/Source/tasks.c **** 		 * many of the FreeRTOS/Demo sub-directories in a file called
3365:Libraries/FreeRTOS/Source/tasks.c **** 		 * printf-stdarg.c (note printf-stdarg.c does not provide a full
3366:Libraries/FreeRTOS/Source/tasks.c **** 		 * snprintf() implementation!).
3367:Libraries/FreeRTOS/Source/tasks.c **** 		 *
3368:Libraries/FreeRTOS/Source/tasks.c **** 		 * It is recommended that production systems call uxTaskGetSystemState()
3369:Libraries/FreeRTOS/Source/tasks.c **** 		 * directly to get access to raw stats data, rather than indirectly
3370:Libraries/FreeRTOS/Source/tasks.c **** 		 * through a call to vTaskList().
3371:Libraries/FreeRTOS/Source/tasks.c **** 		 */
3372:Libraries/FreeRTOS/Source/tasks.c **** 
3373:Libraries/FreeRTOS/Source/tasks.c **** 
3374:Libraries/FreeRTOS/Source/tasks.c **** 		/* Make sure the write buffer does not contain a string. */
3375:Libraries/FreeRTOS/Source/tasks.c **** 		*pcWriteBuffer = 0x00;
3376:Libraries/FreeRTOS/Source/tasks.c **** 
3377:Libraries/FreeRTOS/Source/tasks.c **** 		/* Take a snapshot of the number of tasks in case it changes while this
3378:Libraries/FreeRTOS/Source/tasks.c **** 		function is executing. */
3379:Libraries/FreeRTOS/Source/tasks.c **** 		uxArraySize = uxCurrentNumberOfTasks;
3380:Libraries/FreeRTOS/Source/tasks.c **** 
3381:Libraries/FreeRTOS/Source/tasks.c **** 		/* Allocate an array index for each task. */
3382:Libraries/FreeRTOS/Source/tasks.c **** 		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
3383:Libraries/FreeRTOS/Source/tasks.c **** 
3384:Libraries/FreeRTOS/Source/tasks.c **** 		if( pxTaskStatusArray != NULL )
3385:Libraries/FreeRTOS/Source/tasks.c **** 		{
3386:Libraries/FreeRTOS/Source/tasks.c **** 			/* Generate the (binary) data. */
3387:Libraries/FreeRTOS/Source/tasks.c **** 			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
3388:Libraries/FreeRTOS/Source/tasks.c **** 
3389:Libraries/FreeRTOS/Source/tasks.c **** 			/* Create a human readable table from the binary data. */
3390:Libraries/FreeRTOS/Source/tasks.c **** 			for( x = 0; x < uxArraySize; x++ )
3391:Libraries/FreeRTOS/Source/tasks.c **** 			{
3392:Libraries/FreeRTOS/Source/tasks.c **** 				switch( pxTaskStatusArray[ x ].eCurrentState )
3393:Libraries/FreeRTOS/Source/tasks.c **** 				{
3394:Libraries/FreeRTOS/Source/tasks.c **** 				case eReady:		cStatus = tskREADY_CHAR;
3395:Libraries/FreeRTOS/Source/tasks.c **** 									break;
3396:Libraries/FreeRTOS/Source/tasks.c **** 
3397:Libraries/FreeRTOS/Source/tasks.c **** 				case eBlocked:		cStatus = tskBLOCKED_CHAR;
3398:Libraries/FreeRTOS/Source/tasks.c **** 									break;
3399:Libraries/FreeRTOS/Source/tasks.c **** 
3400:Libraries/FreeRTOS/Source/tasks.c **** 				case eSuspended:	cStatus = tskSUSPENDED_CHAR;
3401:Libraries/FreeRTOS/Source/tasks.c **** 									break;
3402:Libraries/FreeRTOS/Source/tasks.c **** 
3403:Libraries/FreeRTOS/Source/tasks.c **** 				case eDeleted:		cStatus = tskDELETED_CHAR;
3404:Libraries/FreeRTOS/Source/tasks.c **** 									break;
3405:Libraries/FreeRTOS/Source/tasks.c **** 
3406:Libraries/FreeRTOS/Source/tasks.c **** 				default:			/* Should not get here, but it is included
3407:Libraries/FreeRTOS/Source/tasks.c **** 									to prevent static checking errors. */
3408:Libraries/FreeRTOS/Source/tasks.c **** 									cStatus = 0x00;
3409:Libraries/FreeRTOS/Source/tasks.c **** 									break;
3410:Libraries/FreeRTOS/Source/tasks.c **** 				}
3411:Libraries/FreeRTOS/Source/tasks.c **** 
3412:Libraries/FreeRTOS/Source/tasks.c **** 				sprintf( pcWriteBuffer, "%s\t\t%c\t%u\t%u\t%u\r\n", pxTaskStatusArray[ x ].pcTaskName, cStatus,
3413:Libraries/FreeRTOS/Source/tasks.c **** 				pcWriteBuffer += strlen( pcWriteBuffer );
3414:Libraries/FreeRTOS/Source/tasks.c **** 			}
3415:Libraries/FreeRTOS/Source/tasks.c **** 
3416:Libraries/FreeRTOS/Source/tasks.c **** 			/* Free the array again. */
3417:Libraries/FreeRTOS/Source/tasks.c **** 			vPortFree( pxTaskStatusArray );
3418:Libraries/FreeRTOS/Source/tasks.c **** 		}
3419:Libraries/FreeRTOS/Source/tasks.c **** 		else
3420:Libraries/FreeRTOS/Source/tasks.c **** 		{
3421:Libraries/FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3422:Libraries/FreeRTOS/Source/tasks.c **** 		}
3423:Libraries/FreeRTOS/Source/tasks.c **** 	}
3424:Libraries/FreeRTOS/Source/tasks.c **** 
3425:Libraries/FreeRTOS/Source/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) ) */
3426:Libraries/FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
3427:Libraries/FreeRTOS/Source/tasks.c **** 
3428:Libraries/FreeRTOS/Source/tasks.c **** #if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) )
3429:Libraries/FreeRTOS/Source/tasks.c **** 
3430:Libraries/FreeRTOS/Source/tasks.c **** 	void vTaskGetRunTimeStats( char *pcWriteBuffer )
3431:Libraries/FreeRTOS/Source/tasks.c **** 	{
3432:Libraries/FreeRTOS/Source/tasks.c **** 	TaskStatus_t *pxTaskStatusArray;
3433:Libraries/FreeRTOS/Source/tasks.c **** 	volatile UBaseType_t uxArraySize, x;
3434:Libraries/FreeRTOS/Source/tasks.c **** 	uint32_t ulTotalTime, ulStatsAsPercentage;
3435:Libraries/FreeRTOS/Source/tasks.c **** 
3436:Libraries/FreeRTOS/Source/tasks.c **** 		#if( configUSE_TRACE_FACILITY != 1 )
3437:Libraries/FreeRTOS/Source/tasks.c **** 		{
3438:Libraries/FreeRTOS/Source/tasks.c **** 			#error configUSE_TRACE_FACILITY must also be set to 1 in FreeRTOSConfig.h to use vTaskGetRunTime
3439:Libraries/FreeRTOS/Source/tasks.c **** 		}
3440:Libraries/FreeRTOS/Source/tasks.c **** 		#endif
3441:Libraries/FreeRTOS/Source/tasks.c **** 
3442:Libraries/FreeRTOS/Source/tasks.c **** 		/*
3443:Libraries/FreeRTOS/Source/tasks.c **** 		 * PLEASE NOTE:
3444:Libraries/FreeRTOS/Source/tasks.c **** 		 *
3445:Libraries/FreeRTOS/Source/tasks.c **** 		 * This function is provided for convenience only, and is used by many
3446:Libraries/FreeRTOS/Source/tasks.c **** 		 * of the demo applications.  Do not consider it to be part of the
3447:Libraries/FreeRTOS/Source/tasks.c **** 		 * scheduler.
3448:Libraries/FreeRTOS/Source/tasks.c **** 		 *
3449:Libraries/FreeRTOS/Source/tasks.c **** 		 * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part
3450:Libraries/FreeRTOS/Source/tasks.c **** 		 * of the uxTaskGetSystemState() output into a human readable table that
3451:Libraries/FreeRTOS/Source/tasks.c **** 		 * displays the amount of time each task has spent in the Running state
3452:Libraries/FreeRTOS/Source/tasks.c **** 		 * in both absolute and percentage terms.
3453:Libraries/FreeRTOS/Source/tasks.c **** 		 *
3454:Libraries/FreeRTOS/Source/tasks.c **** 		 * vTaskGetRunTimeStats() has a dependency on the sprintf() C library
3455:Libraries/FreeRTOS/Source/tasks.c **** 		 * function that might bloat the code size, use a lot of stack, and
3456:Libraries/FreeRTOS/Source/tasks.c **** 		 * provide different results on different platforms.  An alternative,
3457:Libraries/FreeRTOS/Source/tasks.c **** 		 * tiny, third party, and limited functionality implementation of
3458:Libraries/FreeRTOS/Source/tasks.c **** 		 * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in
3459:Libraries/FreeRTOS/Source/tasks.c **** 		 * a file called printf-stdarg.c (note printf-stdarg.c does not provide
3460:Libraries/FreeRTOS/Source/tasks.c **** 		 * a full snprintf() implementation!).
3461:Libraries/FreeRTOS/Source/tasks.c **** 		 *
3462:Libraries/FreeRTOS/Source/tasks.c **** 		 * It is recommended that production systems call uxTaskGetSystemState()
3463:Libraries/FreeRTOS/Source/tasks.c **** 		 * directly to get access to raw stats data, rather than indirectly
3464:Libraries/FreeRTOS/Source/tasks.c **** 		 * through a call to vTaskGetRunTimeStats().
3465:Libraries/FreeRTOS/Source/tasks.c **** 		 */
3466:Libraries/FreeRTOS/Source/tasks.c **** 
3467:Libraries/FreeRTOS/Source/tasks.c **** 		/* Make sure the write buffer does not contain a string. */
3468:Libraries/FreeRTOS/Source/tasks.c **** 		*pcWriteBuffer = 0x00;
3469:Libraries/FreeRTOS/Source/tasks.c **** 
3470:Libraries/FreeRTOS/Source/tasks.c **** 		/* Take a snapshot of the number of tasks in case it changes while this
3471:Libraries/FreeRTOS/Source/tasks.c **** 		function is executing. */
3472:Libraries/FreeRTOS/Source/tasks.c **** 		uxArraySize = uxCurrentNumberOfTasks;
3473:Libraries/FreeRTOS/Source/tasks.c **** 
3474:Libraries/FreeRTOS/Source/tasks.c **** 		/* Allocate an array index for each task. */
3475:Libraries/FreeRTOS/Source/tasks.c **** 		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
3476:Libraries/FreeRTOS/Source/tasks.c **** 
3477:Libraries/FreeRTOS/Source/tasks.c **** 		if( pxTaskStatusArray != NULL )
3478:Libraries/FreeRTOS/Source/tasks.c **** 		{
3479:Libraries/FreeRTOS/Source/tasks.c **** 			/* Generate the (binary) data. */
3480:Libraries/FreeRTOS/Source/tasks.c **** 			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
3481:Libraries/FreeRTOS/Source/tasks.c **** 
3482:Libraries/FreeRTOS/Source/tasks.c **** 			/* For percentage calculations. */
3483:Libraries/FreeRTOS/Source/tasks.c **** 			ulTotalTime /= 100UL;
3484:Libraries/FreeRTOS/Source/tasks.c **** 
3485:Libraries/FreeRTOS/Source/tasks.c **** 			/* Avoid divide by zero errors. */
3486:Libraries/FreeRTOS/Source/tasks.c **** 			if( ulTotalTime > 0 )
3487:Libraries/FreeRTOS/Source/tasks.c **** 			{
3488:Libraries/FreeRTOS/Source/tasks.c **** 				/* Create a human readable table from the binary data. */
3489:Libraries/FreeRTOS/Source/tasks.c **** 				for( x = 0; x < uxArraySize; x++ )
3490:Libraries/FreeRTOS/Source/tasks.c **** 				{
3491:Libraries/FreeRTOS/Source/tasks.c **** 					/* What percentage of the total run time has the task used?
3492:Libraries/FreeRTOS/Source/tasks.c **** 					This will always be rounded down to the nearest integer.
3493:Libraries/FreeRTOS/Source/tasks.c **** 					ulTotalRunTimeDiv100 has already been divided by 100. */
3494:Libraries/FreeRTOS/Source/tasks.c **** 					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
3495:Libraries/FreeRTOS/Source/tasks.c **** 
3496:Libraries/FreeRTOS/Source/tasks.c **** 					if( ulStatsAsPercentage > 0UL )
3497:Libraries/FreeRTOS/Source/tasks.c **** 					{
3498:Libraries/FreeRTOS/Source/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
3499:Libraries/FreeRTOS/Source/tasks.c **** 						{
3500:Libraries/FreeRTOS/Source/tasks.c **** 							sprintf( pcWriteBuffer, "%s\t\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].pcTaskName, pxTaskS
3501:Libraries/FreeRTOS/Source/tasks.c **** 						}
3502:Libraries/FreeRTOS/Source/tasks.c **** 						#else
3503:Libraries/FreeRTOS/Source/tasks.c **** 						{
3504:Libraries/FreeRTOS/Source/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
3505:Libraries/FreeRTOS/Source/tasks.c **** 							printf() library can be used. */
3506:Libraries/FreeRTOS/Source/tasks.c **** 							sprintf( pcWriteBuffer, "%s\t\t%u\t\t%u%%\r\n", pxTaskStatusArray[ x ].pcTaskName, ( unsigne
3507:Libraries/FreeRTOS/Source/tasks.c **** 						}
3508:Libraries/FreeRTOS/Source/tasks.c **** 						#endif
3509:Libraries/FreeRTOS/Source/tasks.c **** 					}
3510:Libraries/FreeRTOS/Source/tasks.c **** 					else
3511:Libraries/FreeRTOS/Source/tasks.c **** 					{
3512:Libraries/FreeRTOS/Source/tasks.c **** 						/* If the percentage is zero here then the task has
3513:Libraries/FreeRTOS/Source/tasks.c **** 						consumed less than 1% of the total run time. */
3514:Libraries/FreeRTOS/Source/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
3515:Libraries/FreeRTOS/Source/tasks.c **** 						{
3516:Libraries/FreeRTOS/Source/tasks.c **** 							sprintf( pcWriteBuffer, "%s\t\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].pcTaskName, pxTaskSt
3517:Libraries/FreeRTOS/Source/tasks.c **** 						}
3518:Libraries/FreeRTOS/Source/tasks.c **** 						#else
3519:Libraries/FreeRTOS/Source/tasks.c **** 						{
3520:Libraries/FreeRTOS/Source/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
3521:Libraries/FreeRTOS/Source/tasks.c **** 							printf() library can be used. */
3522:Libraries/FreeRTOS/Source/tasks.c **** 							sprintf( pcWriteBuffer, "%s\t\t%u\t\t<1%%\r\n", pxTaskStatusArray[ x ].pcTaskName, ( unsigne
3523:Libraries/FreeRTOS/Source/tasks.c **** 						}
3524:Libraries/FreeRTOS/Source/tasks.c **** 						#endif
3525:Libraries/FreeRTOS/Source/tasks.c **** 					}
3526:Libraries/FreeRTOS/Source/tasks.c **** 
3527:Libraries/FreeRTOS/Source/tasks.c **** 					pcWriteBuffer += strlen( pcWriteBuffer );
3528:Libraries/FreeRTOS/Source/tasks.c **** 				}
3529:Libraries/FreeRTOS/Source/tasks.c **** 			}
3530:Libraries/FreeRTOS/Source/tasks.c **** 			else
3531:Libraries/FreeRTOS/Source/tasks.c **** 			{
3532:Libraries/FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3533:Libraries/FreeRTOS/Source/tasks.c **** 			}
3534:Libraries/FreeRTOS/Source/tasks.c **** 
3535:Libraries/FreeRTOS/Source/tasks.c **** 			/* Free the array again. */
3536:Libraries/FreeRTOS/Source/tasks.c **** 			vPortFree( pxTaskStatusArray );
3537:Libraries/FreeRTOS/Source/tasks.c **** 		}
3538:Libraries/FreeRTOS/Source/tasks.c **** 		else
3539:Libraries/FreeRTOS/Source/tasks.c **** 		{
3540:Libraries/FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3541:Libraries/FreeRTOS/Source/tasks.c **** 		}
3542:Libraries/FreeRTOS/Source/tasks.c **** 	}
3543:Libraries/FreeRTOS/Source/tasks.c **** 
3544:Libraries/FreeRTOS/Source/tasks.c **** #endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
3545:Libraries/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3546:Libraries/FreeRTOS/Source/tasks.c **** 
3547:Libraries/FreeRTOS/Source/tasks.c **** TickType_t uxTaskResetEventItemValue( void )
3548:Libraries/FreeRTOS/Source/tasks.c **** {
 3846              		.loc 1 3548 0
 3847              		.cfi_startproc
 3848              		@ args = 0, pretend = 0, frame = 0
 3849              		@ frame_needed = 0, uses_anonymous_args = 0
 3850              		@ link register save eliminated.
3549:Libraries/FreeRTOS/Source/tasks.c **** TickType_t uxReturn;
3550:Libraries/FreeRTOS/Source/tasks.c **** 
3551:Libraries/FreeRTOS/Source/tasks.c **** 	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
 3851              		.loc 1 3551 0
 3852 0000 40F20003 		movw	r3, #:lower16:.LANCHOR9
 3853 0004 C0F20003 		movt	r3, #:upper16:.LANCHOR9
 3854 0008 1968     		ldr	r1, [r3]
3552:Libraries/FreeRTOS/Source/tasks.c **** 
3553:Libraries/FreeRTOS/Source/tasks.c **** 	/* Reset the event list item to its normal value - so it can be used with
3554:Libraries/FreeRTOS/Source/tasks.c **** 	queues and semaphores. */
3555:Libraries/FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES 
 3855              		.loc 1 3555 0
 3856 000a 1A68     		ldr	r2, [r3]
 3857 000c 1B68     		ldr	r3, [r3]
3551:Libraries/FreeRTOS/Source/tasks.c **** 
 3858              		.loc 1 3551 0
 3859 000e 8869     		ldr	r0, [r1, #24]
 3860              	.LVL381:
 3861              		.loc 1 3555 0
 3862 0010 DB6A     		ldr	r3, [r3, #44]
 3863 0012 C3F10503 		rsb	r3, r3, #5
 3864 0016 9361     		str	r3, [r2, #24]
3556:Libraries/FreeRTOS/Source/tasks.c **** 
3557:Libraries/FreeRTOS/Source/tasks.c **** 	return uxReturn;
3558:Libraries/FreeRTOS/Source/tasks.c **** }
 3865              		.loc 1 3558 0
 3866 0018 7047     		bx	lr
 3867              		.cfi_endproc
 3868              	.LFE162:
 3870              		.global	pxCurrentTCB
 3871 001a 00BF     		.section	.bss.pxDelayedTaskList,"aw",%nobits
 3872              		.align	2
 3873              		.set	.LANCHOR6,. + 0
 3876              	pxDelayedTaskList:
 3877 0000 00000000 		.space	4
 3878              		.section	.bss.xSchedulerRunning,"aw",%nobits
 3879              		.align	2
 3880              		.set	.LANCHOR10,. + 0
 3883              	xSchedulerRunning:
 3884 0000 00000000 		.space	4
 3885              		.section	.bss.uxTasksDeleted,"aw",%nobits
 3886              		.align	2
 3887              		.set	.LANCHOR13,. + 0
 3890              	uxTasksDeleted:
 3891 0000 00000000 		.space	4
 3892              		.section	.bss.xTasksWaitingTermination,"aw",%nobits
 3893              		.align	2
 3894              		.set	.LANCHOR4,. + 0
 3897              	xTasksWaitingTermination:
 3898 0000 00000000 		.space	20
 3898      00000000 
 3898      00000000 
 3898      00000000 
 3898      00000000 
 3899              		.section	.data.xNextTaskUnblockTime,"aw",%progbits
 3900              		.align	2
 3901              		.set	.LANCHOR15,. + 0
 3904              	xNextTaskUnblockTime:
 3905 0000 FFFFFFFF 		.word	-1
 3906              		.section	.bss.pxReadyTasksLists,"aw",%nobits
 3907              		.align	2
 3908              		.set	.LANCHOR0,. + 0
 3911              	pxReadyTasksLists:
 3912 0000 00000000 		.space	100
 3912      00000000 
 3912      00000000 
 3912      00000000 
 3912      00000000 
 3913              		.section	.bss.uxSchedulerSuspended,"aw",%nobits
 3914              		.align	2
 3915              		.set	.LANCHOR14,. + 0
 3918              	uxSchedulerSuspended:
 3919 0000 00000000 		.space	4
 3920              		.section	.bss.uxCurrentNumberOfTasks,"aw",%nobits
 3921              		.align	2
 3922              		.set	.LANCHOR8,. + 0
 3925              	uxCurrentNumberOfTasks:
 3926 0000 00000000 		.space	4
 3927              		.section	.bss.pxCurrentTCB,"aw",%nobits
 3928              		.align	2
 3929              		.set	.LANCHOR9,. + 0
 3932              	pxCurrentTCB:
 3933 0000 00000000 		.space	4
 3934              		.section	.bss.xPendingReadyList,"aw",%nobits
 3935              		.align	2
 3936              		.set	.LANCHOR3,. + 0
 3939              	xPendingReadyList:
 3940 0000 00000000 		.space	20
 3940      00000000 
 3940      00000000 
 3940      00000000 
 3940      00000000 
 3941              		.section	.bss.xNumOfOverflows,"aw",%nobits
 3942              		.align	2
 3943              		.set	.LANCHOR18,. + 0
 3946              	xNumOfOverflows:
 3947 0000 00000000 		.space	4
 3948              		.section	.bss.xTickCount,"aw",%nobits
 3949              		.align	2
 3950              		.set	.LANCHOR17,. + 0
 3953              	xTickCount:
 3954 0000 00000000 		.space	4
 3955              		.section	.bss.pxOverflowDelayedTaskList,"aw",%nobits
 3956              		.align	2
 3957              		.set	.LANCHOR7,. + 0
 3960              	pxOverflowDelayedTaskList:
 3961 0000 00000000 		.space	4
 3962              		.section	.bss.uxTaskNumber,"aw",%nobits
 3963              		.align	2
 3964              		.set	.LANCHOR11,. + 0
 3967              	uxTaskNumber:
 3968 0000 00000000 		.space	4
 3969              		.section	.bss.xDelayedTaskList1,"aw",%nobits
 3970              		.align	2
 3971              		.set	.LANCHOR1,. + 0
 3974              	xDelayedTaskList1:
 3975 0000 00000000 		.space	20
 3975      00000000 
 3975      00000000 
 3975      00000000 
 3975      00000000 
 3976              		.section	.bss.xDelayedTaskList2,"aw",%nobits
 3977              		.align	2
 3978              		.set	.LANCHOR2,. + 0
 3981              	xDelayedTaskList2:
 3982 0000 00000000 		.space	20
 3982      00000000 
 3982      00000000 
 3982      00000000 
 3982      00000000 
 3983              		.section	.bss.uxPendedTicks,"aw",%nobits
 3984              		.align	2
 3985              		.set	.LANCHOR19,. + 0
 3988              	uxPendedTicks:
 3989 0000 00000000 		.space	4
 3990              		.section	.bss.xSuspendedTaskList,"aw",%nobits
 3991              		.align	2
 3992              		.set	.LANCHOR5,. + 0
 3995              	xSuspendedTaskList:
 3996 0000 00000000 		.space	20
 3996      00000000 
 3996      00000000 
 3996      00000000 
 3996      00000000 
 3997              		.section	.bss.uxTopReadyPriority,"aw",%nobits
 3998              		.align	2
 3999              		.set	.LANCHOR12,. + 0
 4002              	uxTopReadyPriority:
 4003 0000 00000000 		.space	4
 4004              		.section	.bss.xYieldPending,"aw",%nobits
 4005              		.align	2
 4006              		.set	.LANCHOR16,. + 0
 4009              	xYieldPending:
 4010 0000 00000000 		.space	4
 4011              		.text
 4012              	.Letext0:
 4013              		.file 2 "/opt/toolchains/eabi/arm-2014.05/lib/gcc/arm-none-eabi/4.8.3/include/stddef.h"
 4014              		.file 3 "/opt/toolchains/eabi/arm-2014.05/arm-none-eabi/include/stdint.h"
 4015              		.file 4 "Libraries/FreeRTOS/Source/include/projdefs.h"
 4016              		.file 5 "Libraries/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h"
 4017              		.file 6 "Libraries/FreeRTOS/Source/include/list.h"
 4018              		.file 7 "Libraries/FreeRTOS/Source/include/task.h"
 4019              		.file 8 "Libraries/CMSIS/Include/core_cm4.h"
 4020              		.file 9 "Libraries/FreeRTOS/Source/include/portable.h"
 4021              		.file 10 "Libraries/FreeRTOS/Source/include/timers.h"
DEFINED SYMBOLS
                            *ABS*:00000000 tasks.c
     /tmp/ccCbytqi.s:21     .text.unlikely.prvInitialiseTaskLists:00000000 $t
     /tmp/ccCbytqi.s:25     .text.unlikely.prvInitialiseTaskLists:00000000 prvInitialiseTaskLists
     /tmp/ccCbytqi.s:3908   .bss.pxReadyTasksLists:00000000 .LANCHOR0
     /tmp/ccCbytqi.s:3971   .bss.xDelayedTaskList1:00000000 .LANCHOR1
     /tmp/ccCbytqi.s:3978   .bss.xDelayedTaskList2:00000000 .LANCHOR2
     /tmp/ccCbytqi.s:3936   .bss.xPendingReadyList:00000000 .LANCHOR3
     /tmp/ccCbytqi.s:3894   .bss.xTasksWaitingTermination:00000000 .LANCHOR4
     /tmp/ccCbytqi.s:3992   .bss.xSuspendedTaskList:00000000 .LANCHOR5
     /tmp/ccCbytqi.s:3873   .bss.pxDelayedTaskList:00000000 .LANCHOR6
     /tmp/ccCbytqi.s:3957   .bss.pxOverflowDelayedTaskList:00000000 .LANCHOR7
     /tmp/ccCbytqi.s:102    .text.xTaskGenericCreate:00000000 $t
     /tmp/ccCbytqi.s:107    .text.xTaskGenericCreate:00000000 xTaskGenericCreate
     /tmp/ccCbytqi.s:3922   .bss.uxCurrentNumberOfTasks:00000000 .LANCHOR8
     /tmp/ccCbytqi.s:3929   .bss.pxCurrentTCB:00000000 .LANCHOR9
     /tmp/ccCbytqi.s:3880   .bss.xSchedulerRunning:00000000 .LANCHOR10
     /tmp/ccCbytqi.s:3964   .bss.uxTaskNumber:00000000 .LANCHOR11
     /tmp/ccCbytqi.s:3999   .bss.uxTopReadyPriority:00000000 .LANCHOR12
     /tmp/ccCbytqi.s:495    .text.vTaskDelete:00000000 $t
     /tmp/ccCbytqi.s:500    .text.vTaskDelete:00000000 vTaskDelete
     /tmp/ccCbytqi.s:3887   .bss.uxTasksDeleted:00000000 .LANCHOR13
     /tmp/ccCbytqi.s:3901   .data.xNextTaskUnblockTime:00000000 .LANCHOR15
     /tmp/ccCbytqi.s:3915   .bss.uxSchedulerSuspended:00000000 .LANCHOR14
     /tmp/ccCbytqi.s:660    .text.uxTaskPriorityGet:00000000 $t
     /tmp/ccCbytqi.s:665    .text.uxTaskPriorityGet:00000000 uxTaskPriorityGet
     /tmp/ccCbytqi.s:714    .text.vTaskPrioritySet:00000000 $t
     /tmp/ccCbytqi.s:719    .text.vTaskPrioritySet:00000000 vTaskPrioritySet
     /tmp/ccCbytqi.s:876    .text.vTaskSuspend:00000000 $t
     /tmp/ccCbytqi.s:881    .text.vTaskSuspend:00000000 vTaskSuspend
     /tmp/ccCbytqi.s:4006   .bss.xYieldPending:00000000 .LANCHOR16
     /tmp/ccCbytqi.s:1121   .text.vTaskResume:00000000 $t
     /tmp/ccCbytqi.s:1126   .text.vTaskResume:00000000 vTaskResume
     /tmp/ccCbytqi.s:1232   .text.xTaskResumeFromISR:00000000 $t
     /tmp/ccCbytqi.s:1237   .text.xTaskResumeFromISR:00000000 xTaskResumeFromISR
     /tmp/ccCbytqi.s:1386   .text.vTaskStartScheduler:00000000 $t
     /tmp/ccCbytqi.s:1391   .text.vTaskStartScheduler:00000000 vTaskStartScheduler
     /tmp/ccCbytqi.s:2591   .text.prvIdleTask:00000000 prvIdleTask
     /tmp/ccCbytqi.s:3950   .bss.xTickCount:00000000 .LANCHOR17
     /tmp/ccCbytqi.s:1664   .text.vTaskEndScheduler:00000000 $t
     /tmp/ccCbytqi.s:1669   .text.vTaskEndScheduler:00000000 vTaskEndScheduler
     /tmp/ccCbytqi.s:1697   .text.vTaskSuspendAll:00000000 $t
     /tmp/ccCbytqi.s:1702   .text.vTaskSuspendAll:00000000 vTaskSuspendAll
     /tmp/ccCbytqi.s:1720   .text.xTaskGetTickCount:00000000 $t
     /tmp/ccCbytqi.s:1725   .text.xTaskGetTickCount:00000000 xTaskGetTickCount
     /tmp/ccCbytqi.s:1754   .text.xTaskGetTickCountFromISR:00000000 $t
     /tmp/ccCbytqi.s:1759   .text.xTaskGetTickCountFromISR:00000000 xTaskGetTickCountFromISR
     /tmp/ccCbytqi.s:1791   .text.uxTaskGetNumberOfTasks:00000000 $t
     /tmp/ccCbytqi.s:1796   .text.uxTaskGetNumberOfTasks:00000000 uxTaskGetNumberOfTasks
     /tmp/ccCbytqi.s:1813   .text.xTaskIncrementTick:00000000 $t
     /tmp/ccCbytqi.s:1818   .text.xTaskIncrementTick:00000000 xTaskIncrementTick
     /tmp/ccCbytqi.s:3985   .bss.uxPendedTicks:00000000 .LANCHOR19
     /tmp/ccCbytqi.s:3943   .bss.xNumOfOverflows:00000000 .LANCHOR18
     /tmp/ccCbytqi.s:2077   .text.xTaskResumeAll:00000000 $t
     /tmp/ccCbytqi.s:2082   .text.xTaskResumeAll:00000000 xTaskResumeAll
     /tmp/ccCbytqi.s:2248   .text.vTaskDelayUntil:00000000 $t
     /tmp/ccCbytqi.s:2253   .text.vTaskDelayUntil:00000000 vTaskDelayUntil
     /tmp/ccCbytqi.s:2446   .text.vTaskDelay:00000000 $t
     /tmp/ccCbytqi.s:2451   .text.vTaskDelay:00000000 vTaskDelay
     /tmp/ccCbytqi.s:2587   .text.prvIdleTask:00000000 $t
     /tmp/ccCbytqi.s:2713   .text.vTaskSwitchContext:00000000 $t
     /tmp/ccCbytqi.s:2718   .text.vTaskSwitchContext:00000000 vTaskSwitchContext
     /tmp/ccCbytqi.s:2815   .text.vTaskPlaceOnEventList:00000000 $t
     /tmp/ccCbytqi.s:2820   .text.vTaskPlaceOnEventList:00000000 vTaskPlaceOnEventList
     /tmp/ccCbytqi.s:2945   .text.vTaskPlaceOnUnorderedEventList:00000000 $t
     /tmp/ccCbytqi.s:2950   .text.vTaskPlaceOnUnorderedEventList:00000000 vTaskPlaceOnUnorderedEventList
     /tmp/ccCbytqi.s:3099   .text.vTaskPlaceOnEventListRestricted:00000000 $t
     /tmp/ccCbytqi.s:3104   .text.vTaskPlaceOnEventListRestricted:00000000 vTaskPlaceOnEventListRestricted
     /tmp/ccCbytqi.s:3218   .text.xTaskRemoveFromEventList:00000000 $t
     /tmp/ccCbytqi.s:3223   .text.xTaskRemoveFromEventList:00000000 xTaskRemoveFromEventList
     /tmp/ccCbytqi.s:3316   .text.xTaskRemoveFromUnorderedEventList:00000000 $t
     /tmp/ccCbytqi.s:3321   .text.xTaskRemoveFromUnorderedEventList:00000000 xTaskRemoveFromUnorderedEventList
     /tmp/ccCbytqi.s:3411   .text.vTaskSetTimeOutState:00000000 $t
     /tmp/ccCbytqi.s:3416   .text.vTaskSetTimeOutState:00000000 vTaskSetTimeOutState
     /tmp/ccCbytqi.s:3454   .text.xTaskCheckForTimeOut:00000000 $t
     /tmp/ccCbytqi.s:3459   .text.xTaskCheckForTimeOut:00000000 xTaskCheckForTimeOut
     /tmp/ccCbytqi.s:3593   .text.vTaskMissedYield:00000000 $t
     /tmp/ccCbytqi.s:3598   .text.vTaskMissedYield:00000000 vTaskMissedYield
     /tmp/ccCbytqi.s:3615   .text.xTaskGetCurrentTaskHandle:00000000 $t
     /tmp/ccCbytqi.s:3620   .text.xTaskGetCurrentTaskHandle:00000000 xTaskGetCurrentTaskHandle
     /tmp/ccCbytqi.s:3638   .text.xTaskGetSchedulerState:00000000 $t
     /tmp/ccCbytqi.s:3643   .text.xTaskGetSchedulerState:00000000 xTaskGetSchedulerState
     /tmp/ccCbytqi.s:3675   .text.vTaskPriorityInherit:00000000 $t
     /tmp/ccCbytqi.s:3680   .text.vTaskPriorityInherit:00000000 vTaskPriorityInherit
     /tmp/ccCbytqi.s:3769   .text.vTaskPriorityDisinherit:00000000 $t
     /tmp/ccCbytqi.s:3774   .text.vTaskPriorityDisinherit:00000000 vTaskPriorityDisinherit
     /tmp/ccCbytqi.s:3839   .text.uxTaskResetEventItemValue:00000000 $t
     /tmp/ccCbytqi.s:3844   .text.uxTaskResetEventItemValue:00000000 uxTaskResetEventItemValue
     /tmp/ccCbytqi.s:3932   .bss.pxCurrentTCB:00000000 pxCurrentTCB
     /tmp/ccCbytqi.s:3872   .bss.pxDelayedTaskList:00000000 $d
     /tmp/ccCbytqi.s:3876   .bss.pxDelayedTaskList:00000000 pxDelayedTaskList
     /tmp/ccCbytqi.s:3879   .bss.xSchedulerRunning:00000000 $d
     /tmp/ccCbytqi.s:3883   .bss.xSchedulerRunning:00000000 xSchedulerRunning
     /tmp/ccCbytqi.s:3886   .bss.uxTasksDeleted:00000000 $d
     /tmp/ccCbytqi.s:3890   .bss.uxTasksDeleted:00000000 uxTasksDeleted
     /tmp/ccCbytqi.s:3893   .bss.xTasksWaitingTermination:00000000 $d
     /tmp/ccCbytqi.s:3897   .bss.xTasksWaitingTermination:00000000 xTasksWaitingTermination
     /tmp/ccCbytqi.s:3900   .data.xNextTaskUnblockTime:00000000 $d
     /tmp/ccCbytqi.s:3904   .data.xNextTaskUnblockTime:00000000 xNextTaskUnblockTime
     /tmp/ccCbytqi.s:3907   .bss.pxReadyTasksLists:00000000 $d
     /tmp/ccCbytqi.s:3911   .bss.pxReadyTasksLists:00000000 pxReadyTasksLists
     /tmp/ccCbytqi.s:3914   .bss.uxSchedulerSuspended:00000000 $d
     /tmp/ccCbytqi.s:3918   .bss.uxSchedulerSuspended:00000000 uxSchedulerSuspended
     /tmp/ccCbytqi.s:3921   .bss.uxCurrentNumberOfTasks:00000000 $d
     /tmp/ccCbytqi.s:3925   .bss.uxCurrentNumberOfTasks:00000000 uxCurrentNumberOfTasks
     /tmp/ccCbytqi.s:3928   .bss.pxCurrentTCB:00000000 $d
     /tmp/ccCbytqi.s:3935   .bss.xPendingReadyList:00000000 $d
     /tmp/ccCbytqi.s:3939   .bss.xPendingReadyList:00000000 xPendingReadyList
     /tmp/ccCbytqi.s:3942   .bss.xNumOfOverflows:00000000 $d
     /tmp/ccCbytqi.s:3946   .bss.xNumOfOverflows:00000000 xNumOfOverflows
     /tmp/ccCbytqi.s:3949   .bss.xTickCount:00000000 $d
     /tmp/ccCbytqi.s:3953   .bss.xTickCount:00000000 xTickCount
     /tmp/ccCbytqi.s:3956   .bss.pxOverflowDelayedTaskList:00000000 $d
     /tmp/ccCbytqi.s:3960   .bss.pxOverflowDelayedTaskList:00000000 pxOverflowDelayedTaskList
     /tmp/ccCbytqi.s:3963   .bss.uxTaskNumber:00000000 $d
     /tmp/ccCbytqi.s:3967   .bss.uxTaskNumber:00000000 uxTaskNumber
     /tmp/ccCbytqi.s:3970   .bss.xDelayedTaskList1:00000000 $d
     /tmp/ccCbytqi.s:3974   .bss.xDelayedTaskList1:00000000 xDelayedTaskList1
     /tmp/ccCbytqi.s:3977   .bss.xDelayedTaskList2:00000000 $d
     /tmp/ccCbytqi.s:3981   .bss.xDelayedTaskList2:00000000 xDelayedTaskList2
     /tmp/ccCbytqi.s:3984   .bss.uxPendedTicks:00000000 $d
     /tmp/ccCbytqi.s:3988   .bss.uxPendedTicks:00000000 uxPendedTicks
     /tmp/ccCbytqi.s:3991   .bss.xSuspendedTaskList:00000000 $d
     /tmp/ccCbytqi.s:3995   .bss.xSuspendedTaskList:00000000 xSuspendedTaskList
     /tmp/ccCbytqi.s:3998   .bss.uxTopReadyPriority:00000000 $d
     /tmp/ccCbytqi.s:4002   .bss.uxTopReadyPriority:00000000 uxTopReadyPriority
     /tmp/ccCbytqi.s:4005   .bss.xYieldPending:00000000 $d
     /tmp/ccCbytqi.s:4009   .bss.xYieldPending:00000000 xYieldPending
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
vListInitialise
ulPortSetInterruptMask
pvPortMalloc
vListInitialiseItem
pxPortInitialiseStack
vPortEnterCritical
vListInsertEnd
vPortExitCritical
vPortYield
vPortFree
uxListRemove
vPortValidateInterruptPriority
vPortClearInterruptMask
xTimerCreateTimerTask
xPortStartScheduler
vPortEndScheduler
vListInsert
